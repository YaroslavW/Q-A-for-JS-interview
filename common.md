# Часто задаваемые вопросы на интервью по JavaScript | Часть 1

<!-- ![logo for common questions](img/JS-common-bliz-50.jpg) -->
<p align="center">
<img src="img/JS-common-bliz-50.jpg" alt="logo-JS-common-blitz-poll">
</p>

## 1. Что такое JavaScript (JS)?

- JavaScript - это легкий интерпретируемый язык программирования с объектно-ориентированными возможностями, который позволяет встроить интерактивность в статические HTML-страницы.

---

## 2. Каковы основные особенности JavaScript?

- JavaScript - это легкий интерпретируемый язык программирования.
- JavaScript предназначен для создания сетевых приложений.
- JavaScript дополняет и интегрируется с Java.
- JavaScript дополняет и интегрируется с HTML.
- JavaScript открыт и кроссплатформенен.

---

## 3. Каковы преимущества JavaScript?

- Меньше взаимодействия с сервером. Вы можете проверить ввод пользователя перед отправкой страницы на сервер.
- Немедленная обратная связь с посетителями. Им не нужно ждать перезагрузки страницы, чтобы узнать, забыли ли они что-то ввести.
- Повышенная интерактивность. Вы можете создавать интерфейсы, которые реагируют, когда пользователь наводит на них курсор мыши или активирует их с помощью клавиатуры.

---

## 4. Почему javascript называется `Richer Interface` - (более богатый интерфейс)?

- Вы можете использовать JavaScript, чтобы включать такие элементы, как компоненты перетаскивания и ползунки, чтобы предоставить богатый интерфейс посетителям вашего сайта.

---

## 5. Является ли JavaScript чувствительным к регистру?

- Да, JavaScript - это **регистрозависимый язык**. Это означает, что ключевые слова языка, переменные, имена функций и любые другие идентификаторы всегда должны вводиться с одинаковой заглавной буквой.

---

## 6. Как мы можем создать объект в JS?

Например так:

```js
let object = {
  name: "obj",
  age: 10,
};
```

пустой объект можно создать:

1. синтаксис "конструктор объекта"

```js
let object = new Object();
```

2. синтаксис "литерал объекта"

```js
let obj = {};
```

---

## 7. Как мы можем прочитать свойства объекта в js?

- Можем записать и прочитать свойства объекта, используя точку (`.`).
- Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает. Для этого нужно использовать квадратные скобки `[name prop]`

```js
obj["big user"] = true;
```

или так:

```js
let key = "big user";
obj[key] = true;
```

Квадратные скобки в литеральной нотации можно использовать для создания _ввычисляемого свойства_.

```js
let car = prompt("Which car to buy?", "BMW");

let purchases = {
  [car]: 1, // имя свойства будет взято из переменной car
};

alert(purchases.BMW); // 1, если car="BMW"
```

Это точно тоже, как записать так:

```js
let car = prompt("Which car to buy?", "BMW");
let purchases = {};

// имя свойства будет взято из переменной car
purchases[car] = 1;
```

Первая фотрма записи более лаконична, понятна и предпочтительна!

---

## 8. Как создать массив в js и как читать элементы массива?

Мы можем определить пустые массивы с помощью литерала массива и конструктор следующим образом.

- `let x = [];`
- `let y = new Array;`

Можно объявить массив и так:

```js
let array = [1, "car", true, 55, NaN, { name: "Yaroslav" }];
```

Элемент массива можно получить указав в квадратных скобках его номер в массиве.

```js
console.log(array[1]); // car
```

Отсчет начинается с ноля!

Массив имеет свойство длины, которое полезно для итерации. Мы можем прочитать элементы массива следующим образом.

Самый старый цикл `for`

```js
for (var i = 0; i < x.length; i++)
```

Другой вариант цикла - `for..of`
Без доступа к ключам, но это бывает не так и важно.

```js
let cars = ["Mersedes", "Jaguar", "BMW", "Volvo"];
for (let car of cars) {
  console.log(car);
}
```

Так как массив является объектом, то можно и циклом `for..in`
Самый плохой подход использовать этот метод. Он затратный, медленный и переберет все что похоже на массив (псевдомасивы браузера и пр.)

```js
let cars = ["Mersedes", "Jaguar", "BMW", "Volvo"];
for (let key in cars) {
  console.log(cars[key]);
}
```

## 9. Сколько типов функций поддерживает JS?

- Функция в JavaScript может быть как именованной, так и анонимной. Может быть создана конструктором только в глобальной области видимости. Каждая функция JavaScript на самом деле является объектом функции.

```js
const sum = new Function("a", "b", "return a + b");
```

---

## 10. Как определить анонимную функцию?

- Анонимная функция может быть определена так же, как и обычная функция, но у нее не будет никакого имени.

---

## 11. Какой встроенный метод вызывает функцию для каждого элемента в массиве?

- Метод `forEach` вызывает функцию для каждого элемента в массиве.

```js
const array1 = ["a", "b", "c"];

array1.forEach((element) => console.log(element));
```

---

## 12. Какой тип переменной объявленной глобально или локально имеет приоритет над другими, если их имена совпадают?

- Локальная переменная имеет приоритет над глобальной переменной с тем же именем.

---

## 13. Разница между «`var`» и «`let`» ключевыми словами?

- `var` был в JS с самого начала, а `let` был представлен в ES2015 / ES6. `let` имеет область действия блока ограниченного скобками `{}`, а `var` имеет область действия функции.

---

## 14. Разница между «`==`» и «`===`»?

- «`==`» сравнивает только значения «`===`» сравнивает и значения, и типы.

---

## 15. Разница между «`undefined`» и «`null`» ключевыми словами?

- Когда вы определяете переменную, но не присваиваете ей никакого значения. `typeof (undefine) => undefine`
- Null- изночально присвоенное пустое значение переменной. `typeof(null)=> object`

---

## 16. Что такое прототипное наследование?

- Каждый объект имеет свойство, называемое прототипом, в которое мы можем добавлять методы, и когда вы создаете другой объект из него, то вновь созданный объект автоматически наследует свойство своего родителя.

---

## 17. Какой встроенный метод сортирует элементы массива?

- Метод сортировки - `sort()` сортирует элементы массива.

---

## 18. Какой встроенный метод меняет порядок элементов массива?

- Меняет порядок элементов массива - `reverse()` метод. Первый элемент становится последним, а последний становится первым элементом массива.

---

## 19. Что такое `SetTimeout()`?

- Когда вы устанавливаете время задержки выполнения функции, то она становится асинхронной, и ей приходится ждать в стеке, чтобы завершить выполнение.

---

## 20. Как добавить один новый элемент в конце массива в JavaScript?

- Метод `push()` добавляет один или несколько элементов в конец массива и возвращает новую длину массива.

---

## 21. Что такое замыкание и как вы его используете?

- Когда функция возвращает другую функцию, возвращающая функция сохраняет свою среду, и это называется замыканием.

Самый простой пример - счетчик:

```js
function makeCounter() {
  let count = 0;
  return function () {
    return count++;
  };
}

let counter1 = makeCounter();
let counter2 = makeCounter();

alert(counter1()); // 0
alert(counter1()); // 1
```

Внутренняя функция изменяет переменную во внешней функции, доступ к которой извне получить нельзя (сбросить счетчик извне).

---

## 22. Что выведит на страницу приведенный ниже код?

```html
<script>
  document.write({});
</script>
```

- `[object Object]`

---

## 23. Как вы можете перевести элемент в нижнем регистре в верхний регистр?

- Метод `toUpperCase()` возвращает значение вызывающей строки, преобразованное в верхний регистр.

---

## 24. Почему вызов `а()` проходит успешно, а вызов `b()` выдает ошибку?

```javascript
a(); //OK
b(); //error

var b = function () {
  alert("function b");
};

function a() {
  alert("function a");
}
```

- Функция `а()` инициализируется на этапе загрузки скрипта, она как бы "вслывает вверх" - **bubbling**, а функция `b()` инициализируется когда объявляется переменная `b`

---

## 25. Вывести алертом сообщение через три секунды после загрузки скрипта

- Два варианта:

```javascript
//---<<< 1 >>>
setTimeout(alert("Message", 3000));
// ---<<< 2 >>>
setTimeout(function () {
  alert("Message");
}, 3000);
```

---

---

# Часто задаваемые вопросы на интервью по JavaScript | Часть 2

## 26. Каковы все циклические структуры в JavaScript?

- Цикл `while`: Цикл `while` - это оператор потока управления, который позволяет повторно выполнять код в зависимости от заданного логического условия. Цикл `while` можно рассматривать как повторяющийся оператор `if`.

- цикл `for`: цикл `for` обеспечивает краткий способ записи структуры цикла. В отличие от цикла `while`, оператор `for` предоставляет инициализацию, условие и приращение / уменьшение в одной строке, обеспечивая тем самым более короткую и простую в отладке структуру цикла.

- `do while`: цикл `do-while` похож на цикл `while` с той лишь разницей, что он проверяет условие **после** выполнения операторов и, следовательно, является примером цикла управления выходом - Exit Control Loop.

- Метка (`label`) : Метка представляет собой оператор с индентификатором, который позволяет вам ссылаться на какое-то место в вашей программе. Например, вы можете использовать метку, чтобы обозначить цикл, а затем использовать операторы `break` или `continue`, чтобы указать, должна ли программа прерывать цикл или продолжать его выполнение.

  Инструкция метки (`label`) используется вместе с `break` или `continue` для альтернативного выхода из цикла. Оно добавляется перед блочным выражением в качестве ссылки, которая может быть использована в дальнейшем.

  Синтаксис метки следующий:

```js
let str = "";

loop1: for (let i = 0; i < 5; i++) {
  if (i === 1) {
    continue loop1;
  }
  str = str + i;
}

console.log(str);
// expected output: "0234"
```

- `break` : Используйте оператор `break`, чтобы прерывать цикл, переключать управление или в сочетании с оператором метка.

  Когда вы используете `break` без метки, он прерывает циклы `while`, `do-while` и `for` или сразу переключает управление к следующему выражению.
  Когда вы используете `break` с меткой, он прерывает специально отмеченное выражение.
  Синтаксис оператора может быть таким:

1. break;

Пример:

```js
for (i = 0; i < a.length; i++) {
  if (a[i] == theValue) {
    break;
  }
}
```

2. break Метка;
   Пример:

```js
var x = 0;
var z = 0;
labelCancelLoops: while (true) {
  console.log("Внешний цикл: " + x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Внутренний цикл: " + z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

- `continue` Оператор `continue` используется, чтобы шагнуть на шаг вперёд в циклах `while`, `do-while`, `for` или перейти к метке.

  Когда вы используете `continue` без метки, он прерывает текущую итерацию циклов `while`, `do-while` и `for` и продолжает выполнение цикла со следующей итерации. В отличие от `break`, `continue` не прерывает выполнение цикла полностью. В цикле `while` он прыгает к условию. А в `for` увеличивает шаг.
  Когда вы используете `continue` с меткой, он применяется к циклу с этой меткой.
  Синтаксис `continue` может выглядеть так:

1. continue;

```js
var i = 0;
var n = 0;
while (i < 5) {
  i++;
  if (i == 3) {
    continue;
  }
  n += i;
}
```

2. continue Метка;

```js
checkiandj: while (i < 4) {
  console.log(i);
  i += 1;
  checkj: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 != 0) {
      continue checkj;
    }
    console.log(j + " чётное.");
  }
  console.log("i = " + i);
  console.log("j = " + j);
}
```

- `for...in` .Оператор `for...in` проходит по всем перечислимым свойствам объекта. JavaScript выполнит указанные выражения для каждого отдельного свойства. Цикл `for...in` выглядит так:

Пример:

```js
let arr = ["AUDI A8", "2019", "brown"];
arr.cost = "$100.000";

for (key in arr) {
  console.log(`${key} = ${arr[key]}`);
}

// 0 = AUDI A8
// 1 = 2019
// 2 = brown
// cost = $100.000
```

- `for...of` Оператор `for...of` создаёт цикл, проходящий по перечислимым объектам (включая `Array`, `Map`, `Set`, объект `arguments` и так далее), вызывая на каждой итерации функцию с выражениями, которые надо выполнить для получения значения каждого отдельного свойства.

Пример:

```js
let arr = [3, 5, 7];
arr.foo = "hello";

for (let i in arr) {
  console.log(i); // выводит "0", "1", "2", "foo"
}

for (let i of arr) {
  console.log(i); // выводит "3", "5", "7"
}
```

---

## 27. Как изменить стиль / класс элемента?

Изменить стиль / класс элемента можно двумя способами.

- `document.getElementById("myText").style.fontSize = "16px;`

- `document.getElementById("myText").className = "class";`

---

## 28. Объясните, как читать и писать файл с помощью JavaScript?

- Функции [readFile()](https://ru.code-maven.com/reading-a-file-with-nodejs) используются для операции чтения.

```js
readFile(Path, Options, Callback);
```

Развернутое объяснение:

### Чтение файла с Node.js - блокирующее и неблокирующее

Node предоставляет библиотеку `fs` для работы с файловой системой. К примеру, для чтения файлов.

#### Асинхронное чтение файла (неблокирующее)

"Нормальный" способ чтения файлов в Node.js это чтение асинхронным способом. Это значит, что вы вызываете команду чтения файла и передаете `callback`, который будет вызван при завершении чтения. Это позволяет работать с несколькими запросами чтения параллельно.

Для этого мы можем использовать метод [readFile](https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback) из класса `fs`.

Пример:

```js
var fs = require("fs");

fs.readFile("DATA", "utf8", function (err, contents) {
  console.log(contents);
});

console.log("after calling readFile");
```

Для начала мы загружаем класс `fs` с помощью команды `require`. Затем вызываем метод `readFile`, который получает 3 параметра: имя файла ('DATA' в нашем случае), кодировку файла ('utf8' в примере) и функцию. Эта функция будет вызывана, когда завершится операция чтения файла. Функция получит два параметра. Первый - информация о каких-либо ошибках, второй - содержимое файла.

Как только программа будет запущена, Node начнет читать файл в фоновом режиме, но продолжит выполнение. Таким образом, сначала будет выполнен вызов `console.log('after calling readFile');`, который выведет этот текст в консоль. Затем, когда содержимое файла будет загружено в память, Node вызовет функцию, которую мы передали в метод `readFile`, и она выведет в консоль содержимое файла.

#### Синхронное чтение файла (блокирующее)

Люди, пришедшие из других языков программирования (из большинства), считают синхронное чтение файлов более очевидным. Я не знаю в какой ситуации вы захотите использовать синхронные операции в Node.js, но я вижу, что много асинхронных функций имеют синхронный вариант, наверное, этим кто-то пользуется.

Для чтения файлов вы можете использовать метод [readFileSync](https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options) из класса `fs`:

```js
var fs = require("fs");

var contents = fs.readFileSync("DATA", "utf8");
console.log(contents);
```

- Функции `writeFile()` используются для операции записи.

```js
writeFile(Path, Data, Callback);
```

Подробно:
Для записи файла в синхронном варианте используется функция `fs.writeFileSync()`, которая в качестве параметра принимает путь к файлу и записываемые данные:

```js
fs.writeFileSync("hello.txt", "Текст для записи в файл");
```

Также для записи файла можно использовать асинхронную функцию `fs.writeFile()`, которая принимает те же параметры:

```js
fs.writeFile("hello.txt", "Текст для записи в файл");
```

В качестве вспомогательного параметра в функцию может передаваться функция обратного вызова, которая выполняется после завершения записи:

```js
const fs = require("fs");

fs.writeFile("hello.txt", "Hello мир!", function (error) {
  if (error) throw error; // если возникла ошибка
  console.log("Асинхронная запись файла завершена. Содержимое файла:");
  let data = fs.readFileSync("hello.txt", "utf8");
  console.log(data); // выводим считанные данные
});
```

Следует отметить, что эти методы полностью перезаписывают файл. Если надо дозаписать файл, то применяются методы `fs.appendFile()/fs.appendFileSync()`:

```js
const fs = require("fs");

fs.appendFileSync("hello.txt", "Текст для записи в файл");

fs.appendFile("hello.txt", "Привет МИР!", function (error) {
  if (error) throw error; // если возникла ошибка

  console.log("Запись файла завершена. Содержимое файла:");
  let data = fs.readFileSync("hello.txt", "utf8");
  console.log(data); // выводим считанные данные
});
```

---

## 29. Что называется типизацией переменных в JavaScript?

- Возможность хранения в одной переменной разных типов данных.

```js
Geeks = 42;
Geeks = "GeeksforGeeks";
```

---

## 30. Как преобразовать строку любого формата в целое число в JavaScript?

- В JavaScript функция [parseInt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt) используется для преобразования строки в целое число. Эта функция возвращает целое число base, которое указано во втором аргументе функции `parseInt()`. Функция `parseInt()` возвращает `NaN` (не число), если строка не содержит число.

```js
console.log(parseInt("6", 10)); // 6
```

```js
console.log(parseInt("es6", 10)); //NaN
```

---

## 31. Объясните, как обнаружить операционную систему на клиентском компьютере?

- Чтобы обнаружить операционную систему на клиентском компьютере, можно просто использовать свойство `navigator.appVersion` или `navigator.userAgent`. Свойство `Navigator.appVersion` является свойством только для чтения и возвращает строку, представляющую информацию о версии браузера.

---

## 32. Какие типы всплывающих окон доступны в JavaScript?

- Существует три типа всплывающих окон, доступных в JavaScript.

1. Alert
2. Confirm
3. Prompt

---

## 33. В чем разница между окном предупреждения - `alert` и окном подтверждения - `confirmation`?

- В окне предупреждения - `alert` будет отображаться только одна кнопка, которая является кнопкой **«ОК»**. Он используется для информирования пользователя о соглашении, которое необходимо согласовать. Но в окне подтверждения - `confirmation` отображаются две кнопки **«ОК»** и **«Отмена»**, где пользователь может принять решение, соглашаться или нет.

---

## 34. В чем недостаток использования `innerHTML` в JavaScript?

- Использование `innerHTML` в JavaScript имеет много недостатков, поскольку контент будет заменён везде. Если вы используете `+= like “innerHTML = innerHTML + ‘html'”`, все равно старый контент заменяется HTML. Он сохраняет обработчики событий, прикрепленные к любым элементам DOM.

---

## 35. Какая польза от `void(0)`?

- [Void(0)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/void) используется для вызова другого метода без обновления страницы во время передачи параметра времени «ноль».

> Этот оператор позволяет вставлять выражения, которые производят дополнительные действия, в места, где ожидается undefined.

> Оператор void часто используется для получения примитивного значения undefined, используя "void(0)" (что эквивалентно "void 0"). В подобных случаях можно просто использовать глобальную переменную undefined (предполагая, что её значение по умолчанию не было изменено).

Когда браузер переходит по `javascript: URI`, он вычисляет код в URI и заменяет содержание страницы возвращенным значением, если оно не равно `undefined`. Можно воспользоваться оператором `void` для возврата `undefined`. Например:

```html
<a href="javascript:void(0);">
  Click here to do nothing
</a>

<a href="javascript:void(document.body.style.backgroundColor='green');">
  Click here for green background
</a>
```

Однако заметим, что не рекомендуется использовать псевдо-протокол `javascript:`. Лучше прибегнуть к другим альтернативам, таким, как обработчики событий.

---

## 36. Что такое `JavaScript Cookies`?

- Файлы `cookie` - это небольшие файлы, которые хранятся на компьютере пользователя. Они используются для хранения скромного объема данных, специфичных для конкретного клиента и веб-сайта, и могут быть доступны как веб-сервером, так и клиентским компьютером. Когда были изобретены файлы `cookie`, это были небольшие документы, содержащие информацию о вас и ваших предпочтениях. Например, когда вы выбираете язык, на котором вы хотите просматривать свой веб-сайт, веб-сайт будет сохранять информацию в документе, называемом `cookie`, на вашем компьютере, и в следующий раз, когда вы посетите веб-сайт, он сможет прочитать cookie сохраненные ранее.

---

## 37. Как создать `cookie` с помощью JavaScript?

- Чтобы создать `cookie` с помощью JavaScript, вам просто нужно присвоить строковое значение объекту `document.cookie`.

```js
document.cookie = "key1 = value1; key2 = value2; expires = date";
```

---

## 38. Как читать куки с помощью JavaScript?

- Значение `document.cookie` используется для создания файла `cookie`. Всякий раз, когда вы хотите получить доступ к `cookie`, вы можете использовать строку. Строка `document.cookie` содержит список пар **имя = значение**, разделенных точками с запятой, где **имя** - это имя файла `cookie`, а **значение** - его строковое значение.

---

## 39. Как удалить куки с помощью JavaScript?

- Удалить `cookie` гораздо проще, чем создать или прочитать `cookie`, вам просто нужно установить значение expires = «прошлое время» - `expires = “past time”` и убедиться, что определен правильный путь к `cookie`, только это не позволяет вам удалить `cookie`. :-)

---

## 40. Что такое escape-символы - `escape characters` и escape-функция - `escape() function`?

- Escape-символ `escape characters`: этот символ необходим, если вы хотите работать с некоторыми специальными символами, такими как одинарные и двойные кавычки, апострофы и амперсанды. Все специальные символы играют важную роль в JavaScript, чтобы проигнорировать это или напечатать этот специальный символ, вы можете использовать обратную косую черту escape-символа «`\`».

```javascript
// Need escape character
document.write("GeeksforGeeks: A Computer Science Portal "for Geeks" ")
document.write("GeeksforGeeks: A Computer Science Portal \"for Geeks\" ")
```

- Функция escape() - `escape() function`: функция escape () принимает строку в качестве параметра и кодирует ее, чтобы ее можно было передать на любой компьютер в любой сети, поддерживающей символы ASCII.

---

## 41. Имеет ли JavaScript область действия концептуального уровня - `concept level scope`?

- JavaScript не имеет области действия концептуального уровня, его объявленная переменная внутри любой функции имеет область действия внутри функции.

---

## 42. Как общие объекты могут быть созданы в JavaScript?

Для создания универсального объекта в JavaScript используйте:

```js
var I = new object();
```

---

## 43. Какие ключевые слова используются для обработки исключений?

- При выполнении кода JavaScript ошибки почти наверняка возникнут. Эти ошибки могут возникать из-за ошибки со стороны программиста из-за неправильного ввода или даже если есть проблемы с логикой программы. Но все ошибки могут быть решены с помощью приведенных ниже команд.

1. Оператор `try` позволяет вам протестировать блок кода на наличие ошибок.
2. Оператор `catch` позволяет вам обработать ошибку, если она есть.
3. Оператор `throw` позволяет вам создавать свои собственные ошибки.

---

## 44. Какая польза от `blur function`?

`blur function` используется для удаления фокуса с выбранного элемента. Этот метод запускает событие размытия - `blur event` или к нему можно прикрепить функцию, запускаемую при возникновении `blur event` - события размытия.

---

## 45. Что такое метод `unshift` в JavaScript?

Он используется для вставки элементов в начало массива. Это как метод `push`, но он вставляет элементы в начало массива.

---

## 46. В чем заключается разница между классовым и прототипным наследованием?

- **Классовое наследование**: экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор `new`. Экземпляр класса может не содержать дескриптор `class` начиная с ES6.

- **Прототипное наследование**: экземпляры наследуются напрямую от других объектов, реализуются через фабрики или `Object.create()` и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое.

---

## 47. Что такое двусторонняя связь данных и однонаправленный поток данных и в чем разница между ними?

- Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот.

- Однонаправленный поток данных означает, что только модель – источник истины. Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о намерении модели (или "`store`" в терминах React). Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание.

- Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.

---

## 48. Каковы плюсы и минусы функционального и объектно-ориентированного программирования?

- Плюсы ООП: простая для понимания концепция объектов и методов вызова. ООП стремится использовать _императивный_ стиль, нежели _декларативный_, который читается как прямой набор машинных инструкций.

- Минусы ООП: как правило, присутствует зависимость от общих состояний. Объекты и их поведение связаны одной сущностью, к которой случайно может быть получен доступ любым количеством функций в неопределенном порядке, что может привести к непредсказуемому поведению, например, состоянию гонки.

- Плюсы ФП: используется функциональная парадигма, позволяющая избежать общих состояний и нежелательных эффектов, исключаются ошибки, возможные из-за конкурирования функций. Благодаря таким фичам, как неявное программирование, функции, как правило, радикально упрощаются и легко перестраиваются для более легкого, по сравнению с ООП, повторного использования кода.

- Вычисления, использующие чистые функции легко масштабируются на несколько процессоров или распределенных вычислительных кластеров без опасения возникновения борьбы за ресурсы.

- Минусы ФП: чрезмерная эксплуатация функциональных подходов, вроде неявного программирования, может привести к снижению читабельности кода, так как конечный код получается более абстрактным, кратким и менее конкретным.

- Чаще люди больше знакомы с ООП и императивным подходом, так что некоторые общие идиомы функционального программирования могут вызывать трудности у новичков.

- Функциональное программирование имеет более крутую кривую обучения, нежели ООП, имеющего большую популярность и более понятного для изучения. Концепции ФП часто описываются идиомами и обозначениями из лямбда-исчислений, алгебры и теории категорий, требующих знаний основ в этих областях для понимания.

---

## 49. Когда классовое наследование – подходящий выбор?

- Вопрос с подвохом. Правильный ответ – никогда. Композиция – более простой и гибкий подход, чем наследование классов.

---

## 50 Что значит "композиция объектов лучше, чем наследование классов"?

- Это цитата из книги “Design Patterns: Elements of Reusable Object-Oriented Software”. Повторное использование кода должно достигаться за счет сборки малых единиц функциональности в новый объект, а не наследованием классов и созданием иерархий.

---

---

# Часто задаваемые вопросы на интервью по JavaScript | Часть 3

## 51. Что-такое хэш-таблица?

Хэш-табли́ца или хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции:

- операцию добавления новой пары,
- операцию поиска и
- операцию удаления пары по ключу.

Подробней: https://ru.wikipedia.org/wiki/Хеш-таблица

---

## 52. Что такое `web workers` и зачем они нужны?

`Web Workers` предоставляют простое средство для запуска скриптов в фоновом потоке. Поток Worker'а может выполнять задачи без вмешательства в пользовательский интерфейс. К тому же, они могут осуществлять ввод/вывод, используя `XMLHttpRequest` (хотя атрибуты `responseXML` и `channel` всегда будут равны `null`). Существующий Worker может отсылать сообщения в JavaScript код, который его создал, отправляя сообщения в обработчик событий, указанный этим кодом (и наоборот).

`Web worker` – это асинхронная система или протокол, позволяющий веб-страницам выполнять задачи в фоновом режиме независимо от основного потока и пользовательского интерфейса веб-сайта. Это изолированная среда, которая изолирована от объекта `window`, объекта `document`, прямого доступа в Интернет и лучше всего подходит для длительных или сложных вычислительных задач.

Помимо `web worker` – системы, предназначенной для многопоточности, – существуют и другие способы выполнения асинхронной обработки в JavaScript, такие как асинхронные вызовы Ajax и цикл обработки событий (`event loop`).

Подробней: https://developer.mozilla.org/ru/docs/DOM/Using_web_workers

---

## 53. Какие ограничения накладываются на поток `Web Worker`?

Потоки `web worker` не могут изменять HTML элементы, глобальные переменные и некоторые свойства окон, такие как `window.location`. Вы можете использовать типы данных javascript, вызовы `XMLHttpRequest` и прочее.

Сценарий должен обслуживаться с того же хоста или домена из соображений безопасности, и это также будет причиной того, что web worker не будут работать, если мы откроем файл локально с помощью схемы `file://`.

#### Разделение потоков

Здесь важно отметить разделение область видимости `window` и `document` в потоке основного окна браузера и `worker`.

Чтобы использовать поток `worker`, эти две области должны иметь возможность обмениваться данными. Для этого мы используем функцию `postMessage()` в файле `worker.js` – для отправки сообщений в основной поток браузера – и `listener` (слушиватель) `worker.onmessage` в главном потоке для получения сообщений от `worker`.

Мы также можем отправлять сообщения из основного потока браузера в поток `worker`. Единственное отличие состоит в том, что мы вызываем `worker.postMessage()` в главном потоке, а `onmessage` в потоке `worker`.

Мы можем использовать метод `terminate()`, чтобы завершить выполнение `worker`.

Имея все это в виду, мы подходим к этому примеру:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Web Workers Example</title>

    <style type="text/css">
      body {
        padding-top: 28px;
      }
      .output-cont {
        margin-left: 12%;
        margin-top: 28px;
      }

      .output-cont h3 {
        width: 200px;
        height: 100%;
      }
      .output-cont button {
        padding: 4px 8px;
        font-size: 1.1rem;
        font-family: sans-serif;
      }
    </style>
  </head>

  <body>
    <div class="output-cont">
      <button onclick="testWorker()">start worker</button>
      <h3 id="workerOutput"></h3>
      <button onclick="terminateWorker()">terminate worker</button>
    </div>
    <br />
    <div class="output-cont">
      <button onclick="testMainThread()">start blocking thread</button>
      <h3 id="mainThreadOutput"></h3>
    </div>
    <br />
    <div class="output-cont">
      <button onclick="alert('browser responsive!')">
        test browser responsiveness
      </button>
    </div>

    <script>
      var worker;

      function testWorker() {
        if (typeof Worker !== "undefined") {
          if (typeof worker == "undefined") {
            worker = new Worker("worker.js");
          }
          worker.onmessage = function (event) {
            document.getElementById("workerOutput").innerHTML = event.data;
          };
        } else {
          document.getElementById("workerOutput").innerHTML =
            "Web Workers are not supported in your browser";
        }
      }
      function terminateWorker() {
        worker.terminate();
        worker = undefined;
      }

      function testMainThread() {
        for (var i = 0; i < 200000; i++) {
          document.getElementById("mainThreadOutput").innerHTML =
            "Main Thread Counter: " + i;
        }
      }
    </script>
  </body>
</html>
```

и worker.js:

```js
i = 0;
while (i < 200000) {
  postMessage("Web Worker Counter: " + i);
  i++;
}
```

![Worker img](img/webworker.gif)

Теперь мы можем видеть, что рабочий поток не блокирует интерактивность основного процесса браузера, а циклический вывод 200 000 номеров не влияет на основной поток. Числа в элементе `#workerOutput` обновляются на каждой итерации.

Блокирующий поток, или основной поток, когда задействован в цикле, блокирует всю интерактивность (здесь мы установили число итераций 200 000, но это будет еще более очевидно, если мы увеличим его до 2 000 000).

Еще одна вещь, которая указывает нам на заблокированный основной поток, заключается в том, что рабочий процесс обновляет страницу на каждой итерации, а цикл в главном потоке (определенный в `index.html`) обновляет только элемент `#mainThreadOutput` на последней итерации.

Это связано с тем, что браузер слишком занят подсчетом (`цикл for`), чтобы иметь возможность перерисовывать DOM, поэтому он делает это только после того, как его работа с циклом `for` полностью завершена (в конце цикла)

---

## 54. Как создать поток `web worker` в JavaScript?

Мы используем их следующим образом: мы проверяем наличие конструктора `Worker()` в браузере, и, если он доступен, мы создаем экземпляр рабочего объекта с URL-адресом сценария в качестве аргумента. Этот скрипт будет выполняться в отдельном потоке.

```js
if (typeof Worker !== "undefined") {
  worker = new Worker("worker.js");
}
```

Подробней:

- https://developer.mozilla.org/ru/docs/DOM/Using_web_workers
- https://habrahabr.ru/post/132785/
- https://webdevblog.ru/javascript-web-workers-rukovodstvo-dlya-nachinajushhih/

---

## 55. Как уничтожить объект web worker?

`w.terminate();`

---

## 56. Зачем в HTML 5 введены события `server-sent`?

Разрабатывать web-приложения, использующие Server-Sent Events намного проще, чем с использованием websockets. Нужно всего лишь немного кода на стороне сервере, чтобы переправлять события web-приложению, но клиентская часть кода для обработки этих событий работает почти точно так же, как и для любых других событий.

Подробней:

- https://ru.wikipedia.org/wiki/Server-sent_events
- https://habrahabr.ru/post/120429/
- https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events/Using_server-sent_events

---

## 57. Что такое неопределенные (`undefined`) и необъявленные (`undeclared`) переменные?

- `undefined` - значение
- `undeclared`- ошибка ReferenceError

Пример:

```js
typeof a; //'undefined'
a; //ReferenceError: a is not defined
```

_Проблема_: оператор `typeof` говорит нам, что тип необъявленной переменной — `undefined`, но при обращении к ней происходит ошибка.
_Объяснение_: на самом деле, есть 2 понятия — `Undefined` и `Undeclared`. Так вот, необъявленная переменная является `Undeclared`-переменной и обращение к ней вызывает ошибку. Объявленная, но не инициализированная переменная принимает значение `undefined` и при обращении к ней ошибок не возникает.
_Совет_: перед обращением к переменной, вы должны быть уверенны, что она объявлена. Если вы обратитесь к `Undeclared`-переменной, то код, следующий за обращением, не будет выполнен.

Подробней: https://habrahabr.ru/post/159313/

---

## 58. Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.

```js
function numberGenerator() {
  // Локальная «свободная» переменная, которая доступна только в замыкании
  var num = 1;
  function checkNumber() {
    console.log(num);
  }
  num++;
  return checkNumber;
}

var number = numberGenerator();
number(); // 2
```

В примере функция `numberGenerator` создаёт локальную «свободную» переменную `num` (число) и `checkNumber` (функция, которая выводит число в консоль). Функция `checkNumber` не содержит собственной локальной переменной, но благодаря замыканию она имеет доступ к переменным внутри внешней функции, `numberGenerator`. Поэтому объявленная в `numberGenerator` переменная `num` будет успешно выведена в консоль, даже после того, как `numberGenerator` вернёт результат выполнения.

Подробней

- https://htmlacademy.ru/blog/195-lets-learn-javascript-closures
- https://habrahabr.ru/post/38642/

---

## 59.Объясните "JavaScript module pattern" и где он (паттерн) применяется?

Первостепенная задача не засорять пространство имен, но с модульностью ES2015 как таковая необходимость отпала.

«Модуль», позволяет скрывать приватную информацию в замыканиях, давая доступ лишь к тому, что решил сделать общедоступным разработчик.

Благодаря этому мы можем защищать код от несанкционированного вмешательства и защищать глобальную область видимости от загрязнения. Если этого не делать, то, с одной стороны, работа внутренних механизмов модулей может быть случайно или целенаправленно нарушена, из-за того, что внешний код обращается к функциям или переменным, к которым он обращаться не должен. С другой стороны, если не пользоваться описанным здесь подходом, в глобальную область видимости попадает много ненужного, что может, например, привести к конфликтам имён.

Этот шаблон позволяет скрывать детали реализации модулей, защищая их от случайных или намеренных изменений, и помогает поддерживать в чистоте глобальную область видимости.

Подробнее

- https://habr.com/ru/company/ruvds/blog/419997/

---

## 60. Как Вы организуете свой код? (`module pattern`, наследование)?

Теперь пришло время поговорить о приватных переменных и функциях. Например, это могут быть некие вспомогательные функции, обеспечивающие работу внутренних механизмов модуля.

Это могут быть временные переменные, или переменные, играющие роль хранилищ неких данных, доступ к которым мы хотим жёстко контролировать. Нас интересует такое устройство модуля, когда внешнему миру доступно лишь то, что должно быть доступно, а всё остальное оказывается скрытым. Собственно говоря, приватным станет всё то, что, в нашем примере, будет объявлено за пределами объекта, возвращаемого из IIFE.

```js
  var privateMethod = function () {

  };
  return {
    publicMethod: function () {

    }
  };
})();
```

Метод `publicMethod` из этого примера можно вызвать извне, а функцию `privateMethod` — нет, так как она находится в приватной области видимости, в замыкании. Именно подобные функции, недоступные извне, могут выполнять роль вспомогательных механизмов модулей. Они могут использоваться для управления внутренними структурами данных, для выполнения каких-то вызовов к неким сервисам, и в других ситуациях.

При работе с подобными функциями нужно учитывать, что к ним можно обращаться из других функций, объявленных в той же области видимости, в том числе — и из методов возвращённого из IIFE объекта, причём, даже после того, как выполнена команда `return`, возвращающая этот объект. То есть, общедоступные методы имеют доступ к приватным функциям, они могут с ними взаимодействовать, но в глобальной области видимости эти приватные функции недоступны.

```js
var Module = (function () {
  var privateMethod = function () {};
  return {
    publicMethod: function () {
      // у этого метода есть доступ к privateMethod, мы можем вызвать его здесь так:
      // privateMethod();
    },
  };
})();
```

Благодаря этому мы можем защищать код от несанкционированного вмешательства и защищать глобальную область видимости от загрязнения. Если этого не делать, то, с одной стороны, работа внутренних механизмов модулей может быть случайно или целенаправленно нарушена, из-за того, что внешний код обращается к функциям или переменным, к которым он обращаться не должен. С другой стороны, если не пользоваться описанным здесь подходом, в глобальную область видимости попадает много ненужного, что может, например, привести к конфликтам имён.

Вот пример объекта, возвращаемого из IIFE, который содержит общедоступные методы и может обращаться к приватным функциям:

```js
var Module = (function () {
  var myModule = {};
  var privateMethod = function () {};
  myModule.publicMethod = function () {};
  myModule.anotherPublicMethod = function () {};
  return myModule; // возвращает объект с общедоступными методами
})();

// использование модуля
Module.publicMethod();
```

#### Именование приватных и общедоступных функций

Существует одно соглашение, в соответствии с которым в начале имён приватных функций ставят знак подчёркивания. Это позволяет, лишь взглянув на код, понять, какие функции являются внутренними, а какие — общедоступными. Например, выглядеть это может так:

```js
var Module = (function () {
  var _privateMethod = function () {};
  var publicMethod = function () {};
  return {
    publicMethod: publicMethod,
  };
})();
```

Подробней:

- https://habr.com/ru/company/ruvds/blog/419997/
- https://habrahabr.ru/post/131714/

---

## 61. В чем разница между `host`-объектами и нативными объектами?

_Встроенные объекты_: `String`, `Math`, `RegExp`, `Object`, `Function` и т.д. - основные предопределенные объекты, всегда доступные в JavaScript. Определено в спецификации ECMAScript.

_Объекты хоста_: объекты типа `window`, `XmlHttpRequest`, узлы `DOM` и т.д., которые предоставляются средой браузера. Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста. Если JavaScript работает за пределами браузера, например, на языке сценариев на стороне сервера, например, в Node.js, будут доступны разные объекты хоста.

_Объекты пользователя_: объекты, определенные в JavaScript-коде.

---

## 62.В чем разница между `.call` и `.apply`?

- `.call()` - вызывает ту же функцию с указанными аргументами

* `.apply()` - вызывает ту же функцию с аргументами, указанными в массиве

* `.bind()` - создает новую функцию с тем же самым телом функции с заданным значением `this` (первый аргумент) и возвращает эту функцию.

Во всех случаях первый аргумент используется как значение `this` внутри функции.

Подробней:

- https://learn.javascript.ru/call-apply
- https://habrahabr.ru/sandbox/33838/

---

## 63.Что делает и для чего нужна функци `Function.prototype.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Подробней: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

---

## 64. Объясните, как работает наследование в JavaScript?

Модель наследования в JavaScript может озадачить опытных разработчиков на высокоуровневых объектно-ориентированных языках (таких, например, как Java или C++), поскольку она динамическая и не включает в себя реализацию понятия `class` (хотя ключевое слово `class`, бывшее долгие годы зарезервированным, и приобрело практическое значение в стандарте ES2015, однако, `class` в JavaScript ES>=6 представляет собой лишь "синтаксический сахар" поверх прототипно-ориентированной модели наследования).

В плане наследования JavaScript работает лишь с одной сущностью: объектами. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство `prototype` равно `null`. По определению, `null` не имеет прототипа и является завершающим звеном в цепочке прототипов.

Хотя прототипную модель наследования некоторые относят к недостаткам JavaScript, на самом деле она мощнее классической. К примеру, поверх неё можно предельно просто реализовать классическое наследование, а вот попытки совершить обратное непременно вынудят вас попотеть.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
- https://learn.javascript.ru/class-inheritance
- https://habrahabr.ru/post/131714/

---

## 65. Расскажите, как работает прототипное наследование

Этот вопрос очень часто задают на собеседованиях. Все объекты в JavaScript имеют свойство `prototype`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее [делегирование, чем наследование](https://davidwalsh.name/javascript-objects).

Ссылки

- https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson
- https://davidwalsh.name/javascript-objects

---

## 66.Что вы думаете о `AMD` против `CommonJS`?

Оба являются способами реализации системы модулей, которая изначально не присутствовала в JavaScript до появления ES2015. `CommonJS` является синхронным, в то время как `AMD` (Asynchronous Module Definition, асинхронное определение модуля) — соответственно, асинхронным. `CommonJS` разработан с учетом разработки на стороне сервера, в то время как `AMD` с поддержкой асинхронной загрузки модулей больше предназначена для браузеров.

Я считаю синтаксис `AMD` довольно многословным, а `CommonJS` ближе к стилю, который используется в выражениях импорта в других языках. В большинстве случаев я считаю `AMD` ненужным, потому что если вы разместите весь свой код в одном объединенном файле, то вы не сможете воспользоваться свойствами асинхронной загрузки. Кроме того, синтаксис `CommonJS` ближе к стилю написания модулей Node, и поэтому происходит меньше путаницы при переключении между клиентской и серверной разработкой на JavaScript.

Я рад, что с появлением модулей ES2015, которые поддерживают как синхронную, так и асинхронную загрузку, мы, наконец, можем придерживаться одного подхода. Несмотря на то, что они не полностью поддерживаются во всех браузерах и Node, мы можем использовать транспайлеры для преобразования нашего кода.

Ссылки

- https://auth0.com/blog/javascript-module-systems-showdown/
- https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs

---

## 67.Объясните, почему это не является IIFE: `function foo(){ }();`. Что необходимо изменить, чтобы это стало IIFE??

`IIFE` расшифровывается как `Immediately Invoked Function Expression` — немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ }();` как `function foo(){ }` и `();`, где первое выражение — это объявление функции, а второе (пара скобок) — попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются **объявлениями функций**. Оборачивая эту функцию внутри`()`, она становится **функциональным выражением**, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

Вы также можете использовать оператор `void` — `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше `IIFE` возвращает что-либо, вы не можете его использовать. Пример:

```js
const foo = void function bar() { return ‘foo’; }();
console.log(foo); // undefined
```

Ссылки

- http://lucybain.com/blog/2014/immediately-invoked-function-expression/
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void

---

## 68.В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?

**Необъявленные** переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`, `let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок`try/catch`.

```js
function foo() {
  x = 1; // ReferenceError в строгом режиме
}
foo();
console.log(x); // 1
```

Переменная `undefined` — это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Чтобы проверить это, сравните, используя оператор строгого равенства (`===`) или `typeof`, который вернет строку `undefined`. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет `true`, если значение равно `null`.

```js
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === ‘undefined’); // true
console.log(foo == null); // true. Неправильно, не используйте это для проверки!
function bar() {}
var baz = bar();
console.log(baz); // undefined
```

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (`==`) для проверки, так как он также вернет `true`, если значение равно `undefined`.

```js
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === ‘object’); // true
console.log(foo == undefined); // true. Неправильно, не используйте это для проверки!
```

Личная привычка — я никогда не оставляю свои переменные необъявленными или неприсвоенными. Я явно назначаю им null после объявления, если я не собираюсь их пока использовать. Если вы используете линтер в своем рабочем процессе, он обычно также проверяет, что вы не ссылаетесь на необъявленные переменные.

Ссылки

- https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables
- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var

---

## 69.Что такое замыкание и как/для чего его используют?

Замыкание — это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово “лексический” относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания — это функции, которые имеют доступ к переменным внешней (замыкающей) функции — цепочке областей видимости даже после того, как внешняя функция вернулась.

### Для чего его используют?

- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий. Обычно используется в [модульном паттерне](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript).

- [Частичное применение функций или каррирование.](https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8)

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
- https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36

---

## 70. Можете ли вы описать основное различие между циклом `.forEach` и циклом `.map()`? И в каких случаях каждый из них используется?

Чтобы понять разницу между ними, давайте посмотрим, что делает каждая функция.

### forEach

- Перебирает элементы в массиве.
- Вызывает `callback-функцию` для каждого элемента.
- Не возвращает значение.

```js
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  // Делаем что-либо с num и/или index.
});
// doubled = undefined
```

### map

- Перебирает элементы в массиве.
- “Сопоставляет” каждый элемент с новым элементом, вызывая функцию для каждого элемента, создавая в результате новый массив.

```js
const a = [1, 2, 3];
const doubled = a.map((num) => {
  return num * 2;
});
// doubled = [2, 4, 6]
```

Основное различие между `.forEach` и `.map()` состоит в том, что `.map()` возвращает новый массив. Если вам нужен результат, но вы не хотите изменять исходный массив, `.map()` — очевидный выбор. Если вам просто нужно перебрать массив, то стоит воспользоваться `forEach`.

Ссылки

- https://codeburst.io/javascript-map-vs-foreach-f38111822c0f

---

## 71. В каких случаях обычно используются анонимные функции?

Они могут использоваться в `IIFE` для инкапсуляции кода в локальную область видимости, чтобы объявленные в ней переменные не попадали в глобальную область видимости.

```js
(function () {
  // Здесь код функции.
})();
```

Как `callback`-функция, которая используется один раз и не должна использоваться где-либо еще. Код будет казаться более автономным и читаемым, когда обработчики будут определены прямо внутри вызывающего их кода, а не искать в другом месте, чтобы найти тело функции.

```js
setTimeout(function () {
  console.log("Hello world!");
}, 1000);
```

Аргументы в конструкциях функционального программирования или `Lodash` (аналогично `callback`-функциям).

```js
const arr = [1, 2, 3];
const double = arr.map(function (el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]
```

Ссылки

- https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions
- https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo

---

## 72.Как вы организуете свой код? (module pattern, classical inheritance)

В прошлом я использовал `Backbone`, который поощряет ООП подход, создавая Backbone модели и добавляя к ним методы.

Модульный паттерн до сих пор хорош, но в настоящее время я использую `React/Redux`, который использует однонаправленный поток данных на основе архитектуры `Flux`. Я создаю модели своего приложения при помощи простых объектов и пишу чистые функции для управления этими объектами. Состояние управляется при помощью экшенов и редьюсеров, как в любом другом приложении `Redux`.

Я избегаю использования наследования классов, где это возможно. Если же мне это необходимо сделать, то я придерживаюсь [этих правил](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4).

---

## 73. Что такое объект `arguments`?

`Arguments` — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство `length`, мы можем получить доступ к определенному значению с помощью `arguments[i]`, но у него отсутствуют методы `forEach`, `reduce`, `filter` и `map`. Он позволяет узнать количество параметров функции.

Преобразовать `arguments` в массив можно с помощью `Array.prototype.slice`:

`Array.prototype.slice.call(arguments)`

Запомните: в стрелочных функциях объект `arguments` **не работает**.

```js
function one() {
    return arguments
}
const two = function() {
    return arguments
}
const three = function three({
    return arguments
})
const four = () => arguments

four() // arguments is not defined
```

Вызов функции `four` приводит к ошибке `ReferenceError: arguments is not defined`. Эту проблему можно решить с помощью оператора `rest`:

```js
const four = (...args) => args;
```

Это автоматически поместит все параметры в массив.

---

## 74. В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Я полагаю, что суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` — это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает `Person` как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается `undefined`, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта `Person` с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например: `Object.create(Person.prototype)`.

```js
function Person(name) {
  this.name = name;
}
var person = Person(‘John’);
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: Cannot read property ‘name’ of undefined
var person = new Person(‘John’);
console.log(person); // Person { name: “John” }
console.log(person.name); // “john”
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new

---

## 75. В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

```js
function add(a, b) {
  return a + b;
}
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

---

## 76. Что делает и для чего нужна функция `Function.prototype.bind`?

Взято дословно с MDN:

> Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
> По моему опыту, это наиболее полезно для привязки значения `this` в методах классов, которые вы хотите передать в другие функции. Это часто делается в компонентах React.

Ссылки

- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind

---

## 77. В каких случаях используется `document.write()`?

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает `document.open`, который очищает весь документ (`<head>`и `<body>` будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

В Интернете есть несколько ответов, которые объясняют, что `document.write()` используется в коде отслеживания или когда вы хотите добавить стили, которые должны работать только при включенном JavaScript. Он даже используется в шаблоне HTML5 для параллельной загрузки скриптов и сохранения порядка выполнения! Тем не менее, я подозреваю, что эти причины могут быть устаревшими, и в наши дни они могут быть достигнуты без использования `document.write()`. Пожалуйста, поправьте меня, если я ошибаюсь по этому поводу.

Ссылки

- https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html
- https://github.com/h5bp/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag

---

## 78.В чем разница между `feature detection` (определение возможностей браузера), `feature inference` (предположение возможностей) и анализом строки `user-agent`?

### `Feature detection` (определение возможностей браузера)

Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода - и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:

```js
if ("geolocation" in navigator) {
  // Можно использовать navigator.geolocation
} else {
  // Обработка отсутствия возможности
}
```

`Modernizr` - отличная библиотека для обработки таких функций.

### `Feature inference` (предположение возможностей)

Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует, например:

```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

Этот подход не рекомендуется. Первый подход более надежен.

### Строка `User Agent`

Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя от которого исходит запрос. Доступ к ней можно получить через `navigator.userAgent`. Тем не менее, строка `User Agent` сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome, так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте этого метода.

Ссылки

- https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection
- https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent

---

## 79. Расскажите об `Ajax` как можно более подробно

`Ajax` (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью `Ajax` веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, `Ajax` позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных `JSON` вместо `XML` из-за того, что `JSON` основан на JavaScript.

Раньше для асинхронного взаимодействия использовали `XMLHttpRequest API`, а сейчас принято использовать `fetch API`.

Ссылки

- https://en.wikipedia.org/wiki/Ajax_(programming)
- https://developer.mozilla.org/en-US/docs/AJAX

---

## 80. Какие преимущества и недостатки в использовании `Ajax`?

### Преимущества

- Повышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.

- Сокращение количества подключений к серверу, поскольку скрипты и таблицы стилей нужно запрашивать только один раз.

- Состояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.

- Большая часть преимуществ SPA.

### Недостатки

- Сложнее реализовать добавление динамической веб-страницы в закладки.
- Не работает, если в браузере отключен JavaScript.
- Некоторые поисковые роботы не выполняют JavaScript и не видят данные, загружаемые при помощи JavaScript.
- Большая часть недостатков SPA.

### Объясните, как работает `JSONP` (и почему это не совсем AJAX)

- `JSONP` (`JSON` с набивкой) - это способ, часто используемый для обхода политики ограничения домена в браузерах, потому что `Ajax`-запросы с текущей страницы к серверу, находящемуся в другом домене, запрещены.
- `JSONP` работает, отправляя запрос к серверу в другом домене через тег `script` и обычно с параметром запроса `callback`, например:https://example.com?callback=printData. Затем сервер обернет данные внутри функции с именем `printData` и вернет их клиенту.

**HTML**:

```html
<!-- https://mydomain.com -->
<script>
  function printData(data) {
    console.log(`My name is ${data.name}!`);
  }
</script>
<script src="https://example.com?callback=printData"></script>
```

**JS**:

// Файл загружен с `https://example.com?callback=printData printData({ name: 'Yang Shun' });`

У клиента должна быть функция `printData` в своей глобальной области видимости, и эта функция будет выполнена клиентом, когда будет получен ответ с сервера из другого домена.

`JSONP` может быть небезопасным и иметь повышенный риск. Поскольку `JSONP` - это действительно JavaScript, и он может делать все остальное, что может делать JavaScript, то вы должны быть уверены в надежности поставщика данных `JSONP`.
В наши дни, CORS является рекомендуемым подходом и `JSONP` является способом для его обхода.

Ссылки

- https://stackoverflow.com/a/2067584/1751946

---

## 81.Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?

Да. Handlebars, Underscore, Lodash, AngularJS, и JSX. Мне не нравилась шаблонизация в AngularJS, потому что там активно использовались строки в директивах и легко допустить ошибку при опечатке. JSX - мой новый фаворит, так как он ближе к JavaScript и почти не имеет дополнительного синтаксиса. В настоящее время вы даже можете использовать строковые литералы шаблонов ES2015 в качестве быстрого способа создания шаблонов, не полагаясь на сторонний код.

```js
const template = `<div>My name is: \${name}</div>`;
```

Однако следует помнить о возможном XSS в вышеприведенном подходе, поскольку содержимое не экранируется, в отличие от библиотек шаблонизации.

---

## 82 Расскажите, что такое поднятие (`hoisting`)

Поднятие (`hoisting`) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова `var`, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Однако, "поднимается" только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.

Обратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.

// объявления переменных через `var` поднимаются.

```js
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1
// объявления переменных через let/const НЕ поднимаются.
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

При объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.

// Объявление функции

```js
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
console.log(foo); // [Function: foo]
// Функциональное выражение
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
  console.log("BARRRR");
};
console.log(bar); // [Function: bar]
```

---

## 83.Объясните, что такое всплытие событий (`event bubbling`)

Когда событие срабатывает на элементе DOM, оно попытается обработать событие (если привязан обработчик), затем событие всплывет вверх к своему родителю и это повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть до `document`. Всплытие событий является механизмом, на котором основано делегирование событий.

---

## 84. В чем разница между "атрибутом" (`attribute`) и "свойством" (`property`)?

Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы проиллюстрировать разницу, представьте, что у нас есть это текстовое поле в HTML:

```html
<input type="text" value="Hello" />. const input =
document.querySelector('input'); console.log(input.getAttribute('value')); //
Hello console.log(input.value); // Hello
```

Но после того, как вы измените значение текстового поля, добавив к нему "`World!`", будет:

```js
`console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

Ссылки

- https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html

---

## 84. Почему не следует расширять нативные JavaScript-объекты?

Расширение встроенного/нативног объекта JavaScript означает добавление свойств/функций к его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на практике это опасно. Представьте, что ваш код использует несколько библиотек, которые расширяют `Array.prototype`, добавляя один и тот же метод `contains`. В результате код будет работать неверно, если поведение этих двух методов не будет одинаковым.

Единственный случай, при котором можно расширить нативный объект — это при создании полифила, создав собственную реализацию метода, который является частью спецификации JavaScript, но может отсутствовать в устаревших браузерах.

Ссылки

- http://lucybain.com/blog/2014/js-extending-built-in-objects/

---

## 85. В чем разница между событием `load` и событием `DOMContentLoaded`?

Событие `DOMContentLoaded` вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.
Событие `load` происходит только после загрузки DOM и всех зависимых ресурсов.

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded
- https://developer.mozilla.org/en-US/docs/Web/Events/load

---

## 86. В чем разница между `==` и `===`?

`==` — это оператор абстрактного сравнения, а `===` — оператор строгого сравнения.

Оператор `==` будет сравнивать на равенство после выполнения любых необходимых преобразований типов.

Оператор `===` не будет выполнять преобразование типов, поэтому, если два значения не одного типа, `===` просто вернет `false`. При использовании `==` могут происходить такие странные вещи, как:

```js
1 == "1"; // true
1 == [1]; // true
1 == true; // true
0 == ""; // true
0 == "0"; // true
0 == false; // true
```

А если сравнить null и undefined с другими ложными значениями при помощи оператора нестрогого сравнения (`==`), то окажется, что они не равны ничему, кроме самих себя:

```js
null == 0; // false
undefined == ""; // false
null == false; // false
undefined == false; // false
null == undefined; // true
```

Мой совет — никогда не используйте оператор `==`, за исключением удобного сравнения с `null` или `undefined`, где выражение `a == null` вернет `true`, если `a` принимает значение `null` или `undefined` .

```js
var a = null;
console.log(a == null); // true
console.log(a == undefined); // true
```

Ссылки

- https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons
- https://frontender.info/exploring-the-abyss-of-null-and-undefined-in-javascript/

---

## 87. Объясните `same-origin policy` в контексте JavaScript

`Same-origin policy` (принцип одинакового источника) не позволяет JavaScript выполнять запросы за границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа `DOM` этой страницы.

Ссылки

- https://en.wikipedia.org/wiki/Same-origin_policy

---

## 88. Сделайте так, чтобы этот код работал:

```js
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
```

Решение:

```js
function duplicate(arr) {
  return arr.concat(arr);
}
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
```

---

## 89. Почему тернарный оператор так называется?

“Тернарный” означает три. Троичное выражение принимает три операнда: условие, выражение “`then`” и выражение “`else`”. Тернарные операторы не являются исключительными для JavaScript, и я не знаю, почему подобный вопрос был добавлен в этот список.

Ссылки

- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operat

---

## 90. Что делает строчка “`use strict`”;? Какие достоинства и недостатки от ее использования?

`use strict` это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.

**Преимущества**:

- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).
- Требует, чтобы имена параметров функции были уникальными.
- `this` в глобальной области видимости равно `undefined`.
- Перехватывает распространенные ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.

**Недостатки**:

- Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- Нет доступа к `function.caller` и `function.arguments`.
- Объединение скриптов, написанных в строгом режиме может вызвать проблемы.

В целом, я думаю, что преимущества перевешивают недостатки, и мне никогда не приходилось полагаться на функции, которые заблокированы в строгом режиме. Я бы порекомендовал использовать строгий режим.

Ссылки

- http://2ality.com/2011/10/strict-mode-hatred.html
- http://lucybain.com/blog/2014/js-use-strict/

---

## 91. Напишите цикл, который перебирает числа до `100`, возвращая ”`fizz`” на числа кратные`3`, ”`buzz`” на числа кратные `5` и ”`fizzbuzz`” на числа кратные `3` и `5`.

```js
for (let i = 1; i <= 100; i++) {
  let f = i % 3 == 0,
    b = i % 5 == 0;
  console.log(f ? (b ? "FizzBuzz" : "Fizz") : b ? "Buzz" : i);
}
```

Хотя я бы не советовал вам использовать этот код во время интервью. Просто придерживайтесь длинного, но ясного подхода. Также можете взглянуть на разные безумные реализации FizzBuzz, по ссылке ниже.

Ссылки

- https://gist.github.com/jaysonrowe/1592432

---

## 92. Почему считается хорошим тоном оставить глобальную область видимости (`global scope`) в нетронутом состоянии?

Каждый скрипт имеет доступ к глобальной области видимости, и если каждый будет использовать глобальное пространство имен для определения своих переменных, то могут возникнуть конфликты. Используйте модульный паттерн (используя IIFE) для инкапсуляции ваших переменных в локальное пространство имен.

---

## 93. Для чего используют событие `load`? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?

Событие `load` происходит в конце процесса загрузки документа. На этом этапе все объекты в документе находятся в DOM, и все изображения, скрипты и ссылки загрузились.
Событие DOM `DOMContentLoaded` будет запущено после создания DOM для страницы, но не будет ждать окончания загрузки других ресурсов. Оно предпочтительно в тех случаях, когда вам не нужно загружать страницу целиком перед инициализацией.

Ссылки:

- https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload

---

## 94. Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.

Текст ниже взят из замечательного [руководства по фронтенду от Grab](https://github.com/grab/front-end-guide).

В наши дни веб-разработчики называют свои продукты веб-приложениями, а не веб-сайтами. Хотя между этими двумя терминами нет строгой разницы, веб-приложения, как правило, очень интерактивны и динамичны, что позволяет пользователю выполнять действия и получать мгновенный ответ.

Традиционно браузер получает HTML с сервера и отображает его. Когда пользователь переходит на другой URL-адрес, требуется полное обновление страницы, и сервер отправляет свежий HTML-код на новую страницу. Это называется рендерингом на стороне сервера.

Однако в современных SPA вместо этого используется рендеринг на стороне клиента.

Браузер загружает начальную страницу с сервера вместе со скриптами (фреймворками, библиотеками, кодом приложения) и таблицами стилей, необходимыми для всего приложения. Когда пользователь переходит на другие страницы, обновление страницы не происходит. URL-адрес страницы обновляется при помощи [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).

Новые данные, необходимые для страницы (обычно в формате JSON), извлекаются браузером посредством запросов [AJAX](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started) к серверу. Затем SPA динамически обновляет страницу данными через JavaScript, которые были получены при начальной загрузке страницы. Эта модель похожа на работу нативных мобильных приложений.

### Преимущества:

- Приложение становится более отзывчивым, и пользователи не видят мерцание при навигации, т.к. страница не обновляется целиком.
- На сервер поступает меньше HTTP-запросов, так как одни и те же ресурсы не нужно загружать снова для каждой загрузки страницы.
- Четкое разделение на клиент и сервер. Вы можете легко создавать новые клиентские приложения для разных платформ (например, для мобильных устройств, чат-ботов, умных часов) без необходимости изменять код сервера. Вы также можете изменить технологический стек на клиенте и сервере независимо, пока между ними существует интерфейс.

### Недостатки:

- Более тяжелая первоначальная загрузка страницы из-за загрузки кода фреймворка, самого приложения и ресурсов.
- Ваш сервер должен быть сконфигурирован так, чтобы он направлял все запросы к единой точке входа, и переложил обязанности по навигации на сторону клиента.
- Для отображения содержимого SPA полагается на JavaScript, но не все поисковые системы выполняют JavaScript во время индексации, и они могут не увидеть содержимое страницы. Это вредит поисковой оптимизации (SEO) вашего приложения. Тем не менее, в большинстве случаев, когда вы создаете приложения, SEO не является наиболее важным фактором, так как не весь контент должен индексироваться поисковыми системами. Чтобы преодолеть это, вы можете либо рендерить свое приложение на стороне сервера, либо использовать такие сервисы, как Prerender, чтобы “рендерить ваш javascript в браузере, сохранять статический HTML и передавать его поисковым роботам”.

Ссылки

- https://github.com/grab/front-end-guide#single-page-apps-spas
- http://stackoverflow.com/questions/21862054/single-page-app-advantages-and-disadvantages
- http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/
- https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52

---

## 95. Насколько вы опытны в работе с промисами (`promises`) и/или их полифилами?

Обладаю практическими знаниями о них. Промис — это объект, который может вернуть одно значение в будущем: либо выполненное значение, либо причина, по которой оно не было выполнено (например, произошла ошибка сети).

Промис может находиться в одном из 3 возможных состояний: выполнено, отклонено или ожидает выполнения. При использовании промисов можно добавлять `callback`-функции для обработки выполненного значения или причины отказа.

Некоторыми распространенными полифилами являются `$.deferred`,`Q` и `Bluebird`, но не все они соответствуют спецификации. ES2015 поддерживает промисы “из коробки”, и в настоящее время полифилы обычно не нужны.

Ссылки

- https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261

---

## 96. Какие преимущества и недостатки при использовании промисов вместо колбэков (`callbacks`)?

### Преимущества:

- Помогает избежать “callback hell”, который может быть нечитаемым.
- Упрощает написание последовательного удобочитаемого асинхронного кода с помощью `.then()`.
- Упрощает написание параллельного асинхронного кода с помощью `Promise.all()`.
- С использованием промисов можно избежать следующих проблем, которые возникают при использовании `callback`-функций:
- Колбэк-функция была вызвана слишком рано
- Колбэк-функция была вызвана слишком поздно (или вовсе не была вызвана)
- Колбэк-функция была вызвана слишком мало или слишком много раз
- Не удалось передать необходимую среду/параметры
- Были пропущены ошибки/исключения

Недостатки

- Чуть более сложный код (спорно).
- В старых браузерах, где не поддерживается ES2015, вам нужно загрузить полифил, чтобы их использовать.

Ссылки

- https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md

---

## 97.Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?

Вот несколько языков, которые компилируются в JavaScript: CoffeeScript, Elm, ClojureScript, PureScript и TypeScript.

Преимущества:

- Исправляют некоторые давние проблемы в JavaScript и препятствует использованию анти-паттернов в JavaScript.
- Позволяют писать более короткий код, предоставляя синтаксический сахар поверх JavaScript, которого, как мне кажется, не хватало в ES5, но с приходом ES2015 все изменилось.
- Статическая типизация идеальна (в случае TypeScript) для больших проектов, которые необходимо поддерживать с течением времени.

Недостатки:

- Необходима сборка/компиляция кода, так как браузеры запускают только JavaScript, и ваш код должен быть скомпилирован в JavaScript перед тем, как он будет передан в браузеры.
- Отладка может быть трудной, если карты кода (source maps) плохо сопоставляются с исходным кодом.
- Большинство разработчиков не знакомы с этими языками и должны будут изучить их. Если ваша команда будет использовать их для своих проектов, это приведет к увеличению затрат.
- Меньшее сообщество (зависит от языка), что означает, что будет труднее найти ресурсы, учебные пособия, библиотеки и инструменты.
- Может отсутствовать поддержка в IDE/редакторе.
- Эти языки всегда будут позади последнего стандарта JavaScript.
- Разработчики должны знать, во что компилируется их код — потому что это то, что будет запускаться в браузере, и это наиболее важно.
  По большому счету, ES2015 значительно улучшил JavaScript и сделал разработку на нем намного удобнее. Я не вижу причин использовать CoffeeScript в наши дни.

Ссылки

- https://softwareengineering.stackexchange.com/questions/72569/what-are-the-pros-and-cons-of-coffeescript

---

## 98. Какие инструменты и методы вы используете при отладке кода?

### React и Redux:

- [React Devtools](https://github.com/facebook/react-devtools)
- [Redux Devtools](https://github.com/reduxjs/redux-devtools)

### Vue:

- [Vue Devtools](https://github.com/vuejs/vue-devtools)

### JavaScript:

- [Chrome Devtools](https://medium.com/hackernoon/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d)
- Выражение `debugger`
- Отладка при помощи старого доброго `console.log`

Ссылки

- https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d
- https://raygun.com/blog/javascript-debugging/

---

## 99. Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?

### Для объектов:

- `for-in` циклы — `for (var property in obj) { console.log(property); }`. Тем не менее, он также будет перебирать его унаследованные свойства, и вам нужно добавить проверку `obj.hasOwnProperty(property)` перед его использованием.
- `Object.keys() — Object.keys(obj).forEach(function (property) { … }). Object.keys()`- это статический метод, который возвращает все перечисляемые свойства объекта.
- `Object.getOwnPropertyNames() — Object.getOwnPropertyNames(obj).forEach(function (property) { … }). Object.getOwnPropertyNames()` — это статический метод, который возвращает все перечисляемые и неперечисляемые свойства объекта.

### Для массивов:

- Циклы `for — for (var i = 0; i < arr.length; i++)`. Распространенной ошибкой здесь является то, что `var` находится в области видимости функции, а не в блочной области видимости, и в большинстве случаев нам нужна переменная-итератор блочной области. ES2015 позволяет использовать `let`, который имеет блочную область видимости, и рекомендуется использовать его вместо `var`. В итоге: `for (let i = 0; i < arr.length; i++)`.
- `forEach — arr.forEach(function (el, index) { … })`. Эта конструкция иногда может быть более удобной, потому что вам не нужно использовать `inde`, если все, что вам нужно, это элементы массива. Существуют также методы `every и some`, которые позволят вам досрочно завершить итерацию.
- `for-of циклы — for (let elem of arr) { … }`. ES6 представил новый цикл `for-of`, который позволяет перебирать объекты, которые соответствуют [итерируемому протоколу](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols) такие как `String`, `Array`, `Map`, `Set`, и т.д. Он сочетает в себе преимущества цикла`for`и метода `forEach()`. Преимущество цикла`for` заключается в том, что его можно преждевременно завершить, а преимущество `forEach()` заключается в том, что он более лаконичен, чем цикл `for`, поскольку вам не нужна переменная счетчика. С циклом `for-of` вы получаете возможность выхода из цикла и более сжатый синтаксис.

В большинстве случаев я бы предпочел метод `.forEach`, но он зависит от того, что вы пытаетесь сделать. До ES6 мы использовали циклы `for`, если нам нужно было преждевременно завершить цикл при помощи `break`. Но теперь с ES6 мы можем сделать это с помощью циклов `for-of`. Я использую циклы `for`, когда мне нужно еще больше гибкости, например, в случае увеличения итератора более одного раза за цикл.
Кроме того, при использовании цикла `for-of`, если вам нужен доступ как к индексу, так и к значению каждого элемента массива, вы можете сделать это с помощью метода ES6 `entries()` и деструктуризации:

```js
const arr = ["a", "b", "c"];
for (let [index, elem] of arr.entries()) {
  console.log(index, ": ", elem);
}
```

Ссылки

- http://2ality.com/2015/08/getting-started-es6.html#from-for-to-foreach-to-for-of
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries

---

## 100. Объясните разницу между синхронными и асинхронными функциями

Синхронные функции являются блокирующими, а асинхронные — нет. В синхронных функциях одна операция должна завершиться, прежде чем будет запущена следующая операция. В этом случае скрипт выполняется строго по порядку операций, и выполнение скрипта приостанавливается, если одна из операций занимает очень много времени.

Асинхронные функции обычно принимают `callback`-функцию в качестве параметра, и выполнение продолжается на следующей строке сразу после вызова асинхронной функции. Callback-функция вызывается только тогда, когда асинхронная операция завершена и стек вызовов пуст. Ресурсоемкие операции, такие как загрузка данных с веб-сервера или запросы к базе данных, должны выполняться асинхронно, чтобы основной поток мог продолжать выполнять другие операции вместо блокировки до завершения этой долгой операции (в случае браузеров пользовательский интерфейс будет зависать).

---

## 101. Что такое цикл событий (`event loop`)? В чем разница между стеком вызовов (`call stack`) и очередью событий (`task queue`)?

Цикл событий — это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть `callback`-функции, то функция удаляется из очереди и помещается в стек вызовов для выполнения.

Рекомендую ознакомиться с [докладом о цикле событий от Philip Robert](https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html). Это одно из самых популярных видео о JavaScript.

Ссылки

- https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html
- http://theproactiveprogrammer.com/javascript/the-javascript-event-loop-a-stack-and-a-queue/

---

## 102.Объясните разницу при использовании `foo` в `function foo() {}` и `var foo = function() {}`

Первое — объявление функции, а второе — функциональное выражение. Ключевое отличие состоит в том, что тело функции при объявлении поднимается наверх, а тело функциональных выражений — нет (они имеют такое же поведение поднятия, что и переменные).

Для получения более подробной информации, обратитесь к вопросу выше о поднятии. Если вы попытаетесь вызвать выражение функции до того, как оно будет определено, вы получите ошибку `Uncaught TypeError: XXX is not a function`.

#### Объявление функции

```js
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
```

#### Функциональное выражение

```js
foo(); // Uncaught TypeError: foo is not a function
var foo = function () {
  console.log("FOOOOO");
};
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function

---

## 103. В чем различие между переменными, созданными при помощи `let`, `var` и `const`?

Переменные, объявленные при помощи ключевого слова `var`, относятся к области видимости функции, в которой они созданы. Или, если они созданы вне какой-либо функции — к глобальному объекту. `let` и `const` относятся к блочной области видимости — это означает, что они доступны только в пределах ближайшего набора фигурных скобок (функция, блок `if-else` или цикл `for`).

```js
function foo() {
  // Все переменные доступны внутри функции.
  var bar = "bar";
  let baz = "baz";
  const qux = "qux";
  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}
console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = "bar";
  let baz = "baz";
  const qux = "qux";
}
// переменные, объявленные при помощи var, доступны в любом месте функции.
console.log(bar); // bar
// переменные, объявленные при помощи let и const не доступны вне блока, в котором были определены.
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

`var` позволяет поднимать переменные, что означает, что на них можно ссылаться в коде до их объявления. `let` и `const` не позволяют этого, и выдают ошибку.

```js
console.log(foo); // undefined
var foo = "foo";
console.log(baz); // ReferenceError: can’t access lexical declaration 'baz' before initialization
let baz = "baz";
console.log(bar); // ReferenceError: can’t access lexical declaration 'bar' before initialization
const bar = "bar";
```

Переопределение переменной с помощью `var` не вызовет ошибку, в отличие от `let` и `const`.

```js
var foo = "foo";
var foo = "bar";
console.log(foo); // “bar”
let baz = "baz";
let baz = "qux"; // Uncaught SyntaxError: Identifier ‘baz’ has already been declared
```

`let` отличается от const тем, что изменять значение `const` нельзя.

```js
// Это нормально.
let foo = "foo";
foo = "bar";
// Это вызывает исключение.
const baz = "baz";
baz = "qux";
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

## 104. В чем разница между классом в ES6 и функцией-конструктором в ES5?

Для начала посмотрим на примеры:

```js
// ES5 функция-конструктор
function Person(name) {
  this.name = name;
}
// ES6 класс
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

Они выглядят довольно похоже, если рассматривать простые конструкторы.
Основное отличие в конструкторе возникает при использовании наследования. Если мы хотим создать класс `Student` (который будет являться подклассом класса `Person`) и добавить поле `studentId`, то, в дополнение к вышеописанному, мы должны сделать следующее:

```js
// ES5 функция-конструктор
function Student(name, studentId) {
  // Вызов конструктора суперкласса для инициализации производных от суперкласса членов.
  Person.call(this, name);
  // Инициализация собственных членов подкласса.
  this.studentId = studentId;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
// ES6 класс
class Student extends Person {
  constructor(name, studentId) {
    super(name);
    this.studentId = studentId;
  }
}
```

Наследование в синтаксисе ES5 является намного более многословным, а в ES6 более понятное и усваиваемое.

Ссылки

- https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance
- https://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5

---

## 105.Можете ли вы привести пример использования стрелочных функции `=>`? Чем они отличаются от других функций?

Одним очевидным преимуществом стрелочных функций является упрощение синтаксиса, необходимого для создания функций, без необходимости использования ключевого слова `function`. `this` внутри стрелочных функций также привязано к замыкающей области видимости, в отличие от обычных функций, где `this` определяется контекстом, в котором они вызываются. Лексически привязанное `this` полезно при вызове `callback`-функций, особенно в компонентах React.

---

## 106. В чем преимущество использования стрелочных функций для метода в конструкторе?

Основным преимуществом использования стрелочной функции в качестве метода внутри конструктора является то, что значение `this` устанавливается во время создания функции и не может измениться после этого. Таким образом, когда конструктор используется для создания нового объекта, `this` всегда будет ссылаться на этот объект. Например, допустим, у нас есть конструктор `Person`, который принимает имя - `name` в качестве аргумента, имеет два метода для вывода в консоль этого имени, один в качестве обычной функции, а другой в качестве стрелочной:

```js
const Person = function(firstName) {
  this.firstName = firstName;
  this.sayName1 = function() { console.log(this.firstName); };
  this.sayName2 = () => { console.log(this.firstName); };
};
const john = new Person(‘John’);
const dave = new Person(‘Dave’);
john.sayName1(); // John
john.sayName2(); // John
// У обычной функции значение `this` может быть изменено, но у стрелочной функции нет
john.sayName1.call(dave); // Dave (потому что ‘this’ сейчас ссылается на объект dave)
john.sayName2.call(dave); // John
john.sayName1.apply(dave); // Dave (потому что ‘this’ сейчас ссылается на объект dave)
john.sayName2.apply(dave); // John
john.sayName1.bind(dave)(); // Dave (потому что ‘this’ сейчас ссылается на объект dave)
john.sayName2.bind(dave)(); // John
var sayNameFromWindow1 = john.sayName1;
sayNameFromWindow1(); // undefined (потому что ‘this’ сейчас ссылается на объект window)
var sayNameFromWindow2 = john.sayName2;
sayNameFromWindow2(); // John
```

Смысл заключается в том, что `this` можно изменить для обычной функции, но для стрелочных функций контекст всегда остается неизменным. Поэтому, даже если вы передаете стрелочную функцию в разные части вашего приложения, вам не нужно беспокоиться об изменении контекста.

Это может быть особенно полезно в классовых React-компонентах. Если вы определяете метод класса для чего-то такого, как обработчик клика, используя обычную функцию, а затем передаете этот обработчик в дочерний компонент в качестве `prop`, вам также необходимо привязать `this` в конструкторе родительского компонента , Если вместо этого вы используете стрелочную функцию, то нет необходимости привязывать `this`, так как метод автоматически получит свое значение `this` из замыкающего лексического контекста. (Прочитайте эту статью о стрелочных функциях: [https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb](https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb))

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
- https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb

---

## 107.Дайте определение функции высшего порядка

Функция высшего порядка — это любая функция, которая принимает одну или несколько функций в качестве аргументов, которые она использует для работы с данными и/или возвращает функцию в качестве результата.

Функции высшего порядка предназначены для абстрагирования некоторой операции, которая выполняется повторно. Классическим примером является метод `map`, который принимает массив и функцию в качестве аргументов.

Затем `map` использует эту функцию для преобразования каждого элемента в массиве, возвращая новый массив с преобразованными данными.

Другими популярными примерами в JavaScript являются `forEach`, `filter` и `reduce`. Функции высшего порядка используют не только для манипуляций с массивами, но также и для возврата функции из другой функции, например при использовании `Function.prototype.bind`.

#### Map

Допустим, у нас есть массив с именами, которые нам нужны о преобразовать в верхний регистр.

```js
const names = ["irish", "daisy", "anna"];
```

Императивное решение будет выглядеть так:

```js
const transformNamesToUppercase = function (names) {
  const results = [];
  for (let i = 0; i < names.length; i++) {
    results.push(names[i].toUpperCase());
  }
  return results;
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
```

Воспользууемся `.map(transformerFn)`, чтобы сделать код декларативным и более коротким:

```js
const transformNamesToUppercase = function (names) {
  return names.map((name) => name.toUpperCase());
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
```

Ссылки

- https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99
- https://hackernoon.com/effective-functional-javascript-first-class-and-higher-order-functions-713fde8df50a
- https://eloquentjavascript.net/05_higher_order.html

---

## 108. Можете ли вы привести пример деструктуризации объекта или массива?

Деструктуризация — это выражение, доступное в ES6, которое предоставляет краткий и удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные.

#### Деструктуризация массива

```js
// Присваивание переменной
const foo = [‘one’, ‘two’, ‘three’];
const [one, two, three] = foo;
console.log(one); // “one”
console.log(two); // “two”
console.log(three); // “three”
// Перестановка переменных местами
let a = 1;
let b = 3;
[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
```

#### Деструктуризация объекта

```js
// Присваивание переменной
const o = { p: 42, q: true };
const { p, q } = o;
console.log(p); // 42
console.log(q); // true
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
- https://ponyfoo.com/articles/es6-destructuring-in-depth

---

## 109. Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?

Шаблонные строки помогают упростить написание строк и делают возможным включение переменных в строку. До ES2015 писали так:

```js
var person = { name: ‘Tyler’, age: 28 };
console.log('Hi, my name is ' + person.name + ' and I am ' + person.age + ' years old!');
// ‘Hi, my name is Tyler and I am 28 years old!’
```

С приходом шаблонных строк в ES6 стало намного проще:

```js
const person = { name: ‘Tyler’, age: 28 };
console.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);
// ‘Hi, my name is Tyler and I am 28 years old!’
```

Обратите внимание, что для шаблонных строк используются обратные кавычки, а не простые. Переменные добавляются в подстановки `${}`, обозначаемые знаком доллара и фигурными скобками.

Второй пример использования заключается в создании многострочных литералов. До ES2015 перенос осуществлялся следующим образом:

```js
console.log("This is line one.\nThis is line two.");
// This is line one.
// This is line two.
```

Или же, чтобы не приходилось прокручивать длинную строку в текстовом редакторе, можно было разбить код на несколько строк в коде, таким образом:

```js
console.log("This is line one.\n" + "This is line two.");
// This is line one.
// This is line two.
```

Однако шаблонные строки сохраняют любой интервал, который вы добавляете к ним. Например, чтобы создать тот же многострочный литерал, который мы создали выше, вы можете просто написать:

```js
console.log(`This is line one.
This is line two.`);
// This is line one.
// This is line two.
```

Еще одним вариантом использования шаблонных строк будет использование в качестве замены библиотек шаблонизации для интерполяции переменных:

```js
const person = { name: "Tyler", age: 28 };
document.body.innerHTML = `
  <div>
    <p>Name: ${person.name}</p>
    <p>Name: ${person.age}</p>
  </div>`;
```

**Обратите внимание, что ваш код может быть восприимчив к XSS при использовании `.innerHTML`. Очищайте ваши данные перед отображением, если они получены от пользователя!**

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals

---

## 110. Можете ли вы привести пример каррированной функции (`curry function`) и в чем их преимущество?

Каррирование — это паттерн, где функция с более чем одним параметром разбивается на несколько функций, которые при последовательном вызове будут накапливать все необходимые параметры по одному. Этот метод может быть полезен для облегчения чтения и написания кода, написанного в функциональном стиле. Важно отметить, что каррированная функция должна начинаться как одна функция, а затем разбиваться на последовательность функций, каждая из которых принимает один параметр.

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }
  function _curried(depth, args) {
    return function(newArgument) {
      if (depth — 1 === 0) {
        return fn(…args, newArgument);
      }
      return _curried(depth — 1, […args, newArgument]);
    };
  }
  return _curried(fn.length, []);
}
function add(a, b) {
  return a + b;
}
var curriedAdd = curry(add);
var addFive = curriedAdd(5);
var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

Ссылки

- https://hackernoon.com/currying-in-js-d9ddc64f162e

---

## 111. В чем преимущества использования `spread` оператора и чем он отличается от `rest` оператора?

`Spread` оператор синтаксиса ES6 очень полезен при написании кода в функциональном стиле, поскольку мы можем легко создавать копии массивов или объектов, не прибегая к `Object.create`, `slice` или функции библиотеки. Эта языковая функция часто используется в проектах с Redux и rx.js.

```js
function putDookieInAnyArray(arr) {
  return […arr, ‘dookie’];
}
const result = putDookieInAnyArray([‘I’, ‘really’, “don’t”, ‘like’]); // [“I”, “really”, “don’t”, “like”, “dookie”]
const person = {
  name: ‘Todd’,
  age: 29,
};
const copyOfTodd = { …person };
```

В свою очередь, `rest` оператор синтаксиса ES6 позволяет в сокращенном виде указывать неопределенное количество аргументов, передаваемых в функцию. Можно сказать, что он противоположен `spread` оператору: собирает данные и добавляет их в массив, вместо разделения массива данных. Он используется в аргументах функций, а также при деструктуризации массивов и объектов.

```js
function addFiveToABunchOfNumbers(…numbers) {
  return numbers.map(x => x + 5);
}
const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]
const [a, b, …rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]
const { e, f, …others } = {
  e: 1,
  f: 2,
  g: 3,
  h: 4,
}; // e: 1, f: 2, others: { g: 3, h: 4 }
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

---

## 112.Каким образом можно обмениваться кодом между файлами?

Это зависит от среды выполнения JavaScript.

На клиенте (в среде браузера), пока переменные/функции объявлены в глобальной области видимости (`window`), все скрипты могут на них ссылаться. В качестве альтернативы, используйте `Asynchronous Module Definition` (AMD) через `RequireJS` для модульного подхода.

На сервере (Node.js) обычно используется `CommonJS`. Каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту `module.exports`.

ES2015 позволяет использовать модульный синтаксис, который призван заменить как `AMD`, так и `CommonJS`. В конечном итоге он будет поддерживаться как в браузере, так и в Node.

Ссылки

- http://requirejs.org/docs/whyamd.html
- https://nodejs.org/docs/latest/api/modules.html
- http://2ality.com/2014/09/es6-modules-final.html

---

## 113. Для чего используются статические члены класса?

Члены статических классов (свойства/методы) не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того, какой экземпляр ссылается на них. Статические свойства обычно являются конфигурационными переменными, а статические методы обычно являются чисто служебными функциями, которые не зависят от состояния экземпляра.

Ссылки

- https://stackoverflow.com/questions/21155438/when-to-use-static-variables-methods-and-when-to-use-instance-variables-methods

---

---

# Часто задаваемые вопросы на интервью по ES6

<p align="center">
<img src="img/es6-blitx-50.jpg" alt="logo-es6-blitz-poll">
</p>

## 1. Что такое ES6?

- ES6 также известен как ECMAScript 2015.
- ES6 или ECMAScript 2015 является 6-ым основным выпуском ECMAScript.
- Если ваш браузер не поддерживает ES6, вы можете написать совместимый код ES6, используя Babel и Webpack.
- ES10 (ECMAScript 2019) - это последняя версия ECMAScript.

---

## 2. Что такое ECMAScript?

ECMAScript - это спецификация, определенная в стандарте ECMA-262 для создания языка сценариев общего назначения.

---

## 3. Что такое JavaScript?

Язык сценариев общего назначения, соответствующий спецификации ECMAScript.

---

## 4. Что такое JavaScript Engine?

Программа или интерпретатор, который понимает и выполняет код JavaScript.

Самый популярный движок JavaScript:

- Google Chrome - V8 // Fastest JavaScript Engine
- Mozilla FireFox - SpiderMonkey
- Microsoft Edge - Chakra

---

## 5. Что такое Babel?

- Babel - один из самых популярных javascript-транспортеров.
- Babel в основном используется для преобразования кода ES6 + (ECMAScript 2015+) в обратно совместимую версию JavaScript, которая может быть запущена старыми механизмами JavaScript.

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6.html

---

## 6. Что такое Webpack?

- Webpack позволяет запускать среду, в которой работает Babel.
- Webpack - это пакет модулей javascript с открытым исходным кодом, который принимает модули с зависимостями и генерирует статические ресурсы, представляющие эти модули.

**Преимущества использования Webpack:**

1. Он объединяет несколько ваших модулей и упаковывает их в один файл `.js`.
2. Он поставляется с интегрированным сервером разработки. Небольшое экспресс-приложение для локальной разработки. Вы просто включаете один тег Javascript, указывающий на сервер, например `localhost: 8080 / assets / bundle.js`, и получаете бесплатное обновление кода и управление ресурсами.

---

## 7. Перечислите некоторые новые функции в ES6?

**Новые функции в ES6:**
Лучшие 10 функций ES6, которые должен знать каждый разработчик JavaScript.

- а). `Let` и `Const` ключевые слова
- b). `Arrow functions` - стрелочные функции
- c). `Template Literals` - шаблонные литералы
- d). `Object Literals` - литералы объекта
- e). `Default Parameters` - параметры по умолчанию
- f). `Destructuring Assignment` - деструктурирующее присваивание
- g). `Rest and Spread Operators` - операторы rest и spread
- h). `Modules`, `Classes`, `Iterators`, `Generators` in ES6 - Модули, классы, итераторы и генераторы
- i). `Promises` in ES6 -Обещания
- j). `Support for Map/Set & WeakMap/WeakSet`

---

## a). `let` и `const`:

**`Const` Ключевое слово**:

- Ключевое слово `const` используется для определения констант в ES6.
  это также известно как неизменяемые переменные.
- Значение константы **не может** быть изменено путем переназначения, и оно **не может** быть повторно объявлено.

```js
const MY_CONST = "Javascript ES6 Interview Questions";
console.log(MY_CONST);
//Javascript ES6 Interview Questions
MY_CONST = "ES6 Interview Questions";
console.log(MY_CONST);
// Uncaught TypeError: Присвоение постоянной переменной,
// потому что мы не можем переназначить новое значение константе
```

В случае `Object` и `Array` мы можем добавить в него новые элементы

```js
const myObject = { name: "Full Stack Tutorials" };
// Если вы попытаетесь
// перезаписать / переназначить / переопределить объект,
//  выдается ошибка.

myObject = { name: "Full Stack Tutorials" };
//Uncaught TypeError: Присвоение постоянной переменной.
myObject = { fullname: "Full Stack Tutorials" };
//Uncaught TypeError: Присвоение постоянной переменной..

// Поскольку ключи объектов не защищены,
//  приведенный ниже код будет успешно выполнен.
myObject.name = "Anonymous User";
// Вы можете использовать Object.freeze (),
// чтобы сделать объект неизменным

const myArray = ["Javascript", "Node.js", "React.js"];
// Можно помещать элементы в массив
myArray.push("jQuery");
// Но присвоение нового массива той же переменной
// приведет к ошибке.

myArray = ["jQuery"];
//Uncaught TypeError: Присвоение постоянной переменной.
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-let-ii.html
- https://abcinblog.blogspot.com/2018/09/es6-const-let-variii.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md
- https://abcinblog.blogspot.com/2018/05/es6-1.html

`Object.freeze()`

> `Object.freeze` работает со значениями и делает объект неизменным.

_`Object.freeze ()` принимает объект в качестве аргумента и возвращает тот же объект, что и неизменный объект_

Как только вы заморозили объект, вы не можете изменять, добавлять или удалять свойства объекта, но вы можете назначить другой экземпляр.

```js
const myObject = { name: "Full Stack Tutorials" };
Object.freeze(myObject);
myObject.name = "Anonymous User";
// выдает ошибку в строгом режиме
console.log(myObject.name);
// Выведет: Full Stack Tutorials
```

**`let` ключевое слово**:
ES6 представляет новое ключевое слово `let`, которое позволяет нам объявлять локальные переменные в области видимости блока.

Позволяет вам объявлять переменные, которые ограничены по видимости блоком, оператором или выражением, в котором они используются.

```js
let a = 10;
funtion testMe(){
	let a = 20;
	console.log(a); // 20
}
console.log(a); // 10

```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-let-ii.html
- https://abcinblog.blogspot.com/2018/09/es6-const-let-variii.html

---

## b). Функции стрелки:

- Функция стрелки имеет более короткий синтаксис, чем обычная функция.
- Можно считать, что в функции Arrow `this` ключевого слова не существует. Более подробно - см. "Общие вопросы по JS"

```js
(param1, param2, …, paramN) => {
//statements or code
}
```

```js
//in ES5
var sum = function(a, b) {
return a + b;
};
console.log(sum(10,40)); // 50

----------------------------
//in ES6
var total = (x, y) => {
	return (x + y);
}
console.log(total(20,30)); // 50
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-xi.html
- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## c). `Template literals` - Шаблонные литералы:

ES6 представляет новые и простые в использовании строковые шаблоны с заполнителями для переменных.

- Шаблонные литералы заключены в обратную кавычку (русская буква "ё" в английской раскладке) (``).
- Вы можете использовать многострочные строки.
- Вы можете использовать новый синтаксис `$ {variable_name}` внутри строки, помеченной галочкой.
- До ES6 это называлось `Template Strings`.

```js
//Пример-1

var num1 = 10;
var num2 = 20;
console.log(`The sum of ${num1} and ${num2} is ${num1 + num2}.`);

//Выведет: The sum of 10 and 20 is 30

//Пример-2

var TempBody = `Hello Users! Your are reading about ES6 Features,
    In ES6, you are implementing Template Literals.
    Let me show you the sum of ${num1} and ${num2} is ${num1 + num2}. 
	Hope you have understood the concept of Template Literals.`;

console.log(TempBody);
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-template-strings-v.html
- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## d). `Object literals`:

Объектный литерал JavaScript представляет собой разделенный запятыми список пар имя-значение, заключенных в фигурные скобки.

```js
var myObject = {
  title: "ES6 Interview Questions and Answers",
  topic: "Object Literals",
  status: true,
  myFunction: () => {
    // Блок кода
  },
};
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-viii.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part2.md

---

## e). `Default Parameters`:

Параметры функции по умолчанию позволяют инициализировать именованные параметры с некоторыми значениями по умолчанию, если значение не передано или не определено.

```js
//3-й параметр имеет значение по умолчанию ноль.

let addNumbers = (a, b, c = 0) => {
  return a + b + c;
};

console.log(addNumbers(1, 2, 2)); //5
console.log(addNumbers(5, 20)); //25
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-vi.html

---

## f). `Destructuring Assignment`:

Деструктурирующее присваивание - это специальный синтаксис, который позволяет вам «распаковывать» массивы или объекты в кучу переменных, так как иногда они более удобны.

```js
// у нас есть массив с именем, отчеством и фамилией
let arr = ["Full", "Stack", "Tutorials"];

// destructuring assignment
let [first_name, middle_name, last_name] = arr;

console.log(first_name); // Full
console.log(middle_name); // Stack
console.log(last_name); // Tutorials
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-xii.html
- https://abcinblog.blogspot.com/2018/09/es6-xiii.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## g).`REST` and `Spread` operator:

Оператор спреда, или три точки, (`…`) - это новый оператор, введенный в ES6. Это позволяет расширять итерируемый объект (например, Array) на составляющие его элементы.

```js
const t = [1, 2, 3];

const s = [...t, 4, 5, 6];

console.log(s);
// [1, 2, 3, 4, 5, 6];
```

Подробне:

- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://abcinblog.blogspot.com/2018/09/es6-spread-operator-iv.html

**Пример: - Удалить дубликаты элементов из массива с помощью ES6 `Set`?**

> Объект `Set` позволяет хранить уникальные значения любого типа, будь то примитивные значения или объект

Вот одна строка для удаления дубликатов из массива. (ES6, конечно!)

```js
const numbers = [1, 2, 3, 4, 5, 5, 5, 5, 5, 5];

function removeDuplicates(array) {
  return [...new Set(array)];
}
console.log(removeDuplicates(numbers));
// [1, 2, 3, 4, 5]
```

Набор - `Set` был введен в ES6 и похож на наборы, с которыми мы сталкиваемся в математике: они не могут иметь дубликаты. После этого мы просто конвертируем `Set` обратно в массив, используя оператор распространения - `...`.

Подробне:

- https://abcinblog.blogspot.com/2018/05/es6-1.html

---

## h). `Class` In ES6:

```js
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  getUserDetails() {
    console.log(this.name + " is " + this.age + " years old!");
  }
}

var userObj = new User("Full Stack Tutorials", 5);
console.log(userObj.getUserDetails());

//Вывод: Full Stack Tutorials is 5 years old!
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-ix.html
- https://abcinblog.blogspot.com/p/blog-page_15.html#jsphp
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

**Генераторы**

Генератор - это функция, которая может остановиться на полпути, а затем продолжить с того места, где остановилась. Короче говоря, генератор выглядит как функция, но ведет себя как итератор.

```js
function* process() {
  console.log("Start process 1");
  console.log("Pause process2 until call next()");

  yield;

  console.log("Resumed process2");
  console.log("Pause process3 until call next()");

  yield;

  console.log("Resumed process3");
  console.log("End of the process function");
}

let _process = process();
```

**yield**:

- Ключевое слово `yield` просто помогает приостановить и возобновить функцию в любое время асинхронно.
- Кроме того, это помогает вернуть значение из функции генератора.

**в использовании**

- Ленивая оценка -`Lazy evaluation`
- Бесконечные последовательности - `Infinite sequences`
- Асинхронные потоки управления - `Asynchronous control flows`

---

## i). `Promise`:

> Обещания используются для обработки асинхронных операций в JavaScript.

Обещание - это объект, который может быть возвращен синхронно из асинхронной функции.

Обещание преодолеть проблему ада обратного вызова - **callback hell**.

**Promise States**:

- `Fulfilled`:будет вызвано `onFulfilled ()` (например, `resolve()` - разрешено был вызван)
- `Rejected`: отклонено - вызывается `onRejected ()` (например, вызывается `reject ()`).
- `Pending`: ожидание - исходное состояние, не выполнено и не отклонено.

Promise Consumers: `then`, `catch`, `finally`

```js
var promise = new Promise(function (resolve, reject) {
  const A = "fullstacktutorials";
  const B = "fullstacktutorials";
  if (A === B) {
    resolve();
  } else {
    reject();
  }
});

promise
  .then(function () {
    console.log("Success, Your promise has been resolved successfully");
  })
  .catch(function () {
    console.log("Something went wrong!");
  });
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-promise-xiv-1.html
- https://abcinblog.blogspot.com/2018/09/es6-promisesxiv-2.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part3.md

---

## j). Map:

Объект Map представляет собой простую карту - ключ / значение.

Любое значение (как объекты, так и примитивные значения) может использоваться в качестве ключа или значения. Синтаксис [ключ, значение].

```js
hash = new Map();
hash.set(
  "FullStackTutorials",
  "Learn Full Stack Tutorials free Online, Javascript ES6 Interview Questions"
);
hash.set(1, 200);

console.log(hash);
//Output: Map(2) {"FullStackTutorials" =>
// "Learn Full Stack Tutorials free Online, Javascript ES6 Interview Questions",
//  1 => 200}
```

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-3.html

---

## 8. Разница между функцией стрелки и обычной функцией в JavaScript?

Существуют следующие различия между функцией стрелки и обычной (обычной) функцией:

**1. Syntax:**
И Стрелка, и Нормальная (Обычная) функция имеют разный синтаксис.

```js
//Normal Function:

let func = function myFunc(params) {
  // body of the function
};

OR;

function myFunc(params) {
  // body of the function
}
```

```js
//Arrow Function:

let func = (params) => {
  // body of the function
};
```

**2. Использование `this` ключевого слова:**

> В функциях Arrow нет привязки `this`

В отличие от обычных функций, функции стрелок не имеют своего собственного `this`.

```js
let myFunc = {
  name: "Full Stack Tutorials",
  arrowFunc: () => {
    console.log(`Welcome to, ${this.name}`);
    // no 'this' binding
  },
  regFunc() {
    console.log(`Welcome to, ${this.name}`);
    // 'this' binding works
  },
};
myFunc.arrowFunc();
myFunc.regFunc();
```

**3. Используя `new` ключевое слово:**
Функции со стрелками нельзя использовать как конструктор с `new`, это вызовет ошибку.

```js
let myFunc = () => {};
let func = new myFunc();
// Uncaught TypeError: myFunc is not a constructor
```

**4. Наличие объекта аргументов:**
Функции стрелок не имеют своих собственных объектов аргументов. Следовательно, arguments - это просто ссылка на аргументы внутренней области.

**5. Использование свойства прототипа:**
Функции стрелок не имеют свойства прототипа.

```js
let myFunc = () => {};
console.log(myFunc.prototype);
// undefined
```

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md
- https://abcinblog.blogspot.com/2018/09/es6-xi.html

---

## 9. Как бы вы фильтровали массив объектов в ES6?

```javascript
var testArray = [
  { name: "Jai", age: 26 },
  { name: "Shiv", age: 22 },
  { name: "Anuj", age: 5 },
  { name: "Jenny", age: 20 },
];
var data = testArray.filter((person) => person.age > 18);
//Filters the Array of Objects to condition set
console.log(data);
/*
0:{name: "Jai", age: 26}
1:{name: "Shiv", age: 22}
2:{name: "Jenny", age: 20}
length:3
*/
```

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-3.html
- https://abcinblog.blogspot.com/2019/01/js-es6-arrays.html

---

## 10. Что вы подразумеваете под IIFE - `Immediately Invoked Function Expressions`(выражениями с немедленным вызовом функций)?

Выражения IIFE или немедленно вызванные функции - это выражения, которые выполняются сразу же после его создания. IIFEs используются, чтобы избежать чрезмерного использования глобального пространства имен, потому что все переменные, которые используются внутри IIFE, не могут быть просмотрены вне его области. Другими словами, IIFE - это шаблоны проектирования, также известные как самоисполняющиеся анонимные функции (Self Executing Anonymous Functions), поскольку они выполняются самостоятельно.

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part3.md

---

## 11. Объясните, почему следующее не работает как `IIFE`. Что нужно изменить, чтобы правильно сделать его `IIFE`?

```js
function foo(){ }();
```

IIFE расшифровывается как выражения для немедленного вызова функций (Immediately Invoked Function Expressions). Парсер JavaScript читает `function foo () {} ();` as `function foo () {}` и `();` где первая часть - это объявление функции, а вторая (пара скобок) - попытка вызова функции, но имя функции не указано, поэтому он выбрасывает `Uncaught SyntaxError: Unexpected token` Неожиданный токен ).

Вот два способа исправить это, которые включают добавление дополнительных скобок: `(function foo () {}) ()` и `(function foo () {} ())`. Эти функции не отображаются в глобальной области видимости, и вы можете даже опустить ее имя, если вам не нужно, чтобы она ссылалась на саму себя внутри тела.

Вы также можете использовать оператор `void`: `void function foo () {} ();`. К сожалению, с таким подходом есть одна проблема. Оценка данного выражения всегда не определена - `undefined`, поэтому, если ваша функция IIFE возвращает что-либо, вы не можете ее использовать. Пример:

```js
// Don't add JS syntax to this code block to prevent Prettier from formatting it.
const foo = void (function bar() {
  return "foo";
})();

console.log(foo); // undefined
```

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part3.md

---

## 12. Объясните мотивацию использования `Simbols` в ES6.

Символы - `Simbols` представляют собой особый вид объекта, недавно добавленный в шестую версию ECMAScript, который можно использовать в качестве уникального имени свойства в объектах. Использование Symbol вместо String (как это было в предыдущих версиях) позволяет программисту использовать разные модули, которые могут создавать свойства, которые не будут проблематичными друг для друга. Другим огромным преимуществом Символов является то, что они могут быть приватными, и к определенным свойствам не может получить доступ ни один пользователь или разработчик, не имеющий прямого доступа к `Simbols`. Они состоят из функции, которую можно использовать для создания разных символов, которые могут работать по-разному. Но у них нет буквального синтаксиса, в отличие от других примитивов JavaScript.

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-symbols-xv.html

---

## 13. Объясните преимущества использования `spread` syntax (синтаксиса распространения) в ES6. Чем он отличается от остального синтаксиса?

Что касается кодирования в функциональной парадигме, использование spread syntax в ES6 может оказаться весьма полезным. Spread syntax может быть легко использован для создания копий массивов или объектов. Использование распространенного синтаксиса в программе не требует использования `Object.create`, `slice` или какой-либо библиотечной функции. Spread syntax широко используется в проектах Redux и rx.js.

С другой стороны, функция синтаксиса `rest` в ES6 используется для передачи произвольного числа аргументов функции. Это также можно рассматривать как сокращение в программировании на JavaScript. Rest syntax может рассматриваться как противоположность Spread syntax. Он берет данные и помещает их в массив вместо распаковки данных. В дополнение к этому, он работает подходящим образом в аргументах функций, массивах, а также в назначениях деструктурирования объектов.

> Примечание. Этот вопрос задается почти во всех интервью ES6.

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://abcinblog.blogspot.com/2018/09/es6-spread-operator-iv.html

---

## 14. Какая разница между ES6 class ES5 function constructors?

| ES6 class                                                                                                                                                                  | ES5 Function Constructors                                                                                                                                          |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Класс ES6 в основном выполняет работу по определению нового объекта и добавлению функций к его прототипу.                                                                  | ES5 Конструкторы функций работают и выглядят одинаково, но основное различие наблюдается, когда разработчик использует свойство `Inheritance`.                     |
| Их можно рассматривать как основу синтаксиса для функций конструктора.                                                                                                     | Они могут быть выполнены только с помощью нового оператора.                                                                                                        |
| Класс ES6 позволяет разработчикам создавать объекты с помощью оператора `new`.                                                                                             | Конструкторы функций ES5 фокусируются на том, как создаются объекты.                                                                                               |
| Они также гарантируют разработчику, что `this` ключевое слово, которое в основном используется внутри класса, относится только к объекту, который создается разработчиком. | Конструктор функций ES5 фокусируется на реализации кода создания многократно используемых объектов. Любая функция может быть использована в качестве конструктора. |

---

## 15. Разница между `.call` и `.apply`?

| .call                                                                                                                          | .apply                                                                                                                                                            |
| :----------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `.call` используется для вызова функций, и первый параметр станет значением этого значения в функции, созданной разработчиком. | `.apply` также используется для вызова функций, но он принимает массив аргументов. Этот массив работает как следующий аргумент, и функция работает таким образом. |
| `.call` используется для вызова метода, который принимает объект-владелец в качестве аргумента.                                | Метод `.apply` используется для написания методов. Эти методы могут быть использованы для нескольких объектов.                                                    |
| Он принимает два параметра, а именно `objectInstance` и `arguments`.                                                           | Он принимает два параметра, а именно `objectInstance` и `arrayofArguments`.                                                                                       |
| `.call` принимает несколько аргументов, разделенных запятыми.                                                                  | `.apply` принимает несколько аргументов с помощью массива аргументов.                                                                                             |

---

## 16. Объясните причину использования классов ES6.

Классы ES6 оказались очень полезными для разработчиков. Некоторые из основных видов использования классов ES6:

- Классы ES6 имеют более простой и менее подверженный ошибкам синтаксис.
- Что касается настройки иерархий наследования, то ES6 считается наилучшим вариантом, поскольку он использует новый синтаксис со старым синтаксисом, который минимизирует ошибки и облегчает процесс.
- Классы ES6 помогают защитить разработчиков от неправильного использования новых функций с помощью функции конструктора. Это одна из самых распространенных ошибок, возникающих у разработчиков при использовании нового оператора. Классы устраняют эту ошибку, заставляя конструктор генерировать исключение, если это оказывается недопустимым объектом для конструктора.
- Классы также помогают вызывать метод, имеющий версию прототипа. Эта версия намного проще с новым синтаксисом ES6, чем старые версии.

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-ix.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## 17. Что такое `generator` (генератор) в JavaScript?

С запуском ES6 появился новый способ работы с функциями и итераторами. Они называются генераторами. Генератор - это не что иное, как функция, которая может остановиться в тот момент, когда пользователь прикажет ему сделать это, а затем продолжить работу только с того места, где он остановился. Другими словами, генератор имеет свойства функции, но также работает как итератор. Он не работает как другие строки кода, которые необходимо заполнить для выполнения.

Генераторы работают по модели «от завершения к завершению», которая облегчает разработчикам компиляцию программы. Генераторы также могут быть определены как специальный класс функций, которые работают для упрощения задачи кодирования итераторов в программе. Это производит последовательность результатов, а не производит единственное значение. Это позволяет разработчику создавать серию значений одновременно.

> Это очень важный вопрос интервью для javascript ES6.

Подробнее:

- https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Generator

---

## 18. Определить `temporal dead zone` (временную мертвую зону) в ES6.

Временная мертвая зона `temporal dead zone` - может быть определена как промежуток времени, который существует между временем, связанным с привязкой переменной к ее объявлению в программе. Временная мертвая зона существует, так что программные ошибки можно легко идентифицировать как переменную, которая может быть доступна до ее объявления. Также для правильной работы `const` можно использовать временную мертвую зону. Он также используется для защиты JavaScript, который в основном является механизмом, используемым во время выполнения.

Подробнее:

- https://developer.mozilla.org/uk/search?q=temporal+dead+zone

---

## 19. Что такое `spread` -параметр распространения, `default` - по умолчанию и `rest` параметры?

**Spread Operator** - Пожертвовано «...» и сопровождается переменной. Например, синтаксис оператора распространения может выглядеть следующим образом: - «`... X`». Операторы распространения манипулируют объектами и массивами, что является основной причиной его использования в ES6. Он используется для копирования свойства одного объекта другому.
Spread оператор разбивает коллекцию на отдельные аргументы функции, это позволяет вызывать функцию, которая принимает три параметра, с одним параметром.

```js
const day = [2015, 10, 12];
const dayOff = new Date(...day);
let firstArray = [4, 5, 6];
let secondArray = [1, 2, 3, ...firstArray]; // [1,2,3,4,5,6]
```

**Default Operator** (Оператор по умолчанию) - для инициализации функции с использованием значений по умолчанию используется оператор по умолчанию. Значением параметра может быть что угодно - число, функция или null.
Синтаксис похож на другие языки: argumentName = someValue.
`function join(arr,separator=','){ return arr.join(separator)}`

**Rest Parameter** . Этот оператор используется для восстановления всех аргументов, необходимых для вызова функции. Это позволяет нам разделять элементы, принадлежащие к разным категориям. Параметр `rest` позволяет объединить параметры в общий параметр массива.

```js
function push(arr, elem, ...otherElems) {
  arr.push(elem);

  if (otherElems.length) {
    otherElems.forEach((e) => push(arr, e));
  }
}
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-spread-operator-iv.html
- https://abcinblog.blogspot.com/2018/05/es6-1.html

---

## 20. Что такое `classes` и `proxies`?

**Class** - Вы можете легко использовать шаблоны с объявлением класса на основе ООП. Он легко работает с конструкторами, поддерживает доступ к базовому классу, наследование и статические методы. ООП относится к объектно-ориентированному программированию.

**Proxies**. С помощью прокси вы можете создавать объекты и размещать объекты с огромным разнообразием поведения. Прокси могут также помочь в профилировании и регистрации.
Прокси-это объект, который перехватывает попытки доступа к другому объекту и может изменять их. Синтаксис:

```js
let proxy = new Proxy(target, handler);
```

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy
- https://abc-react.blogspot.com/2018/10/react.html#proxy_component

---

## 21. Когда я должен использовать функции стрелки в ES6?

Сейчас я использую следующее правило для функций в ES6 и более поздних версиях:

- Используйте `function` в глобальной области видимости и для свойств `Object.prototype`.
- Используйте `class` для конструкторов объектов.
- Используйте `=>` везде в осальном.

Зачем использовать функции стрелок почти везде?

- **Scope safety** - Безопасность области: Когда функции стрелок используются последовательно, все гарантированно будет использовать тот же объект `thisObject`, что и корневой. Если даже один стандартный вызов функции смешивается с кучей функций со стрелками, есть вероятность, что область видимости испортится.
- **Compactness** - Компактность: функции со стрелками легче читать и писать. (Это может показаться самоуверенным, поэтому я приведу несколько примеров далее).
- **Clarity** - Ясность: когда почти все является функцией стрелки, любая обычная функция немедленно выделяется для определения области видимости. Разработчик всегда может найти следующий более высокий оператор функции, чтобы увидеть, что это за `thisObject.`

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/when_not_to_use_arrow_functions.md
- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## 22. Когда НЕ следует использовать функции стрелок в ES6? Назовите три или более случаев.

Функции стрелок НЕ должны использоваться:

- Когда мы хотим использовать поднятие функции (hoisting) - так как функции стрелок являются анонимными.
- Когда мы хотим использовать `this` / `arguments` в функции - поскольку функции стрелок не имеют собственных аргументов / arguments, они зависят от своего внешнего контекста.
- Когда мы хотим использовать именованную функцию - в качестве стрелки функции анонимны.
- Когда мы хотим использовать функцию в качестве конструктора - функции стрелок не имеют своих собственных.
- Когда мы хотим добавить функцию как свойство в литерал объекта и использовать в нем объект - так как мы не можем получить к нему доступ (которым должен быть сам объект).

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/when_not_to_use_arrow_functions.md

---

## 23. Объясните разницу между `Object.freeze ()` и `const`.

`const` и `Object.freeze` - это две совершенно разные вещи.

`const` применяется к привязкам («переменным»). Он создает неизменяемую привязку, то есть вы не можете назначить новое значение привязке.

```js
const person = {
  name: "Leonardo",
};
let animal = {
  species: "snake",
};
person = animal; // ERROR "person" is read-only
```

`Object.freeze` работает со значениями и, более конкретно, со значениями объектов. Это делает объект неизменным, то есть вы не можете изменить его свойства.

```js
let person = {
  name: "Leonardo",
};
let animal = {
  species: "snake",
};
Object.freeze(person);
person.name = "Lima"; //TypeError: Cannot assign to read only property 'name' of object
console.log(person);
```

---

## 24. Объясните `Prototype Design Pattern`.

_Prototype Pattern_ Шаблон прототипа создает новые объекты, но вместо создания неинициализированных объектов он возвращает объекты, инициализированные значениями, которые он скопировал из объекта-прототипа или образца. _Prototype Pattern_ также называется шаблоном Properties (Properties pattern).

Примером использования _Prototype Pattern_ является инициализация бизнес-объектов со значениями, которые соответствуют значениям по умолчанию в базе данных. Объект-прототип содержит значения по умолчанию, которые копируются во вновь созданный бизнес-объект.

Классические языки редко используют Properties pattern, но JavaScript, являющийся языком-прототипом, использует этот шаблон при конструировании новых объектов и их прототипов.

Подробнее:

- https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes
- https://drive.google.com/drive/folders/1MJIG5MUXzz40uSctpPtYlPJz7N9dJ7rw?usp=sharing

---

## 25. Не могли бы вы сравнить использование `Module Pattern` против `Constructor / Prototype pattern`?

Module Pattern - Шаблон модуля обычно используется для пространства имен, где у вас будет один экземпляр, выступающий в качестве хранилища для группировки связанных функций и объектов. Это другой вариант использования, из которого хорошо подходит прототипирование. Они на самом деле не конкурируют друг с другом; вы можете с радостью использовать оба вместе (например, поместить функцию-конструктор внутри модуля и объявить `new MyNamespace.MyModule.MyClass (arguments))`.

Функции-конструкторы и прототипы являются одним из разумных способов реализации классов и экземпляров. Они не совсем соответствуют этой модели, поэтому обычно вам нужно выбрать конкретную схему или вспомогательный метод для реализации классов с точки зрения прототипов.

Подробнее:

- https://drive.google.com/drive/folders/1MJIG5MUXzz40uSctpPtYlPJz7N9dJ7rw?usp=sharing

---

## 26. Каковы предпосылки использования в ES6 `WeakMap` ?

`WeakMaps` предоставляют возможность расширять объекты извне, не мешая сборке мусора. Всякий раз, когда вы хотите расширить объект, но не можете, потому что он запечатан - или из внешнего источника - можно применить WeakMap.

`WeakMaps` доступны только для ES6 и выше. WeakMap - это набор пар ключ-значение, где ключ должен быть объектом.

```js
var map = new WeakMap();
var pavloHero = {
  first: "Pavlo",
  last: "Hero",
};
var gabrielFranco = {
  first: "Gabriel",
  last: "Franco",
};
map.set(pavloHero, "This is Hero");
map.set(gabrielFranco, "This is Franco");
console.log(map.get(pavloHero)); //This is Hero
```

Интересным аспектом `WeakMaps` является тот факт, что он содержит слабую ссылку на ключ внутри карты. Слабая ссылка означает, что если объект будет уничтожен, сборщик мусора удалит всю запись из `WeakMap`, освободив таким образом память.

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap

---

## 27. В чем разница между ES6 `Map` и `WeakMap`?

Они оба ведут себя по-разному, когда объект, на который ссылаются их ключи / значения, удаляется. Давайте возьмем следующий пример кода:

`var map = new Map ();`

`var weakmap = new WeakMap ();`

```js
(function () {
  var a = {
    x: 12,
  };
  var b = {
    y: 12,
  };

  map.set(a, 1);
  weakmap.set(b, 2);
})();
```

Вышеупомянутый IIFE выполняется, и мы больше не можем ссылаться на `{x: 12}` и `{y: 12}`. Сборщик мусора идет вперед и удаляет указатель ключа `b` из «WeakMap», а также удаляет `{y: 12}` из памяти. Но в случае «Map» сборщик мусора не удаляет указатель из «Map», а также не удаляет `{x: 12}` из памяти.

WeakMap позволяет сборщику мусора выполнять свою задачу, но не Map. С картами, написанными вручную, массив ключей будет хранить ссылки на ключевые объекты, предотвращая их сборку мусора. В собственных WeakMaps ссылки на ключевые объекты хранятся «слабо - _weakly_», что означает, что они не предотвращают сборку мусора в случае, если не будет другой ссылки на объект.

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap

---

## 28. Можете ли вы привести пример функции каррирования (curry function) и почему этот синтаксис дает преимущество?

Карринг (каррирование) - это шаблон, в котором функция с более чем одним параметром разбивается на несколько функций, которые при последовательном вызове будут накапливать все необходимые параметры по одному. Этот метод может быть полезен для облегчения чтения и написания кода, написанного в функциональном стиле. Важно отметить, что для функции, которую нужно каррировать, она должна начинаться как одна функция, а затем разбиваться на последовательность функций, каждая из которых принимает один параметр.

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }

  function _curried(depth, args) {
    return function (newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument);
      }
      return _curried(depth - 1, [...args, newArgument]);
    };
  }

  return _curried(fn.length, []);
}

function add(a, b) {
  return a + b;
}

var curriedAdd = curry(add);
var addFive = curriedAdd(5);

var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

Подробнее:

- https://learn.javascript.ru/currying-partials
- https://habr.com/ru/company/ruvds/blog/427295/

---

## 29. Как «заморозить» ("deep-freeze") объект в JavaScript?

Если вы хотите убедиться, что объект глубоко заморожен, вы должны создать рекурсивную функцию для замораживания каждого свойства, имеющего тип объекта:

Без глубокой заморозки (Without deep freeze):

```js
let person = {
  name: "Leonardo",
  profession: {
    name: "developer",
  },
};
Object.freeze(person); // make object immutable
person.profession.name = "doctor";
console.log(person); //output { name: 'Leonardo', profession: { name: 'doctor' } }
```

C deep freeze:

```js
function deepFreeze(object) {
  let propNames = Object.getOwnPropertyNames(object);
  for (let name of propNames) {
    let value = object[name];
    object[name] =
      value && typeof value === "object" ? deepFreeze(value) : value;
  }
  return Object.freeze(object);
}
let person = {
  name: "Leonardo",
  profession: {
    name: "developer",
  },
};
deepFreeze(person);
person.profession.name = "doctor"; // TypeError: Cannot assign to read only property 'name' of object
```

---

---
