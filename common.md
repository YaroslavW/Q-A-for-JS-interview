# Общие вопросы о веб-разработке

![logo General Web Dev](img/general-bliz-50.jpg)

## 1. Используете вы `Perfect Pixel` или что-то аналогичное?

`Pixel Perfect` верстка — это особая техника создания структуры `html`-кода, которая позволяет сверстанному `html`-шаблону максимально точно совпадать с оригинальным PSD-макетом пиксель в пиксель. При наложении `html`-шаблона на макет PSD должно произойти полное совпадение графических элементов, изображений и текста.

Следует уточнить про допуски при верстке, `5px - 10px`

---

## 2. Можете ли пояснить разницу между `progressive enhancement` и `graceful degradation`?

`graceful degradation` будет пониматься как отказоустойчивость клиентских веб-интерфейсов. Постепенная деградация может выражаться в возможности работы при отключённом JavaScript, в достаточно аккуратном отображении интерфейса в браузере, не поддерживающем новые свойства CSS3, в адекватном отображении сайта при отключенных изображениях. В каждом из этих случаев работа пользователя с интерфейсом будет в принципе возможна, хотя и не так удобна.

Что же такое `progressive enhancement`? Чаще всего этот термин переводят, как прогрессивное улучшение. Прогрессивное улучшение предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего. Можно сказать, что сейчас таких этапов четыре

- «Старый-добрый-HTML»
- «CSS»
- «CSS3»
- «JavaScript»

Подробнее - https://htmlacademy.ru/blog/useful/html/progressive-enhancement

---

## 3. Что такое прогрессивный `JPEG`?

Оптимизированные для веба фото — это `jpeg`, а `jpeg` делится на два типа: базовый последовательный (`baseline`) и прогрессивный (`progressive`). Последовательный `jpeg` — это один скан изображения сверху вниз в полном разрешении, а прогрессивный `jpeg` — это серия сканов улучшающегося качества. Так они и рендерятся — последовательный `jpeg` отрисовывается сверху вниз («тик, тик, тик, …»), а прогрессивный быстро размечает свою территорию и затем совершенствуется (по крайней мере так задумано).

Подробнее - https://habr.com/ru/post/165645/

---

## 4. Что такое `feature detection` (определение возможностей браузера)?

`Feature detection` определяет, поддерживает ли браузер тот или иной блок кода и запускает различный код в зависимости от того, поддерживает или нет, так чтобы браузер всегда мог показать рабочий код, вместо репортов об ошибках.

### 2 способа определения в js:

1. распарсить юзер-агент, определить версию браузера и писать в коде свитчи по версии браузера
2. Проверить наличие свойства или метода в `window`(`dom`, `bom`, `javascript`):

```js
if ("geolocation" in navigator) {
  navigator.geolocation.getCurrentPosition(function (position) {
    // show the location on a map, perhaps using the Google Maps API
  });
} else {
  // Give the user a choice of static maps instead perhaps
}
```

### 1 способ в css:

- @supports

Подробней:

- https://developer.mozilla.org/de/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection
- https://habrahabr.ru/post/336466/

---

## 5. Как проверить что куки включенны?

```js
if (!navigator.cookieEnabled) {
  alert("Включите cookie для комфортной работы с этим сайтом");
}
```

---

## 6. Объясните, что означает "Семантическая разметка"

Семантическая вёрстка, или семантический HTML-код, — это подход к созданию веб-страниц на языке HTML, основанный на использовании HTML-тегов в соответствии с их семантикой (предназначением), а также предполагающий логичную и последовательную иерархию страницы. Он противопоставляется подходу, при котором написание HTML-кода определяется внешним видом веб-страницы. Для оформления веб-страниц, написанных в соответствии с семантикой, используются каскадные таблицы стилей (CSS). Стандарт HTML с самого начала включал в себя ряд семантических тегов, но большую популярность семантическая вёрстка получила после начала работ над HTML5.

Подробнее: https://ru.wikipedia.org/wiki/Семантическая_вёрстка

---

## 7. Как можно оптимизировать загрузку внешних ресурсов на странице?

1. Уменьшите количество HTTP-запросов
2. Используйте поддомены для параллельного скачивания
3. Используйте кэш браузера
4. Используйте CDN для загрузки популярных JavaScript библиотек
5. Используйте Gzip- сжатие

Подробней по каждому пункту: https://habrahabr.ru/post/137239/

---

## 8.Каково преимущество в подгрузке внешних ресурсов с нескольких доменов?

Cогласно спецификации `HTTP/1.1` на браузеры накладываются ограничения на количество одновременно загружаемых компонентов сайта, а именно не более 2-х компонентов с одного хоста. Поэтому если на Вашем сайте много графики, то ее лучше вынести на отдельный поддомен или поддомены. Для Вас это будет один и тот же сервер, а для браузера – разные. Чем больше поддоменов Вы создадите, тем больше файлов браузер сможет одновременно загрузить и тем быстрее загрузится вся страница сайта. Вам остается лишь изменить адрес картинок на новый. Очень простой, но действенный способ.

---

## 9. Назовите способы уменьшения времени загрузки страницы (воспринимаемого или реального)

1. Помещайте CSS файлы в начале страницы
2. Помещайте javascript в конец страницы
3. Минимизируйте css и javascript
4. Оптимизируйте ваши изображения
5. Не масштабируйте изображения

Подробней по каждому пункту: https://habrahabr.ru/post/137239/

---

## 10. Что такое `FOUC` (`Flash Of Unstyled Content`)? Как его избежать?

`Flash of Unstyled Content` (`FOUC`) – это кратковременное появление неоформленных HTML-элементов в некоторых версиях браузеров – сразу же после создания визуальных элементов и до полного применения стилей CSS.

- `css {display: block}` на компонент
- В обратных кавычках \` \` инлайнится код, необходимый для показа минимум `600px` высоты страницы без загрузки дополнительных стилей.

---

## 11.Что такое критический путь рендеринга веб-страниц?

Критический путь рендеринга – это набор минимально необходимых для начала отрисовки страницы действий, ресурсов и вычислений.

Критический путь можно измерять в количестве критических ресурсов, минимальном времени загрузки (измеряется в RTT) и объеме критических ресурсов (в байтах).

Для иллюстрации возьмем простейший пример: HTML страницу размером 1 кб без внешних ресурсов. Критический путь будет: 1 ресурс (HTML-документ), 1 RTT (минимально), 1 кб трафика. Однако, таких простых страниц в природе почти не встретить, поэтому покажем, как можно определять критический путь на реальных веб-страницах.

Подробней:

- https://habrahabr.ru/post/262239/

---

## 12. Что такое `WebSQL`?

`WebSQL DB` — это API для доступа к полноценному SQL-хранилищу данных, основанному на `SQLite`. Впрочем, последнее обстоятельство — скорее, особенность реализации и стандартом не оговаривается, хотя диалект `SQL` используется именно от `SQLite`.

Подробней:

- (en) https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Storage
- https://habrahabr.ru/post/84654/
- (Раздел: За пределами пары ключ/значение: конкурентное видение) http://htmlbook.ru/html5/storage

---

## 13. Является ли `WebSQL` частью спецификации HTML 5?

Нет. Многие относят его к HTML 5, но WebSQL не является частью спецификации HTML 5. Спецификация основана на `SQLite`.

Поддержка браузерами: https://caniuse.com/#search=websql

---

## 14. Является ли, `Drag and drop` частью спецификации? Какие drag-события Вам известны?

Да, это часть спецификации

**dragstart, dragenter, dragover, dragleave, drag, drop, dragend**

Подробней: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Drag_and_drop#events

---

## 15. Является ли `Web workers` частью спецификации HTML 5?

Да. `Worker` - это объект, созданный при помощи конструктора (например, `Worker()`), который запускает JavaScript файл по имени — этот файл содержит код, который будет выполнен в потоке Worker'а; объекты Workers запускаются в другом глобальном контексте, который отличается от текущего `window`. Таким образом, использование переменной `window` для получения текущего глобального контекста (вместо `self`) внутри `Worker` вернет ошибку.

- https://developer.mozilla.org/ru/docs/DOM/Using_web_workers
- https://html.spec.whatwg.org/multipage/#toc-workers

---

## 16. Является ли `service workers` частью спецификации HTML 5?

`Service worker` запускается в контексте worker'ов, поэтому он не имеет доступа к DOM и работает в потоке отдельном от основного потока JavaScript, управляющего вашим приложением, а следовательно — не блокирует его. Он призван быть полностью асинхронным; как следствие, синхронные API, такие как `XHR` и `localStorage`, в `service worker`'е использовать нельзя.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API
- https://html.spec.whatwg.org/multipage/#toc-workers

---

## 17. Что такое гиперссылка?

Часть гипертекстового документа, ссылающаяся на другой элемент (команда, текст, заголовок, примечание, изображение) в самом документе, на другой объект (файл, каталог, приложение), расположенный на локальном диске или в компьютерной сети, либо на элементы этого объекта.

Подробней: https://ru.wikipedia.org/wiki/Гиперссылка

---

## 18. Что такое `GraphQL`?

В двух словах, `GraphQL` это синтаксис, который описывает как запрашивать данные, и, в основном, используется клиентом для загрузки данных с сервера. `GraphQL` имеет три основные характеристики:

Позволяет клиенту точно указать, какие данные ему нужны.
Облегчает агрегацию данных из нескольких источников.
Использует систему типов для описания данных.

Подробней:

- https://habrahabr.ru/post/326986/

---

## 19. Что такое `HTTP`?

Протокол передачи гипертекста (`Hypertext Transfer Protocol - HTTP`) это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение, создаёт запрос, а затем ждет ответа.

HTTP - это `stateless`-протокол, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на `TCP/IP`, он так же может использовать любой транспорт, который не теряет молча сообщения (то есть он обязан знать дошло ли сообщение до адресата).

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTTP
- https://ru.wikipedia.org/wiki/HTTP
- https://habrahabr.ru/post/215117/

---

## 20. Если через консоль, примеру curl'oм, запросить сайт, что мы увидим?

Стандартный ответ страницы, как для браузера

Еще желательно знать, как организовывается докачка файлов, после восстановления соединения.

Подробней:

- https://ru.wikipedia.org/wiki/HTTP

---

## 21. Перечислите хотя бы 4 метода `HTTP`:

`GET`, `POST`, `PUT`, `DELETE`

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTTP
- https://ru.wikipedia.org/wiki/HTTP

---

## 22. Назовите 5 классов ошибок при HTTP запросе:

1. Информирование о процессе передачи.

2. Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.

3. Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов `301`, `302`, `303`, `305` и `307` относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке `Location`. При этом допускается использование фрагментов в целевом URI.

4. Указание ошибок со стороны клиента. При использовании всех методов, кроме `HEAD`, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.

5. Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода `HEAD`, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTTP
- https://ru.wikipedia.org/wiki/HTTP

---

## 23. В чем отличия `HTTP/1` от `HTTP/2`?

Протокол `HTTP/2` является бинарным. По сравнению с предыдущим стандартом изменены способы разбиения данных на фрагменты и транспортирования их между сервером и клиентом.

В `HTTP/2` сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.

Также часть улучшений получена за счёт мультиплексирования запросов и ответов для преодоления проблемы «`head-of-line blocking`» протоколов `HTTP 1`; сжатия передаваемых заголовков и введения явной приоритезации запросов.

Так же поддерживает приоритетность загрузки

Подробней:

- https://ru.wikipedia.org/wiki/HTTP/2

---

## 24. Где именно хранятся данные `session` и как сервер понимает как сопоставить конкретные данные `session` конкретному `http` запросу?

Сессии могут храниться на клиенте (`signed cookie session`). При этом используется подпись куки с помощью `HMAC`, чтобы данные сессии не могли быть свободно изменены клиентом. Но обычно сессии хранятся на сервере. Тут выбор огромный: от баз данных и key-value хранилищ (Redis, например) до простых файлов. При этом, клиенту посылается кука `ID` сессии (так сервер идентифицирует юзера), которую злоумышленник может стащить.

Таким кукам, дабы защитить юзеров от `XSS`, ставится флаг `HttpOnly`, который советует браузеру не давать эту куку скриптам вроде JS. В этом случае, стащить куку получится только завладев браузером, файловой системой юзера или через багу браузера.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTTP/Куки

---

## 25. Что такое `HTTPS`?

`HTTPS` (`HyperText Transfer Protocol Secure`) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе `HTTPS` передаются поверх криптографических протоколов `SSL` или `TLS`. В отличие от `HTTP` с `TCP`-портом 80, для `HTTPS` по умолчанию используется `TCP-порт 443`

Подробней:

- https://yandex.ru/blog/company/77455
- https://ru.wikipedia.org/wiki/HTTPS

---

## 26. Что такое `REST`?

`REST` (`Representational State Transfer` — «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. `REST` представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле компоненты в `REST` взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. `REST` является альтернативой `RPC`.

Подробней:

- https://ru.wikipedia.org/wiki/REST
- https://habrahabr.ru/post/38730/

---

## 27. Что такое протокол-`SOAP`?

`SOAP` (`Simple Object Access Protocol` — простой протокол доступа к объектам) — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально `SOAP` предназначался в основном для реализации удалённого вызова процедур (`RPC`). Сейчас протокол используется для обмена произвольными сообщениями в формате `XML`, а не только для вызова процедур. Официальная спецификация последней версии 1.2 протокола никак не расшифровывает название `SOAP`. `SOAP` является расширением протокола `XML-RPC`.

Подробней:
https://ru.wikipedia.org/wiki/SOAP

---

## 28. Что такое нотация О-большое?

В информатике временна́я сложность алгоритма определяет время работы, используемое алгоритмом, как функции от длины строки, представляющей входные данные. Временная сложность алгоритма обычно выражается с использованием нотации «O» большое, которая исключает коэффициенты и члены меньшего порядка. Если сложность выражена таким способом, говорят об асимптотическом описании временной сложности, т.е. при стремлении размера входа к бесконечности. Например, если время, которое нужно алгоритму для выполнения работы, для всех входов длины n не превосходит `5n3 + 3n` для некоторого `n` (большего некоторого `n0`), асимптотическая временная сложность равна `O (n3)`.

Подробней:

- https://ru.wikipedia.org/wiki/Временная_сложность_алгоритма
- https://habrahabr.ru/post/195482/
- https://habrahabr.ru/post/188010/

---

## 29. Что такое `HMAC`?

`HMAC` (сокращение от англ. `hash-based message authentication code`, код аутентификации (проверки подлинности) сообщений, использующий хеш-функции) — в информатике (криптографии), один из механизмов проверки целостности информации, позволяющий гарантировать то, что данные, передаваемые или хранящиеся в ненадёжной среде, не были изменены посторонними лицами (см. человек посередине).

Механизм HMAC использует MAC, описан в `RFC 2104`, в стандартах организаций `ANSI`, `IETF`, `ISO` и `NIST`.

`MAC` — стандарт, описывающий способ обмена данными и способ проверки целостности передаваемых данных с использованием секретного ключа. Два клиента, использующие `HMAC`, как правило, разделяют общий секретный ключ.

`HMAC` — надстройка над MAC; механизм обмена данными с использованием секретного ключа (как в MAC) и хеш-функций. В зависимости от используемой хеш-функции выделяют `HMAC-MD5`, `HMAC-SHA1`, `HMAC-RIPEMD128`, `HMAC-RIPEMD160` и т. п.

Подробней:

- https://ru.wikipedia.org/wiki/HMAC

---

## 30. Что такое `CORS`?

`CORS` (`Cross-Origin Resource Sharing`,"Совместное использование ресурсов между разными источниками") - это система, состоящая из отправки `HTTP` заголовков, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.

`The same-origin security policy` ("правило ограничения домена") по умолчанию запрещает междоменные запросы. `CORS` предоставляет веб-серверам возможность контролировать междоменные запросы и позволяет производить безопасный обмен данными между разными доменами.

Подробней:

- https://developer.mozilla.org/ru/docs/Словарь/CORS
- https://habrahabr.ru/company/pentestit/blog/337146/
- https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy

---

## 31. Что такое архитектурный-паттерн MVC?

`Model-View-Controller` (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо

- **Модель** (Model) предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.

- **Представление** (View) отвечает за отображение данных модели пользователю, реагируя на изменения модель.

- **Контроллер** (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений.

Есть `passive model` & `active model`. Но из-за веба, этот паттер, претерпел изменения, что вносит смуту, и вряд ли получится найти 3 программиста, у которых совпадет понимание этого паттерна. Главное понимать общие черты, чтобы суметь отличить от `MVVM(bindings)` ;)

**Признаки контроллера**:

- Контроллер определяет, какие представление должно быть отображено в данный момент;
- События представления могут повлиять только на контроллер.контроллер может повлиять на модель и определить другое представление.
- Возможно несколько представлений только для одного контроллера;

Подробней:

- https://codepen.io/fikorte/pen/Rjgmqr?limit=all&page=2&q=mvc+example
- https://codepen.io/broneks/pen/RWRLRG?editors=1010
- https://codepen.io/kyliepace/pen/aNepxV?editors=1010
- https://codepen.io/bobodeity/pen/xPbwzX
- https://habrahabr.ru/company/devexpress/blog/305812/
- https://codepen.io/MrCheater/pen/GqQpYY?editors=1010

---

## 32. Что такое архитектурный-паттерн `MVP`?

Данный подход позволяет создавать абстракцию представления. Для этого необходимо выделить интерфейс представления с определенным набором свойств и методов. Презентер, в свою очередь, получает ссылку на реализацию интерфейса, подписывается на события представления и по запросу изменяет модель.

**Признаки презентера**:

- Двухсторонняя коммуникация с представлением;
- Представление взаимодействует напрямую с презентером, путем вызова соответствующих функций или событий экземпляра презентера;
- Презентер взаимодействует с View путем использования специального интерфейса, реализованного представлением;
- Один экземпляр презентера связан с одним отображением.

Подробеней:

- https://habrahabr.ru/post/215605/
- https://stackoverflow.com/questions/2056/what-are-mvp-and-mvc-and-what-is-the-difference
- https://habrahabr.ru/post/171925/
- https://habrahabr.ru/company/mobileup/blog/313538/

---

## 33. Что такое архитектурный-паттерн `MVVM`?

Данный подход позволяет связывать элементы представления со свойствами и событиями View-модели. Можно утверждать, что каждый слой этого паттерна не знает о существовании другого слоя.

**Признаки презентера**:

- Двухсторонняя коммуникация с представлением;
- View-модель — это абстракция представления. Обычно означает, что свойства представления совпадают со свойствами View-модели / модели
- View-модель не имеет ссылки на интерфейс представления (IView). Изменение состояния View-модели автоматически изменяет представление и наоборот, поскольку используется механизм связывания данных (Bindings)
- Один экземпляр View-модели связан с одним отображением.

Подробней:

- https://habrahabr.ru/post/215605/

- https://ru.wikipedia.org/wiki/Model-View-ViewModel

- https://habrahabr.ru/company/mobileup/blog/313538/

---

## 34. Что такое `DOM`?

Объектная Модель Документа (`DOM`) является программным интерфейсом для `HTML`, `XML` и `SVG` документов. Это обеспечивает структурированное представление документа (дерева), и определяет способ, по которому структура может быть доступна для программы, для изменения структуры документа, его стиля и содержания. `DOM` обеспечивает представление документа в виде структурированной группы узлов и объектов, которые имеют свойства и методы. По сути, она связывает веб -страницы со скриптами или языками программирования.

DOM (`Document Object Model` — «объектная модель документа») — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому `HTML-`, `XHTML-` и `XML`-документов, а также изменять содержимое, структуру и оформление таких документов.

Подробней:

- https://developer.mozilla.org/ru/docs/DOM/DOM_Reference
- https://ru.wikipedia.org/wiki/Document_Object_Model

---

## 35. Что такое `Virtual DOM`? Как он работает?

`Virtual DOM`- это абстракция HTML DOM, которая выборочно отображает поддеревья узлов на основе изменений состояния. Он обеспечивает минимальное количество манипуляций с `DOM`, чтобы поддерживать ваши компоненты в актуальном состоянии.

Подробней:

- https://medium.com/treenodes/intro-to-react-2-41b84dd74b5d
- https://habrahabr.ru/post/256965/
- https://medium.com/devschacht/how-to-write-your-own-virtual-dom-c166b56cf01f

---

## 36. Что такое `Shadow DOM`?

Спецификация `Shadow DOM` является отдельным стандартом. Частично он уже используется для обычных DOM-элементов, но также применяется для создания веб-компонентов.

`Shadow DOM` – это внутренний DOM элемента, который существует отдельно от внешнего документа. В нём могут быть свои ID, свои стили и так далее. Причём снаружи его, без применения специальных техник, не видно, поэтому не возникает конфликтов.

Подробней:

- https://learn.javascript.ru/shadow-dom
- https://habrahabr.ru/post/180377/
- https://habrahabr.ru/post/259187/
- https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM

---

## 37.Чем отличаются между собой `Shadow DOM` и `Virtual DOM` и `Regular Dom`?

`Virtual DOM` – полное представление реального DOM. Его самой важной особенностью является группировка изменений и выполнение одиночного повторного рендеринга вместо множества мелких. Если коротко, то можно сказать, что `Virtual DOM` решает проблемы, связанные с производительностью (Не буду вдаваться в подробности принципа работы `Virtual DOM`. В рамках этой статьи достаточно знать, зачем он нужен.)

`Shadow DOM`, как настоящий интроверт, надежно защищает себя от влияния окружающих элементов и не заинтересован и не интересуется изменениями снаружи. Спросите себя, какую главную UI-проблему решают фреймворки типа React и VueJS?

**Инкапсуляция**

`CSS` – сложная штука. Все становится еще сложнее, если вы соединяете стили, пытаясь повторно их использовать в различных комбинациях. Это неизбежно приводит к регрессивным ошибкам интерфейса, сложному обслуживанию и плохой масштабируемости. И все же, я считаю, что основная проблема это не CSS, а то, как мы его используем.

`Shadow DOM` – инструмент, помогающий обойти инкапсуляцию DOM на нативном уровне. Суть не просто в CSS, а в элементах.

В отличие от обычного DOM Shadow DOM идет маленькими кусочками. То есть это не полное представление всего DOM. Представьте Shadow DOM в виде лего, формирующего реальный DOM, где каждый кирпичик представляет собой отдельный DOM.

`Shadow DOM` – это инкапсуляция.

Подробней:

- https://develoger.com/shadow-dom-virtual-dom-889bf78ce701

---

## 38. Что такое ООП и на каких 4х постулатах оно стоит?

1. абстрагирование для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счете — контекстное понимание предмета, формализуемое в виде класса;

2. инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;

3. наследование для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя все остальное, учтенное на предыдущих шагах;

4. полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.

Подробней:

- https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование

---

## 39.Что такое инкапсуляция?

Инкапсуляция - это механизм, который объединяет данные и методы, манипулирующие этими данными, и защищает и то и другое от внешнего вмешательства или неправильного использования. Когда методы и данные объединяются таким способом, создается объект.

Подробней:

- https://ru.wikipedia.org/wiki/Инкапсуляция_(программирование)
- https://habrahabr.ru/post/87205/

---

## 40. Какие классификации паттернов проектирования Вы знаете?

**Порождающие паттерны** беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

**Структурные паттерны** показывают различные способы построения связей между объектами.

**Поведенческие паттерны** заботятся об эффективной коммуникации между объектами.

Подробней:

- https://refactoring.guru/ru/design-patterns/classification
- https://ru.wikipedia.org/wiki/Шаблон_проектирования

---

## 41. Назовите паттерны, которые относятся к порождающим

- **Одиночка(Singleton)**:
  Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

- https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/singleton
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/singleton

- **Абстрактная фабрика(Abstract factory)**
  Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

- https://ru.wikipedia.org/wiki/Абстрактная_фабрика_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/abstract-factory
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/abstract_factory

- **Фабричный метод(Factory method)**
  Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

- https://ru.wikipedia.org/wiki/Фабричный_метод_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/factory-method
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/factory_method

- **Строитель(Builder)**
  Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

- https://ru.wikipedia.org/wiki/Строитель_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/builder
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/builder

- **Прототип(Prototype)**
  Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

- https://ru.wikipedia.org/wiki/Прототип_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/prototype
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/prototype

- **Менее известные**: \* **Отложенная инициализация(Lazy initialization)**
  Объект, инициализируемый во время первого обращения к нему.

Подробнее:

- https://ru.wikipedia.org/wiki/Отложенная_инициализация

  - **Пул одиночек(Multiton)**
    Гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к ним.

    По сути данный паттерн – это реестр одиночек, каждый из которых имеет имя, по которому к нему можно получить доступ.

    Пул одиночек ( Multiton ) — Гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к ним.

```js
/*  
	Use, reuse but don't abuse!
	Author: Razvan Caliman (razvan.caliman@gmail.com)
	
	This is an example of a "Multiton" pattern;
	Create a fixed number of instances of a class.
	Use "lazy instantiation" to create objects only if needed.
	If the maximum number of instances has been reached, return a random one from the ones created.
*/
var Multiton = (function () {
  var inst = [],
    maxInst = 4;

  var Multiton = function () {
    this.inst = inst;
  };

  return function () {
    var p, rand;

    //Still room for instances, create
    if (inst.length < maxInst) {
      p = new Multiton();
      inst.push(p);
    }
    //Enough instances, return a random one
    else {
      rand = Math.floor(Math.random() * 4);
      p = inst[rand];
      console.log("Max instances reached, you get instance: " + rand, p);
    }

    return p;
  };
})();

var p1 = new Multiton();
var p2 = new Multiton();
var p3 = new Multiton();
var p4 = new Multiton();
var p5 = new Multiton();

console.log(p1, p2, p3, p4, p5);
```

Подробнее:

- https://urandev.com/ru/blog/view/38/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD+%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F+MVC
- (en) https://en.wikipedia.org/wiki/Multiton_pattern

---

## 42. Назовите паттерны, которые относятся к структурным

- **Адаптер(Adapter / Wrapper)**
  Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

- https://ru.wikipedia.org/wiki/Адаптер_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/adapter
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/adapter

- **Мост(Bridge)**
  Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

- https://ru.wikipedia.org/wiki/Мост_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/bridge
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/bridge

- **Компоновщик(Composite)**
  Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, если бы это был единичный объект.

- https://ru.wikipedia.org/wiki/Composite
- https://refactoring.guru/ru/design-patterns/composite
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/composite

- **Декоратор(Decorator)**
  Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

- https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/decorator
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/decorator

- **Фасад(Facade)**
  Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

- https://ru.wikipedia.org/wiki/Фасад_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/facade
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/facade

- **Приспособленец(Flyweight) или Легковес**
  Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативной память за счёт экономного разделения общего состояния объектов между собой, вместо хранения одинаковых данных в каждом объекте.

- https://ru.wikipedia.org/wiki/Flyweight
- https://refactoring.guru/ru/design-patterns/flyweight
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/flyweight

- **Заместитель(Proxy)**
  Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

- https://ru.wikipedia.org/wiki/Proxy_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/proxy
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/proxy

- **Менее известные:** \* **Единая точка входа(Front controller)**
  Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.

- https://ru.wikipedia.org/wiki/Единая_точка_входа_(шаблон_проектирования)

---

## 43. Назовите паттерны, которые относятся к поведенческим

- **Цепочка обязанностей(Chain of responsibility)**
  Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

- https://ru.wikipedia.org/wiki/Chain_of_Responsibility
- https://refactoring.guru/ru/design-patterns/chain-of-responsibility
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/chain_of_responsibility

- **Команда, Action, Transaction(Command)**
  Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

- https://ru.wikipedia.org/wiki/Команда_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/command
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/command

- **Интерпретатор(Interpreter)**
  Решает часто встречающуюся, но подверженную изменениям, задачу.

- https://ru.wikipedia.org/wiki/Интерпретатор_(шаблон_проектирования)
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/interpreter

- **Итератор, Cursor(Iterator)**
  Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

- https://ru.wikipedia.org/wiki/Итератор_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/iterator
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/iterator

- **Посредник(Mediator)**
  Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

- https://ru.wikipedia.org/wiki/Mediator
- https://refactoring.guru/ru/design-patterns/mediator
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/mediator

- **Хранитель(Memento)**
  Снимок — это поведенческий паттерн проектирования, который позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов.

- https://ru.wikipedia.org/wiki/Хранитель_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/memento
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/memento

- **Наблюдатель(Observer)**
  Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

- https://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/observer
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/observer
- https://ru.wikipedia.org/wiki/Издатель-подписчик_(шаблон_проектирования)

- **Состояние(State)**
  Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

- https://ru.wikipedia.org/wiki/Состояние_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/state
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/state

- **Стратегия(Strategy)**
  Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс. После чего, алгоритмы можно взаимозаменять прямо во время исполнения программы.

- https://ru.wikipedia.org/wiki/Стратегия_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/strategy
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/strategy

- **Шаблонный метод(Template method)**
  Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

- https://ru.wikipedia.org/wiki/Шаблонный_метод_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/template-method
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/template_method

- **Посетитель(Visitor)**
  Посетитель — это поведенческий паттерн проектирования, который позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.

- https://ru.wikipedia.org/wiki/Посетитель_(шаблон_проектирования)
- https://refactoring.guru/ru/design-patterns/visitor
- https://github.com/torokmark/design_patterns_in_typescript/tree/master/visitor

---

## 44. Что такое функциональное программирование?

Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).

Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).

Подробней:

- https://ru.wikipedia.org/wiki/Функциональное_программирование
- https://habrahabr.ru/post/142351/
- https://ru.stackoverflow.com/questions/417898/Что-такое-функциональное-программирование
- https://tproger.ru/translations/functional-programming-concepts/
- https://habrahabr.ru/post/337880/

---

## 45. В чём разница между императивным и декларативным программированием?

Также подумаем о различиях ООП и ФП с точки зрения разницы между «императивным» и «декларативным» программированием.

Это общие термины, которые описывают общие характеристики нескольких парадигм программирования. ФП – пример декларативного программирования, а ООП – пример императивного программирования.

В базовом смысле императивное программирование касается того, как делать. Эта парадигма объясняет шаги конкретным образом и характеризуется циклами `for` и `while`, операторами `if` и `switch` и так далее.

```js
const sumArray = (array) => {
  let result = 0;
  for (let i = 0; i < array.length; i++) {
    result += array[i];
  }
  return result;
};
```

Напротив, декларативное программирование сосредотачивается на том, что делать. При этом абстрагируется от описания, как делать, и опирается на выражения. Это часто приводит к получению более краткого кода, но при масштабировании его становится сложнее отлаживать из-за меньшей прозрачности.

Вот декларативный подход к функции `sumArray()`, написанной выше.

```js
const sumArray = (array) => {
  return array.reduce((x, y) => x + y);
};
```

---

## 46. Что такое прототип-ориентированное наследование?

Наконец, мы подошли к прототип-ориентированному наследованию. Стилей объектно-ориентированного программирования несколько, и JavaScript использует прототип-ориентированное наследование. Система организует повторяющееся поведение с использованием действующих объектов – «прототипов».

Даже если идея прототипов окажется новой, JavaScript-разработчик сталкивается с этой системой, когда использует встроенные методы. Например, функции для работы с массивами – `map`, `reduce`, `splice` и другие – методы объекта `Array.prototype`. На самом деле, каждый экземпляр массива (определённый с помощью квадратных скобок `[]` или, что реже, с использованием `new Array()`) наследуется от `Array.prototype`. Поэтому методы вроде `map`, `reduce` и `splice` доступны по умолчанию.

То же относится почти всем другим встроенным объектам, таким как строки и логические значения. Только у некоторых, таких как `Infinity`, `NaN`, `null` и `undefined`, отсутствуют свойства или методы.

В конце цепочки прототипов находим `Object.prototype`, и почти каждый объект в JavaScript – экземпляр `Object.prototype`. `Array.prototype` и `String.prototype`, например, оба наследуют свойства и методы от `Object.prototype`.

Чтобы добавить свойства и методы к объекту с использованием синтаксиса прототипа, инициируем объект как функцию и используем ключевое слово `prototype` для добавления свойств и методов:

```js
function Person() {}
Person.prototype.forename = "John";
Person.prototype.surname = "Smith";
```

---

## 47. Стоит ли переопределять или расширять поведение прототипов?

Изменять поведение встроенных прототипов можно так же, как и создавать и расширять собственные прототипы, но почти каждый JavaScript-разработчик и большинство компаний не рекомендуют этого.

Если хотим, чтобы объекты имели одинаковое поведение, создаём пользовательский объект (или определяем собственный «класс» или «подкласс»), который наследуется от встроенного прототипа без внесения изменений в сам прототип. Если работаем с другими разработчиками, у них отчётливые ожидания относительно поведения JavaScript по умолчанию, и редактирование этого поведения по умолчанию может легко привести к ошибкам.

Однако стоит отметить, что не все разделяют это сильное сопротивление расширению встроенных прототипов. В [статье 2005 года](https://brendaneich.com/2005/06/javascript-1-2-and-in-between/) создатель JavaScript Брендан Эйх намекнул, что прототипная система на самом деле создавалась отчасти для возможности расширения!

---

## 48. Чем отличается выражение функции (`Function Expression`) от объявления функции (`Function Declaration`)?

Объявление функции использует ключевое слово `function`, за которым следует имя функции. Напротив, выражение функции начинается с `var`, `let` или `const`, за которым следует имя функции и оператор присваивания `=`. Вот примеры:

```js
// Объявление функции
function sum(x, y) {
  return x + y;
}

// Выражение функции: ES5
var sum = function (x, y) {
  return x + y;
};
// Выражение функции: ES6+
const sum = (x, y) => {
  return x + y;
};
```

При использовании главное отличие состоит в том, что объявления функций «**поднимаются**» (`hoisted`), а выражение функций – нет. Это означает, что объявления функций перемещаются интерпретатором JavaScript в верхнюю часть области видимости. Поэтому используем объявление функции и вызываем эту функцию в любом месте кода. Напротив, выражение функции вызывается только в линейной последовательности: определяется перед вызовом.

Сегодня JavaScript-разработчик предпочитает выражения функций по двум причинам:

- В первую очередь, функциональные выражения помогают создать более предсказуемую, структурированную кодовую базу. Конечно, этого можно достичь также и с объявлениями за счёт простоты избавления от грязного кода.
- Второе, используется синтаксис ES6 для выражений функций. Как правило, получается более кратко, а `let` и `const` предоставляют больше контроля над тем, можно ли переназначить переменную или нет, как увидим в следующем вопросе.

---

## 49. Почему `Math.max()` меньше, чем `Math.min()`?

То, что `Math.max() > Math.min()` возвращает `false`, звучит неправильно, но на самом деле, в этом много смысла. Если аргументы не указаны, `Math.min()` возвращает бесконечность `infinity`, а `Math.max()` возвращает `-infinity`. Это часть спецификации для методов `max()` и `min()`, но за выбором стоит логика. Взгляните на код:

```js
Math.min(1);
// 1
Math.min(1, infinity);
// 1
Math.min(1, -infinity);
// -infinity
```

Если `-infinity` считался бы аргументом по умолчанию для `Math.min()`, то каждый результат равнялся бы `-infinity`, что бесполезно. Поскольку аргумент по умолчанию равен `infinity`, добавление другого аргумента вернёт это число – желаемое поведение.

---

## 50. Почему `0.1 + 0.2 === 0.3` возвращает `false`?

Вкратце, это связано с тем, насколько точно JavaScript хранит числа с плавающей запятой в двоичном виде. Если введём следующие уравнения в консоль Google Chrome, то получим:

```js
0.1 + 0.2;
// 0.30000000000000004
0.1 + 0.2 - 0.2;
// 0.10000000000000003
0.1 + 0.7;
// 0.7999999999999999
```

Это вряд ли вызовет проблемы при вычислении простых уравнений, где не нужна высокая степень точности. Но вызывает головную боль даже в несложных приложениях, когда выполняется проверка на равенство. Рассмотрим решения этого вопроса.

### Фиксированная точка

Например, если известна максимальная точность, которая понадобится (допустим, работаем с валютами), используем целочисленный тип для хранения значения. Таким образом, вместо `4,99` долларов, запишем `499`, и будем выполнять любые уравнения с этим значением. Затем отобразим результат конечному пользователю с использованием выражения вроде `result = (value / 100).toFixed(2)`, которое возвращает строку.

### Двоично-десятичный код

Если точность в самом деле важна, другой вариант – использовать формат двоично-десятичного кода (BCD), к которому обращаемся в JavaScript с помощью [библиотеки BCD](https://formats.kaitai.io/bcd/javascript.html). Каждое десятичное значение хранится отдельно в одном байте (8 бит). Это неэффективно, поскольку байт хранит 16 отдельных значений, а эта система использует только значения 0-9. Однако, если точность важна для приложения, то стоит пойти на компромисс.

---

---

В целом, надеюсь, что эти вопросы помогли вам лучше понять JavaScript – как основные функции, так и особенности – и что помогут вам лучше подготовиться к следующему собеседованию.

---

---

# Вопросы по HTML

![logo General Web Dev](img/html-bliz-50.jpg)

## 1. Для чего нужен `doctype` и сколько разновидностей Вы можете назвать?

Элемент `DOCTYPE` предназначен для указания типа текущего документа — `DTD` (`document type definition`, описание типа документа). Это необходимо, чтобы браузер понимал, как следует интерпретировать текущую веб-страницу, поскольку HTML существует в нескольких версиях, кроме того, имеется `XHTML` (`EXtensible HyperText Markup Language`, расширенный язык разметки гипертекста), похожий на HTML, но различающийся с ним по синтаксису. Чтобы браузер «не путался» и понимал, согласно какому стандарту отображать веб-страницу и необходимо в первой строке кода задавать `DOCTYPE`.

- HTML 4.01
- HTML 5
- XHTML 1.0
- XHTML 1.1

1. Подробней про то, как указывать теги для определенного Doctype: http://htmlbook.ru/html/%21doctype
2. Хорошая полезная подробная статья: https://habrahabr.ru/post/71364/

---

## 2. Что такое режим совместимости (`Quirks Mode`) и стандартный режим (`Standards Mode`)

На сегодняшний день существует **три режима отображения**, которые используются движками разметки (_layout engines_) браузеров: режим совместимости (_quirks mode_), частично стандартный режим (_almost standards mode_) и стандартный режим (_full standards mode_).

В режиме совместимости (_quirks mode_), разметка эмулирует нестандартное поведение браузеров Navigator 4 и Internet Explorer 5. Этот режим необходим для поддержки сайтов, созданных до начала широкого применения веб стандартов.

В стандартном режиме (_full standards mode_) поведение браузера соответствует (будем надеяться) описанному в спецификациях HTML и CSS.

В частично стандартном режиме (_almost standards mode_) реализовано лишь незначительное количество так называемых "странностей" (quirks).

Если вы будете пользоваться неполным тегом `DOCTYPE`, устаревшим его видом, или вообще забудете про него, броузер перейдет в «загадочный» (_quirk_) режим и будет исходить из предположения, что вы писали код страницы с ошибками и вольно отступали от стандартов, т.е. так, как писали в конце 90-ых годов. В этом режиме броузер попытается разобрать вашу страницу по правилам обратной совместимости и выведет на экран, например, CSS так, как его вывел бы Internet Explorer 4-ой версии, а DOM будет работать так, как он работал именно в этом броузере (IE переключается в свой старый DOM, а Mozilla и Netscape 6 переключается вообще в бог знает что).

Подробней

- https://developer.mozilla.org/ru/docs/Web/HTML/Quirks_Mode_and_Standards_Mode
- https://habrahabr.ru/post/71364/

---

## 3. В чем разница между `HTML` и `XHTML`?

`XHTML` - это приложение `XML`, которое является довольно строгим языком с угловыми скобками.
`HTML` - это приложение `SGML`, которое является гораздо менее строгим языком с угловой скобкой.
(`XML` также является применением `SGML`.)
При написании кода `XHTML` придерживаются того же синтаксиса, который характерен для `HTML`. При этом разница между `HTML` и `XHTML` состоит в наборе некоторых обязательных правил.

Правила XHTML следующие.

- Все теги и их атрибуты должны быть набраны в нижнем регистре (строчными символами).
- Значения любых атрибутов необходимо заключать в кавычки.
- Требуется закрывать все теги, даже такие, которым не сопоставлен закрывающий тег.
- Должна соблюдаться правильная вложенность тегов.
- Нельзя использовать сокращенные атрибуты тегов.
- Вместо атрибута `name` следует указывать `id`.
- Следует определять DTD (_document type definition_, описание типа документа) с помощью элемента `DOCTYPE`.

Подробнее с примерами: -http://htmlbook.ru/xhtml/sintaksis-xhtml

---

## 4. Могут ли возникнуть проблемы при подаче страниц с типом `application/xhtml+xml`?

`MIME` (`Multipurpose Internet Mail Extensions`, многоцелевые расширения интернет-почты) — стандарт Интернет, является частью протокола HTTP. Задача MIME это идентификация типа содержимого документа по его заголовку. К примеру, текстовый файл имеет тип `text/plain`, а HTML-файл — `text/html`. Отправка заголовка обычно происходит на основе расширения файла веб-сервером.

Документы `XHTML` по умолчанию отправляются как `text/html`, что в действительности говорит о том, что мы имеем дело с `HTML`, а не `XHTML-файлом`. Чтобы задействовать возможности `XHTML` требуется отдавать файл с типом `application/xhtml+xml`. Если у вас установлен веб-сервер Apache, то вы можете сделать это через директиву `AddType`, добавив следующую строку в файл `.htaccess`, расположенный в корне сайта.

`AddType application/xhtml+xml .xhtml`

В данном случае мы говорим, что все файлы с расширением `.xhtml` отдавать как `application/xhtml+xml`. Если документы формируются через PHP, то можно отдавать заголовок следующим образом:

`header ("Content-type: application/xhtml+xml");`

Учтите, что эта строка должна идти до вывода любого текста на странице.

Браузер Internet Explorer до версии 8.0 включительно не поддерживает тип `application/xhtml+xml` и не сможет отобразить страницу, которая отдаётся с этим типом. Остальные браузеры, в том числе IE9, понимают этот тип как переход в стандартный режим.

Тип `application/xhtml+xml` необходим в случае, когда в документе применяется MathML (Mathematical Markup Language, язык математической разметки), предназначенный для добавления формул или `SVG` (`Scalable Vector Graphics`, масштабируемая векторная графика), язык разметки для создания на странице векторных рисунков. Если вы ничего не знаете об этих технологиях и пока не собираетесь их использовать, лучше отдавать документ как `text/html`. Это позволит охватить наибольшее количество браузеров и поисковых систем.

По сути, тип `text/html` для файлов с расширением `.html` или `.htm` настроен автоматически, поэтому не требуется предпринимать каких-либо действий для этого типа.

согласование содержимого для переключения между `application/xhtml+xml` и `text/html` так же, как вы описываете, не замечая проблем с поисковыми роботами. Строго говоря, вы должны учитывать значения `q` в заголовке `accept`, который указывает предпочтение пользовательского агента к каждому типу контента. Если пользовательский агент предпочитает принимать `text/html`, но будет принимать `application/xhtml+xml` в качестве альтернативы, то для обеспечения максимальной безопасности вы должны иметь страницу `text/html`.

---

## 5. Какая связь между `SGML`, `HTML`, `XML` и `XHTML`?

**SGML** (_Standard generalized markup language_ — стандартный обобщённый язык разметки) – это стандарт, который определяет разметку документа.

**HTML** – это язык разметки, который описывается с помощью SGML.

Итак, с помощью `SGML` было создано `DTD` (определение типа документа), на которое ссылается и которого должен придерживаться `HTML`. Поэтому вы всегда можете найти декларацию «`DOCTYPE`» в начале страницы `HTML`, которая определяет, какое `DTD` будет использовать браузер при разборе кода страницы.

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

Разбор кода по стандарту `SGML` был связан с определёнными трудностями, поэтому был создан `XML`, чтобы облегчить эту процедуру. `XML` использует `SGML`. Например, в `SGML` вы должны использовать открывающие и закрывающие теги, тогда как в `XML` вы можете использовать самозакрывающиеся теги, которые закрываются автоматически. `XHML` был создан из `XML` и использовался в `HTML 4.0`. Поэтому, например, в `HTML`, основанном на `SGML`, тег недопустим, а в `XHTML` он допускается. Вы можете использовать `XML` определение документа, как показано в следующем примере:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

Вкратце, `SGML` стоит в основе всего. Старые версии `HTML` основаны на `SGML`, а `HTML 4.0` использует `XHTML`, построенный на основе XML.

---

## 6. Как установить язык содержимого моей HTML страницы?

Всегда используйте языковой атрибут тэга `html` для объявления языка по умолчанию на странице. Если страница содержит контент на другом языке, добавляйте языковой атрибут к элементам, окружающим этот контент.

Используйте `lang` атрибут для HTML страниц и `xml:lang` атрибут для страниц XML. Для XHTML 1.x и документов HTML5 Polyglot используйте оба атрибута вместе.

Используйте языковые тэги из _IANA Language Subtag Registry_. Вы можете найти тэги также с помощью _Language Subtag Lookup_.

Используйте вложенные элементы для того, чтобы позаботиться о контенте и значения атрибутов для одинаковых элементов на разных языках.

Подробнее:

- https://www.w3.org/International/questions/qa-html-language-declarations.ru

---

## 7. Чем полезны `data`- атрибуты?

HTML5 спроектирован с возможностью расширения данных ассоциированных с каким-либо элементом, но в то же время не обязательно имеющих определённое значение. `data-*` атрибуты позволяют хранить дополнительную информацию в стандартных элементах HTML, без хаков вроде нестандартных атрибутов, лишних DOM-свойств или `Node.setUserData()`.

Синтаксис HTML

```html
<article
  id="electriccars"
  data-columns="3"
  data-index-number="12314"
  data-parent="cars"
></article>
```

Доступ в JavaScript

```js
var article = document.getElementById("electriccars");
article.dataset.columns; // "3"
article.dataset.indexNumber; // "12314"
article.dataset.parent; // "cars"
```

Доступ в CSS

```css
article::before {
  content: attr(data-parent);
}
```

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Using_data_attributes

---

## 8. Если рассматривать HTML5 как открытую web-платформу, на чем она строится, из каких компонентов состоит?

`HTML5` (англ. _HyperText Markup Language, version 5_) — язык для структурирования и представления содержимого всемирной паутины. Это пятая версия HTML. Хотя стандарт был завершён (рекомендованная версия к использованию) только в 2014 году (предыдущая, четвёртая, версия опубликована в 1999 году), ещё с 2013 года браузерами оперативно осуществлялась поддержка, а разработчиками — использование рабочего стандарта (англ. _HTML Living Standard_). Цель разработки HTML5 — улучшение уровня поддержки мультимедиа-технологий с одновременным сохранением обратной совместимости, удобочитаемости кода для человека и простоты анализа для парсеров.

Во всемирной паутине долгое время использовались стандарты _HTML 4.01, XHTML 1.0 и XHTML 1.1._ Веб-страницы на практике оказывались свёрстаны с использованием смеси особенностей, представленных различными спецификациями, включая спецификации программных продуктов, например веб-браузеров, а также сложившихся общеупотребительных приёмов. HTML5 был создан как единый язык разметки, который мог бы сочетать синтаксические нормы HTML и XHTML. Он расширяет, улучшает и рационализирует разметку документов, а также добавляет единый API для сложных веб-приложений.

В HTML5 реализовано множество новых синтаксических особенностей. Например, элементы `video`, `audio` и `canvas`, а также возможность использования SVG и математических формул. Эти новшества разработаны для упрощения создания и управления графическими и мультимедийными объектами в сети без необходимости использования сторонних API и плагинов. Другие новые элементы, такие как `section`, `article`, `header` и `nav`, разработаны для того, чтобы обогащать семантическое содержимое документа (страницы). Новые атрибуты были введены с той же целью, хотя ряд элементов и атрибутов был удалён. Некоторые элементы, например a, `menu` и `cite`, были изменены, переопределены или стандартизированы. API и DOM стали основными частями спецификации HTML5. HTML5 также определяет некоторые особенности обработки ошибок вёрстки, поэтому синтаксические ошибки должны рассматриваться одинаково всеми совместимыми браузерами.

Подробнее:

- https://ru.wikipedia.org/wiki/HTML5

---

## 9. В чем отличия `HTML5` от `HTML4.01` и `XHTML1.0`

Ниже представлен список отличий(не все):

Изменён синтаксис

Встраивание SVG и MathML в text/html

Новые элементы:

```html
<article>
  ,
  <aside>
    ,
    <audio>
      ,
      <canvas
        >,
        <command
          >,
          <datalist>
            ,
            <details
              >, <embed />,
              <figcaption>
                ,
                <figure>
                  ,
                  <footer>
                    ,
                    <header>
                      ,
                      <hgroup>
                        ,
                        <keygen
                          >,
                          <main>
                            ,
                            <mark
                              >,
                              <meter
                                >,
                                <nav>
                                  ,
                                  <output
                                    >,
                                    <progress
                                      >, <rp>,</rp
                                      ><rt
                                        >,
                                        <ruby
                                          >,
                                          <section>
                                            ,
                                            <source />
                                            ,
                                            <summary
                                              >,
                                              <time
                                                >,
                                                <video>, <wbr /></video></time
                                            ></summary></section></ruby></rt></progress
                                  ></output></nav></meter
                            ></mark></main
                        ></keygen>
                      </hgroup>
                    </header>
                  </footer>
                </figure></figcaption
            ></details></datalist></command
      ></canvas>
    </audio>
  </aside>
</article>
```

Новые компоненты ввода:

```html
date/time, email, url, search, number, range, tel, color
```

Новые атрибуты: `charset` (в meta), `async` (в script)

Глобальные атрибуты, которые могут быть применены ко всем элементам: `id`, `tabindex`, `hidden`, `data-*` (пользовательские атрибуты данных)

Элементы, которые будут исключены:

```html
<acronym
  >,
  <applet
    >,
    <basefont>
      ,
      <big
        >,
        <center>
          ,
          <dir>
            ,
            <font
              >,
              <frame
                >,
                <frameset
                  >,
                  <isindex
                    >,
                    <noframes>
                      ,
                      <strike
                        >, <tt></tt
                      ></strike></noframes></isindex></frameset></frame
            ></font>
          </dir></center
      ></big></basefont></applet
></acronym>
```

Подробнее: https://ru.wikipedia.org/wiki/HTML5

---

## 10. Что такое `HTTP cookie`?

`HTTP cookie` (`web cookie`, `cookie браузера`) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.

Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту оно отсылается.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTTP/Куки

---

## 11.Что такое `Secure` ("безопасные") и `HttpOnly cookies`?

"Безопасные" (`secure`) `cookie` отсылаются на сервер только если запрос выполняется по протоколу `SSL` и `HTTPS`. Однако важные данные никогда не следует передавать или хранить в cookies, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг secure никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 and Firefox 52, незащищенные сайты (`http:`) не могут создавать куки с флагом secure.

Куки `HTTPonly` не доступны из JavaScript через свойства `Document.cookie`, и через `XMLHttpRequest` и `Request API`, что помогает избежать межсайтового скриптинга (`XSS`). Устанавливайте этот флаг для тех cookie, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг `HttpOnly`.

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly`

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTTP/Куки

---

## 12. Объясните разницу между `cookies`, `sessionStorage` и `localStorage`.

- LocalStorage

  **Плюсы**:

  - Веб-хранилище можно рассматривать упрощенно как усовершенствование файлов cookie, обеспечивая гораздо большую емкость хранилища. Если вы посмотрите исходный код Mozilla, мы увидим, что 5120KB (5 МБ), равный 2,5 миллионам символов в Chrome), является размером хранилища по умолчанию для весь домен. Это дает вам значительно больше возможностей для работы, чем обычный cookie 4 КБ.

  - Данные не отправляются обратно на сервер для каждого HTTP-запроса (HTML, изображения, JavaScript, CSS и т.д.) - уменьшение количества трафика между клиентом и сервером.

  - Данные, хранящиеся в localStorage, сохраняются до явного удаления. Сделанные изменения сохраняются и доступны для всех текущих и будущих посещений сайта.

  **Минусы**:

  - Он работает в политике одного и того же происхождения. Таким образом, сохраненные данные будут доступны только в том же месте.

- Cookies

  **Плюсы**:

  - По сравнению с другими, ничего.

  **Минусы**:

  - Предел 4Kб предназначен для всего файла cookie, включая имя, значение, дату истечения срока годности и т.д. Чтобы поддерживать большинство браузеров, держите имя менее 4000 байт и общий размер файла cookie под 4093 байтами.

  - Данные отправляются обратно на сервер для каждого HTTP-запроса (HTML, изображения, JavaScript, CSS и т.д.) - увеличение количества трафика между клиентом и сервером.

  **Обычно допустимы следующие действия:**

  - 300 файлов cookie
  - 4096 байт для каждого файла cookie
  - 20 файлов cookie для каждого домена
  - 81920 байт для каждого домена (задано 20 файлов cookie максимального размера 4096 = 81920 байт.)

- sessionStorage
  **Плюсы**:

  - Он похож на localStorage.
  - Изменения доступны только для каждого окна (или вкладки в браузерах, таких как Chrome и Firefox). Сделанные изменения сохраняются и доступны для текущей страницы, а также для будущих посещений сайта в том же окне. Когда окно закрыто, хранилище удаляется.

  **Минусы**:

  - Данные доступны только внутри окна/вкладки, в котором он был установлен.
  - Данные не сохраняются, т.е. будут потеряны после закрытия окна/вкладки.
  - Подобно localStorage, работает в политике одинакового происхождения. Таким образом, сохраненные данные будут доступны только в том же месте.

Подробней:

- LocalStorage: https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage
- Cookies: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки
- SessionStorage: https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage

---

## 13. Каким способом, возможно вложить js-объект в `localstorage`?

`localStorage.setItem(‘Object’, JSON.stringify(Object))`

---

## 14. Нужно ли в 5-м `ХТМL` закрывать `/>` одиночные теги ?

По спецификации - не нужно. Закрывающие слэши предполагаются в XHTML, а в HTML (любой версии) они не нужны.

По здравому смыслу - тоже не нужно. Валидатор w3c так же не ругается.

---

## 15.Что такое кэш приложения в HTML5?

Доступность в оффлайне становится всё более важной для веб-приложений. Да, все браузеры имеют механизмы кэширования, но они ненадежны и работают не всегда ожидаемо. HTML5 устраняет некоторые из этих неприятностей с помощью интерфейса `ApplicationCache`.

Использование интерфейса кэша даёт вашему приложению три преимущества:

- автономный просмотр — пользователи могут исследовать ваш сайт целиком, когда они находятся в оффлайне;
- скорость — ресурсы кэшируются локально, поэтому загружаются быстрее;
- снижение нагрузки на сервер — браузер загружает с сервера только изменённые ресурсы.
- Кэш приложения (или AppCache) позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Ваше приложение будет работать корректно, даже если пользователь нажимает кнопку «Обновить», находясь в автономном режиме.

Подробней, как настроить и обновлять:

- http://htmlbook.ru/blog/rukovodstvo-po-ispolzovaniyu-kesha-prilozheniya

---

## 16. Дайте описание след. разделам в файле манифеста кеша: `CACHE`, `NETWORK` и `FALLBACK`.

- `CACHE` - Это стандартный раздел для записи. Файлы, перечисленные в этом блоке (или сразу после `CACHE MANIFEST`) будут явно кэшированы после того как они скачаны в первый раз.
- `NETWORK` - Файлы, перечисленные в этом разделе, это ресурсы, которые требуют подключения к серверу. Все запросы к этим ресурсам идут в обход кэша, даже если пользователь находится в оффлайне. Можно использовать \* для задания шаблона.
- `FALLBACK` Дополнительный раздел указывает резервные страницы, если ресурс недоступен. Первый URL является ресурсом, второй резервом. Оба адреса должны быть относительны и быть в том же месте, что и файл манифеста. Можно использовать \* для задания шаблона.

Подробней, как настроить и обновлять:

- http://htmlbook.ru/blog/rukovodstvo-po-ispolzovaniyu-kesha-prilozheniya

---

## 17. Объясните разницу между `<script>`, `<script async>` и `<script defer>`

**Просто `script` с `src`:**

- Получить страницу HTML (например, `index.html`)
- Начните синтаксический анализ HTML
- Парсер встречает тег `<script>`, ссылающийся на внешний файл `script`.
- Браузер запрашивает файл `script`. Между тем, синтаксический анализатор блокирует и останавливает анализ другого HTML на вашей странице.
- Через некоторое время загрузится и затем выполняется `script`.
- Парсер продолжает анализировать остальную часть HTML-документа.

**async**: Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении `<script async src="...">` браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.

**defer**: Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от `async`.

_Первое_ – браузер гарантирует, что относительный порядок скриптов с `defer` будет сохранён.

_Второе отличие_ – скрипт с `defer` сработает, когда **_весь HTML-документ_** будет обработан браузером.

Подробнее:

- https://learn.javascript.ru/external-script#асинхронные-скрипты-defer-async

---

## 18. Какое будет поведение `<script async defer>`?

При одновременном указании `async` и `defer` в современных браузерах будет использован **только** `async`, в IE9- – **только** `defer` (не понимает `async`).

Подробнее:

- https://learn.javascript.ru/external-script#асинхронные-скрипты-defer-async

---

## 19. Что такое прогрессивный рендеринг?

Прогрессивное рендеринг - это имя, данное методам, используемым для рендеринга содержимого для отображения как можно быстрее. Раньше он был гораздо более распространенным в дни перед широкополосным доступом в Интернет, но он по-прежнему полезен в современном развитии, поскольку мобильные соединения данных становятся все более популярными (и ненадежными!)

**Примеры таких методов**:

- Ленивая загрузка изображений, где (как правило) некоторые javascript загружают изображение, когда оно попадает в окно просмотра браузеров, вместо загрузки всех изображений при загрузке страницы.
- Приоритет видимого содержимого (или выше рендеринга сложения), где вы включаете только минимальные css/content/скрипты, необходимые для количества страницы, которая будет отображаться в чтобы браузер отображался как можно быстрее, вы можете использовать отложенный javascript (domready/load) для загрузки других ресурсов и контента.

Подробнее:

- Совсем глубоко: https://habrahabr.ru/post/210558/
- Как рендерит: https://habrahabr.ru/post/224187/
- https://habrahabr.ru/post/320430/
- https://stackoverflow.com/questions/33651166/what-is-progressive-rendering

---

## 20. Что такое `meta` теги?

Мета теги — часть программного HTML кода, заключенная между тегом `<head>...</head>` (заголовок страницы). Эти атрибуты не являются обязательными: они не видны пользователю, но сообщают определенную информацию поисковой системе (описание, заголовок, ключевые слова и т.д.).. Как правило, атрибуты любого метатега сводятся к парам «имя=значение», которые определяются ключевыми словами `content`, `name` или `http-equiv`.

**Аттрибуты**:

- `charset`: Задает кодировку документа.
- `content`: Устанавливает значение атрибута, заданного с помощью `name` или `http-equiv`.
- `http-equiv`: Предназначен для конвертирования метатега в заголовок HTTP.
- `name`: Имя метатега, также косвенно устанавливает его предназначение.

Подробнее об аттрибутах:

- http://htmlbook.ru/html/META
- https://www.ashmanov.com/education/articles/meta-tegi/

---

## 21. Как можно с помощью `meta-тега`, указать `HTTP - заголовок`?

`<meta http-equiv="Content-Type" content="text/html" />`

Много подброней:

- https://ru.wikipedia.org/wiki/Метатеги

---

## 22. Расскажите о `meta`-теге с `name=viewport`

Типичный сайт, оптимизированный для мобильных устройств, содержит следующий мета-тег:

```html
<meta name="viewport" content="width=device-width, initial-scale=1" />
```

Свойство `width` определяет размер окна просмотра. Он может быть установлен на определенное количество пикселей, скажем,`width=600` или на специальное значение `device-width`, которое означает ширину экрана в пикселях CSS в масштабе `100%`. (Есть также соответствующие значения `height` и `device-height`, которые могут быть полезны для страниц с элементами, которые изменяют размер или положение на основе высоты окна просмотра).

Свойство `initial-scale` контролирует уровень масштабирования при первой загрузке страницы. Свойства `maximum-scale`, `minimum-scale` и `user-scalable` определяют, как пользователям разрешено увеличивать или уменьшать страницу.

`"user-scalable=no"` запрещается любое масштабирование

Подброней:

- https://developer.mozilla.org/ru/docs/Mozilla/Mobile/Viewport_meta_tag

---

## 23. Какие теги практически обязательно должны быть в `head`?

```html
<meta charset="utf-8" /> <meta http-equiv="x-ua-compatible" content="ie=edge" />
<!-- Use the content="ie-edge" tag if your project
    supports Internet Explorer prior to version 11. -->
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>
<title>Page Title</title>
```

Много больше информации о том, что должно быть в head:

- https://gethead.info/

---

## 24. Есть ли разница: `meta charset="utf-8"` и `meta http-equiv="Content-Type" content="text/html; charset=utf-8"`?

В HTML5 они эквивалентны

Используйте `meta charset="utf-8"` для веб-браузеров при использовании HTML5.

Используйте `meta http-equiv="Content-Type" content="text/html; charset=utf-8"` при использовании HTML4 или XHTML или для устаревших парсеров dom, например DOMDocument в php

---

## 25. Как сделать чтобы все гиперссылки сайта открывались в новом окне, т.е чтобы по умолчанию использовался `target="_blank"`?

Нужно в области `head` прописать тег `base` с атрибутом `target="_blank"`:

```html
<head>
  <base target="”_blank”" />
</head>
```

---

## 26. А как теперь быть, если какую-то из гиперссылок я захочу открыть в этом же окне, т.е. не создавая новое?

В тег `a` этой ссылки вам уже нужно будет добавить атрибут `target="_self"`, ибо по умолчанию сейчас у нас используется `target="_blank"`

---

## 27. Что такое аттрибут `target` и какие значения он принимает и что делает?

По умолчанию, при переходе по ссылке документ открывается в текущем окне или фрейме. При необходимости, это условие может быть изменено атрибутом `target` тега `a`. В XHTML применение этого атрибута запрещено. Все значения аттрибуты начинаются с `_`

- `blank` - Загружает страницу в новое окно браузера.
- `self` - Загружает страницу в текущее окно.
- `parent` - Загружает страницу во фрейм-родитель, если фреймов нет, то это значение работает как self.
- `top` - Отменяет все фреймы и загружает страницу в полном окне браузера, если фреймов нет, то это значение работает как `self`.

Подробней:

- http://htmlbook.ru/html/a/target

---

## 28. Что такое абсолютная и относительная ссылка?

```html
<a href=”http://google.com/example.html”>Абсолютная ссылка</a>

<a href=”../../example.html”>Относительная ссылка</a>
```

---

## 29. Какие новые элементы форм введены в HTML 5?

**В HTML 5 введены десять новых важных элементов форм**:

- Color;
- Date;
- Datetime-local;
- Email;
- Time;
- Url;
- Range;
- Telephone;
- Number;
- Search;

---

## 30. Что такое элемент `datalist` в HTML 5?

Элемент `datalist` в HTML 5 помогает реализовать функцию автозаполнения в поле для ввода.

```html
<input list="Country" />
<datalist id="Country">
  <option value="India"> </option>
  <option value="Italy"> </option>
  <option value="Iran"> </option>
  <option value="Israel"> </option>
  <option value="Indonesia"> </option>
</datalist>
```

Подробней:

- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist

---

## 31. Что такое элемент `output` в HTML 5?

Элемент `output` требуется, когда вы хотите отобразить сумму двух введённых чисел в виде текста. Например, у вас есть два поля для ввода и вы хотите сложить числа из этих двух полей и отобразить их сумму в виде текста. Ниже приведён пример использования элемента `output` в HTML 5:

```html
<form
  onsubmit="return false"
  oninput="o.value = parseInt(a.value) + parseInt(b.value)"
>
  <input name="a" type="number" /> + <input name="b" type="number" /> =
  <output name="o" />
</form>
```

Вы можете заменить «`parseInt`» на «`valueAsNumber`» для простоты. Также вы можете использовать атрибут «`for`» элемента `output` для повышения читаемости.

```html
<output name="o" for="a b"></output>
```

Подробней:

- http://htmlbook.ru/blog/element-output

---

## 32. Что такое свойство `valueAsNumber`?

В HTML5 представлено свойство JavaScript `valueAsNumber` для полей формы (в частности: `number`, `date`, `range`). Оно возвращает значение в виде числа, а не строки, то есть нам больше не нужно использовать `parseInt` или `parseFloat`, и оператор `+` складывает, а не склеивает.

```html
<form
  onsubmit="return false"
  oninput="o.value = a.valueAsNumber + b.valueAsNumber"
>
  <input name="a" id="a" type="number" step="any" /> +
  <input name="b" id="b" type="number" step="any" /> =
  <output name="o" for="a b"></output>
</form>
```

Подробней:

- http://htmlbook.ru/blog/element-output

---

## 33. Для чего нужен атрибут `autocomplete`? Какие параметры принимает?

Этот атрибут помогает заполнять поля форм текстом, который был введён в них ранее. Значения сохраняет и подставляет браузер, при этом автозаполнение по соображениям безопасности может отключаться пользователем в настройках и не может в таком случае управляться атрибутом `autocomplete`.

- `on` - Включает автозаполнение текста.
- `off` - Отключает автозаполнение. Это значение обычно используется для отмены сохранения в браузере важных данных (паролей, номеров банковских карт), а также редко вводимых или уникальных данных (капча).

Подробней:

- http://htmlbook.ru/html/input/autocomplete

---

## 34. Какой формат у `input type="date"` в HTML5

`YYYY-MM-DD`

---

## 35. Какой метод запускает проигрывание аудио-файла?

`var sound = new Audio(«file.wav»);`

`sound.play();`

---

## 36. Какой формат видео файлов сейчас поддерживается html5?

`MPEG 4`

---

## 37. Какие элементы в HTML5 могут иметь `aria` атрибут?

Любой элемент

---

## 38. Знаете ли вы тег `dfn` и за что он отвечает?

Как правило, в документе, когда упоминается новый термин, он выделяется _курсивом_ и дается его определение. При использовании этого термина в дальнейшем, он считается уже известным читателю. Тег `dfn` применяется для выделения таких терминов при их первом появлении в тексте.

Браузеры отображают содержимое контейнера с помощью курсивного начертания.

Подробней:

- http://htmlbook.ru/html/DFN

---

## 39. Что такое SVG?

язык разметки масштабируемой векторной графики, созданный Консорциумом Всемирной паутины (W3C) и входящий в подмножество расширяемого языка разметки XML, предназначен для описания двумерной векторной и смешанной векторно/растровой графики в формате XML. Поддерживает как неподвижную, так и анимированную интерактивную графику — или, в иных терминах, декларативную и скриптовую.

Подробней:

- https://ru.wikipedia.org/wiki/SVG

---

## 40. Что такое `canvas` в HTML 5?

Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript). Он может, к примеру, использоваться для рисования графов, создания коллажей или простой (и не очень) анимации. Изображения в правой части статьи являются примерами использования , примеры их создания приводятся в этой статье.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial

---

## 41. В чём разница между `canvas` и `SVG`?

### `SVG`

- Плюсы:
  - Нет зависимости от разрешения — SVG лучше подходит для кроссплатформенных пользовательских интерфейсов, так как позволяет масштабировать изображение при различных разрешениях экрана.
  - SVG очень хорошо поддерживает анимацию. Элементы могут быть анимированы с использованием описательного синтаксиса или с помощью JavaScript.
  - Можно получить полный контроль над каждым элементом, используя `SVG DOM API` в JavaScript.
  - SVG хранится в формате `XML`, что предоставляет больше возможностей браузерам по обеспечению доступности SVG документов по сравнению с элементом canvas. Таким образом, `SVG` выглядит лучшим решением для пользовательских интерфейсов веб-приложений.
- Минусы:
  - Низкая скорость рендеринга при увеличении сложности документа (рисунка), так как используется модель `DOM`
  - Скорее всего, SVG не подходит для таких приложений как игры. Возможно лучшим выбором будет комбинация `HTML Canvas + SVG`.

### Canvas

- Плюсы:
  - Высокая производительность при отрисовке любых 2D объектов.
  - Стабильная производительность — всё есть пиксель. Производительность падает только при увеличении разрешения изображения.
  - Можно сохранить полученное изображение в `PNG` или `JPG` файл.
  - Лучше всего подходит для создания растровой графики (например, в играх, фракталов и т.п.), редактирования изображений и операций, требующих манипулирования на уровне пикселей.
- Минусы:

  - Отрисовка основана на пикселях.
  - Не существует API для анимации. Вам придется прибегать к использованию таймеров и других событий для обновления канвы.
  - Слабые возможности по рендерингу текста.
  - Возможно, не самый лучший выбор, когда доступность имеет решающее значение. Канва предоставляет вам поверхность для рисования в выбранном контексте (2D и 3D). Можно указать альтернативный контент внутри элемента canvas, который будет показан браузером при невозможности отображения графики. Кроме того, вы можете выполнить проверку доступности выбранного Canvas API с помощью JavaScript. На основе этого вы можете обеспечить различную функциональность для пользователей браузеров с разной поддержкой `HTML 5 Canvas`.
  - `HTML 5 Canvas` не подходит для создания веб-сайтов или интерфейсов веб-приложений, так как пользовательские интерфейсы обычно должны быть динамическими и интерактивными, а Canvas требует от вас постоянной перерисовки каждого элемента в интерфейсе.

Подробней:

- https://habrahabr.ru/company/simbirsoft/blog/332750/
- https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial

---

## 42. В каких случаях лучше выбрать `canvas`, а в каких `svg`?

### `HTML 5 Canvas` следует использовать для:

- Редактирования изображений: обрезки, изменения размеров, фильтров (удаления эффекта красных глаз, создания эффекта сепии, изменения цветности или яркости)
- Создания растровой графики: визуализации данных, создания фракталов и графиков функций.
- Анализа изображений: создания гистограмм и т.п.
- Создания игровой графики, такой как спрайты и фоны.

### `SVG` следует использовать для:

- Создания пользовательских интерфейсов веб-приложений, независимых от разрешения экрана.
- Высокоинтерактивных анимированных пользовательских интерфейсов.
- Графиков и диаграмм.
- Редактирования векторных изображений.

## 43. Что такое `WebGL`?

`WebGL` (`Web-based Graphics Library`) — программная библиотека для языка программирования JavaScript, позволяющая создавать на JavaScript интерактивную 3D-графику, функционирующую в широком спектре совместимых с ней веб-браузеров. За счёт использования низкоуровневых средств поддержки `OpenGL`, часть кода на `WebGL` может выполняться непосредственно на видеокартах. WebGL — это контекст элемента canvas HTML, который обеспечивает API 3D графики без использования плагинов. Спецификация версии 1.0 была выпущена 3 марта 2011 года. Проект по созданию библиотеки управляется некоммерческой организацией Khronos Group.

Подробней:

- https://ru.wikipedia.org/wiki/WebGL

---

## 44. Перечислите блочные элементы, которые Вам известны(хотя бы 5).

```html
<address>
  ,
  <article>
    ,
    <aside>
      ,
      <audio>
        ,
        <blockquote>
          ,
          <canvas
            >,
            <dd>
              ,
              <div>
                ,
                <dl>
                  ,
                  <fieldset>
                    ,
                    <figcaption>
                      ,
                      <figure>
                        ,
                        <footer>
                          ,
                          <form>
                            ,
                            <h1>
                              ,
                              <h2>
                                ,
                                <h3>
                                  ,
                                  <h4>
                                    ,
                                    <h5>
                                      ,
                                      <h6>
                                        ,
                                        <header>
                                          ,
                                          <hgroup>
                                            ,
                                            <hr />
                                            ,
                                            <li>
                                              ,
                                              <main>
                                                ,
                                                <nav>
                                                  ,
                                                  <noscript
                                                    >,
                                                    <ol>
                                                      ,
                                                      <output
                                                        >,
                                                        <p>,</p>
                                                        <pre>
, <section>
                                                            ,
                                                            <table>
                                                              ,
                                                              <tfoot>
                                                                ,
                                                                <ul>
                                                                  ,
                                                                  <video></video>
                                                                </ul>
                                                              </tfoot>
                                                            </table></section
                                                        ></pre>
                                                      </output></ol
                                                  ></noscript>
                                                </nav>
                                              </main>
                                            </li>
                                          </hgroup>
                                        </header>
                                      </h6>
                                    </h5>
                                  </h4>
                                </h3>
                              </h2>
                            </h1>
                          </form>
                        </footer>
                      </figure>
                    </figcaption>
                  </fieldset>
                </dl>
              </div></dd
          ></canvas>
        </blockquote>
      </audio>
    </aside>
  </article>
</address>
```

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTML/Block-level_elements

---

## 45. Перечислите строчные элементы, которые Вам известны(хотя бы 5).

```html
b, big, i, small, tt abbr, acronym, cite, code, dfn, em, kbd, strong, samp,
time, var a, bdo, br, img, map, object, q, script, span, sub, sup button, input,
label, select, textarea
```

Подробней:
--https://developer.mozilla.org/ru/docs/Web/HTML/Строчные_Элементы

---

## 46 Дайте пояснения, для какой цели добавленны след. элементы: `article`, `aside`, `audio`,`canvas`, `figcaption`, `figure`, `footer`, `header`, `hgroup`, `output`, `section`, `video`. (Кратко)

- _article_: Тег `article` задает содержание сайта вроде новости, статьи, записи блога, форума или др. Элемент должен содержать часть самодостаточной информации, которая может быть вырвана из контекста всей страницы без потери смысла.
- _aside_: Определяет блок сбоку от контента для размещения рубрик, ссылок на архив, меток и другой информации. Такой блок, как правило, называется «сайдбар» или «боковая панель».
- _audio_: Добавляет, воспроизводит и управляет настройками аудиозаписи на веб-странице. Путь к файлу задается через атрибут src или вложенный тег source. Внутри контейнера audio можно написать текст, который будет выводиться в браузерах, не работающих с этим тегом.
- _canvas_: Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript).
- _figcaption_: Содержит описание для тега figure. Тег figcaption должен быть первым или последним элементом в группе.
- _figure_ : Используется для группирования любых элементов, например, изображений и подписей к ним.
- _footer_: Тег `footer` задаёт «подвал» сайта или раздела, в нём может располагаться имя автора, дата документа, контактная и правовая информация.
- _header_: Тег `header` задает «шапку» сайта или раздела, в которой обычно располагается заголовок.
- _hgroup_: Используется для группирования заголовков веб-страницы или раздела. Внутри располагаются теги заголовков от `h1` до `h6`. Данный тег исключён из версии HTML от W3C, но остался в версии WHATWG, будущее элемента пока не определено.
- _output_: Определяет область в которую выводится информация, преимущественно с помощью скриптов.
- _section_: Задаёт раздел документа, может применяться для блока новостей, контактной информации, глав текста, вкладок в диалоговом окне и др. Раздел обычно содержит заголовок. Допускается вкладывать один тег `section` внутрь другого.
- _video_: Добавляет, воспроизводит и управляет настройками видеоролика на веб-странице. Путь к файлу задается через атрибут `src` или вложенный тег `source`.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTML/Element/article
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/aside
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/audio
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/canvas
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/figure
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/footer
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/header
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/hgroup
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/section
- https://developer.mozilla.org/ru/docs/Web/HTML/Element/video

---

## 47. На какие события `video` или `audio` можно подписаться?(Кандидат может не знать ни одного. Это легко гуглится в работе)

_abort, canplay, ended, loadstart, pause, play, playing_

Подробней:

- https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events

---

## 48 Чем отличается `article` от `section`?

Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:

- `div` — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.
- `section` — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.
- `article` — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.

Подробней:

- https://habrahabr.ru/post/214407/

---

## 49. Для чего нужен тег `noscript`?

Элемент HTML `noscript` определяет секцию html кода, которая будет вставлена, если в браузере пользователя нет либо отключена поддержка JavaScript'а.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/HTML/Element/noscript

---

## 50. Что такое категории контента в HTML5, cколько их, расскажите о них.

Каждый элемент HTML принадлежит некоторому количеству категорий контента, которые объединяют элементы с общим набором характеристик. Такая группировка является свободной, то есть не задает на самом деле отношение между элементами таких типов, но помогает определить и описать их поведение и правила, которым они должны следовать, особенно когда дело доходит до сложных деталей. Также возможна ситуация, когда элемент не входит ни в одну из этих категорий.

**Существует три типа категорий контента:**

- Основные категории контента, описывающие общие для многих элементов правила;
- Категории контента для элементов форм, описывающие общие правила для элементов форм;
- Особые категории контента, описывающие редкие категории, актуальные только для нескольких элементов, возможно, лишь в особом контексте.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Content_categories

---

## 51. Какие категории считаются основными категориями контента?

- _Метаданные_: Элементы, принадлежащие к категории метаданных, изменяют отображение или поведение HTML-документа, связывают его с другими документами и предоставляют другую дополнительную информацию о документе.
- _Потоковый контент_: Элементы основного потока обычно содержат текст и встроенный контент.
- _Секционный контент_: Подобные элементы создают секции (блоки) в текущей структуре документа, определяющие область действия заголовочного контента и элементов `header` и `footer`
- _Заголовочный контент_: Заголовочный контент задает заголовок секции, явно отмеченной структурным элементом или неявно – самим заголовочным.
- _Фразовый контент_: Фразовый контент определяет текст и его формат. Серии фразового контента образуют параграфы.
- _Встроенный контент_: Встроенный контент импортирует в документ другой ресурс или вставляет содержимое на другом языке разметки или принадлежащее другому пространству имен.
- _Интерактивный контент_: К интерактивному контенту относятся элементы, который специально разработаны для взаимодействия с пользователем.
- _Явный контент_: Контент считается явным, когда он не скрыт и не является пустым, это контент, который отображен и предметен. У элементов потокового или фразового контента должен быть хотя бы один явный узел.
- _Контент форм_: Контент форм включает в себя элементы, у которых есть владелец формы, обозначенный атрибутом `form`. Владелецем формы является либо элемент `form` либо элемент, id которого указан в атрибуте `form`.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Content_categories

---

## 52. Отличие `i` от `em` и `strong` от `b` т. д.?

Следует отметить, что теги `b` и `strong`, также как `i` и `em`, несмотря на сходный результат, не совсем эквивалентны и заменяемы. Первый тег `b` — относится к тегам физической разметки и устанавливает жирный текст, а тег `strong` — является тегом логической разметки и определяет важность помеченного текста. Такое разделение тегов на _логическое_ и _физическое_ форматирование изначально предназначалось, чтобы сделать HTML универсальным, в том числе не зависящим от устройства вывода информации. Теоретически, если воспользоваться, например, речевым браузером, то текст, оформленный с помощью тегов `b` и `strong`, будет отмечен по-разному. Однако получилось так, что в популярных браузерах результат использования этих тегов равнозначен.

---

## 53. Можно ли вложить `p` в другой такой же `p`? Можно ли вложить `div` в `p`?

Синтаксически `div` и `p` внутри `p` является **недопустимым** во всех стандартах HTML. Более того, при использовании соответствующего парсера HTML невозможно разместить элемент `div` внутри `p` в DOM, потому что открывающий тег `div` автоматически закрывает элемент `p`.

---

## 54. Какие теги запрещены в html5? (хотя бы 3, не страшно если ни одного)

```html
<applet>
  <ins>
    <col />
    ,
    <colgroup>
      <area />
      <basefont />
      <center>
        <bdo>
          <dir>
            <font>
              <frame />
              <frameset>
                <iframe>
                  <isindex>
                    <noframes>
                      <strike>
                        <u>
                          <tbody></tbody>
                          <tfoot>
                            <thead></thead>
                          </tfoot>
                        </u>
                      </strike>
                    </noframes>
                  </isindex>
                </iframe>
              </frameset>
            </font>
          </dir>
        </bdo>
      </center>
    </colgroup>
  </ins>
</applet>
```

Подробнее:

- https://html5book.ru/html-tags/
- https://html5book.ru/neobyazatelnye-tegi-html5/

---

## 55. Чем отличается класс (`class`) от идентификатора (`id`) в HTML?

**Идентификаторы**:

- В коде документа каждый идентификатор уникален и должен быть включён лишь один раз.
- Имя идентификатора чувствительно к регистру.
- Через метод `getElementById` можно получить доступ к элементу по его идентификатору и изменить свойства элемента.
- Стиль для идентификатора имеет приоритет выше, чем у классов.

**Классы**:

- Классы могут использоваться в коде неоднократно.
- Имена классов чувствительны к регистру.
- Классы можно комбинировать между собой, добавляя несколько классов к одному тегу.

---

## 56. Какое событие сработает при потери фокуса элементом формы?

Событие `onblur` возникает при потере элемента фокуса. Это обычно происходит, если щелкнуть на другой элемент текущего документа. Событие `onblur` противоположно по своему действию событию `onfocus`.

Подробенй:

- http://htmlbook.ru/html/attr/onBlur
- https://developer.mozilla.org/ru/docs/Web/Events/blur

---

## 57. Для чего существует тег `q`?

Тег `q` используется для выделения в тексте цитат. Содержимое контейнера автоматически отображается в браузере в кавычках.

Подробней:

- http://htmlbook.ru/html/Q

---

## 58. Что такое "Якорь"?

Якорем называется закладка с уникальным именем на определенном месте веб-страницы, предназначенная для создания перехода к ней по ссылке. Якоря удобно применять в документах большого объема, чтобы можно было быстро переходить к нужному разделу.

Подробней:

- http://htmlbook.ru/samhtml/yakorya

---

## 59. Расскажите про тег `keygen`

Используется для генерации пары ключей — закрытого и открытого. Когда форма отправляется на сервер, закрытый ключ сохраняется на локальном компьютере, а открытый ключ передается вместе с формой. Сами ключи необходимы для шифрования и расшифровки данных, создания и проверки цифровой подписи.

Подробней:

- http://htmlbook.ru/html/KEYGEN
- https://developer.mozilla.org/en-US/docs/Web/HTML/Element/keygen

---

## 60. Для олдскульных ребят, существует ли тег `basefont` и за что он отвечает?

Не существует, ни за что не отвечает

Существовал, убран из html5

Тег `basefont` предназначен для задания шрифта, размера и цвета текста по умолчанию. Указанные значения будут использоваться во всем документе за исключением тега `font`, в котором можно переопределить параметры оформления текста. Допускается использование тега в контейнере `head` или `body`, причем несколько раз. Это позволяет изменять вид шрифта для части документа.

Подробней:

- http://htmlbook.ru/html/basefont

---

---

# Часть 2

## Вопросы по CSS

## ![logo css](img/css-bliz-50.jpg)

## 1. Расскажите о блочной модели CSS

Блочная модель CSS – это прямоугольное пространство вокруг элемента HTML, в котором определяются границы, поля и отступы.

Границы – определяют максимальную область, в которой будет содержаться элемент. Мы можем сделать границу видимой, невидимой, определить высоту и ширину элемента и т.п. Поля – определяют расстояния между границами и элементом.

Отступы – определяют расстояния между границами и соседними элементами.

---

## 2. Что такое `reset` CSS и для чего он нужен?

Каждый браузер устанавливает свои значения стилей по умолчанию для различных HTML-элементов. С помощью CSS Reset мы можем нивелировать эту разницу для обеспечения кроссбраузерности стилей.

Например, вы используете элемент a в вашем документе. Большинство браузеров, как Internet Explorer и Firefox, добавляют ссылке синий цвет и подчёркивание. Однако представьте, что через пять лет кто-то решил создать новый браузер (назовём его UltraBrowser). Разработчикам браузера не нравился синий цвет и раздражало подчёркивание, поэтому они решили выделять ссылки красным цветом и полужирным шрифтом. Именно исходя из этого, если вы установите базовое значение стилей для элемента a, то он гарантированно будет таким, каким вы хотите его видеть, а не как предпочитают его отображать разработчики UltraBrowser.

Подробней:

- https://habrahabr.ru/post/45296/

---

## 3. Что такое `normalize CSS` и для чего он нужен?

`Normalize.css` является альтернативой `CSS Reset`. Проект является продуктом сотен часов глубокого исследования различий между изначальными стилями браузера. Это исследование провели Николас Галахер и Джонатан Нил.

**Цели normalize.css**:

- сохранять полезные настройки браузера, а не стирать их;
- нормализовать стили для широкого круга HTML-элементов;
- корректировать ошибки и основные несоответствия браузера;
- совершенствовать юзабилити незаметными улучшениями;
- объяснять код, используя комментарии и детальную документацию.
  Он поддерживает широкий диапазон браузеров (в том числе мобильных) и включает в себя CSS, который нормализует HTML5-элементы, типографику, списки, встраиваемый контент, формы и таблицы.

Несмотря на то, что проект основан на принципе нормализации, он использует стандартные настройки там, где они предпочтительны.

Подробней:

- https://htmlacademy.ru/blog/64-about-normalize-css
- https://habrahabr.ru/company/htmlacademy/blog/342052/

---

## 4. Чем отличается `reset.css` от `normalize.css`?

`Reset.css` накладывает однородный визуальный стиль, выравнивая стили по умолчанию почти для всех элементов. В отличие от этого, `normalize.css` сохраняет многие полезные стили браузеров по умолчанию. Это значит, что не требуется повторно объявлять стили для всех стандартных элементов типографики.

Когда элемент имеет различные стили по умолчанию в разных браузерах, `normalize.css` там, где это возможно, стремится сделать эти стили совместимыми и соответствующими современными стандартам.

Подробней:

- https://htmlacademy.ru/blog/64-about-normalize-css

---

## 5. Объясните, что такое плавающие элементы (`floats`) и как они работают?

- `Float` определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Плавающие (обтекающие) элементы сначала выстраиваются в нормальном потоке, затем образуется новый поток, и они сдвигаются либо вправо, либо влево (в зависимости от выбранного значения) в родительском контейнере. Иными словами, они идут по порядку друг за другом. Учитывая, что в родительском контейнере есть достаточно свободного места, эти плавающие элементы не подстраиваются и не выравниваются для распределения пространства между этими самыми элементами.
- Как правило, плавающий элемент обязательно должен иметь фиксированную ширину. Это гарантирует, что `float` ведет себя так как и ожидалось, избегая проблем в некоторых браузерах.
- Используя свойство `clear`, вы можете указать пять значений: `left`, `right`, `both`, `inherit`, и `none`. Это свойство определяет, по какой стороне будет выравниваться элемент, при этом остальные элементы будут обтекать его с других сторон. Например, если вы укажите «`left»`, элемент задействует отмену обтекания с левого края плавающего элемента. При этом все другие элементы на этой стороне будут опущены вниз, и располагаться под текущим элементом.
- Правило, которое я обнаружил для себя, прекрасно работает для моих float-макетов.В своем HTML коде, я почти всегда сначала создаю плавающие элементы во время разметки, прежде чем добавлять простые элементы, которые могут взаимодействовать с ними. Вы экономите большую часть времени, и это дает желаемый результат.
- Но и тут бывают проблемы, когда вы помещаете в родительский блок плавающие элементы, родительский контейнер не может определить динамически высоту своих дочерних элементов, поэтому родительский контейнер будет иметь высоту равную нулю. Это может поломать вашу верстку. Существует метод, который позволяет родительскому элементу, определить свое пространство с учетом каких-либо плавающих элементов внутри. Можно использовать CSS свойство `overflow` (переполнение) со значением `hidden` (скрыть). Обратите внимание, что значение свойства `overflow` не предназначено для такого рода использования, и может вызывать некоторые проблемы, такие как скрытие нужного контента в данный момент или появление нежелательных полос прокрутки.
- Хак: для очистки плавающих элементов лучше применять ‘`overflow:auto`’ к родительскому элементу.
- Обратите внимание, что данный трюк не очищает плавающие элементы — он просто растягивает родительский контейнер. Вы можете принудительно очистить `float`, если вы добавите очищающий элемент после последнего плавающего элемента, или вы можете добавить в любом нужном вам месте, создав тем самым новый поток. Родительский элемент не умеет очищать дочерние плавающие элементы.
  **9 правил**:

1. Плавающие элементы прижимаются к границам своих контейнеров, но не дальше.
2. Любой плавающий элемент будет находится либо рядом, либо ниже предыдущего элемента. Если элементы прижаты влево, второй элемент появится точно справа от первого. Если они прижаты вправо, второй элемент появится слева от первого (`reverse`).
3. Элемент с левым обтеканием, не может быть правее, чем элемент с правым обтеканием.
4. Плавающие элементы не могут подняться выше верхнего края родительского контейнера (однако становится еще сложнее, когда задействованы отступы).
5. Плавающий элемент не может быть выше своего соседа плавающего элемента.
6. Плавающий элемент не может быть выше своего соседа строчного элемента.
7. Плавающий элемент совместно со своим таким же соседом элементом, не могут выходить за края родительского контейнера.
8. Плавающий элемент должен быть помещен как можно выше.
9. Элемент с левым обтеканием должен быть помещен как можно дальше влево, как это возможно, элемент с правым обтеканием должен быть помещен как можно дальше вправо, как это возможно.

Подробней:

- https://habrahabr.ru/post/273471/

---

## 6. Какие вы знаете методы запрета обтекания (`clearing`) и какие где применяются?

Хак: для очистки плавающих элементов лучше применять ‘`overflow:auto`’ к родительскому элементу.

```css
.clearfix:after {
  content: "";
  display: table;
  clear: both;
}
```

---

## 7. Что такое CSS спрайты? Как они реализуются на странице или сайте?

CSS спрайт — это техника оптимизации производительности, которая сочетает в себе несколько изображений в одном изображении, называемом спрайт-лист (`sprite sheet`) или набор плиток (`tile set`). Спрайты уменьшают нагрузку на сеть за счет сокращения количества загрузок с сервера, необходимых для отображения веб-страницы.

Подробней:

- https://habrahabr.ru/post/159027/

---

## 8. Как Вы обеспечиваете отображение страниц в старых/ограниченных браузерах?

- Полифилы, кроссбраузерные решения
- Проверка нужной версии на спец. сервисах
- Скачивание старые версий браузеров(хард метод)

Подробнее:

- https://caniuse.com/ (софт метод)
  Предупреждение о устаревшем браузере

---

## 9. Какими способами можно визуально скрыть элемент (оставив его доступным для экранного диктора, `screen reader`)?

```css
position: relative;
left: -5000px;
```

---

## 10. Вы когда-нибудь использовали сеточную верстку (`grid system`, `grid design`)? Если да, какая Ваша любимая?

- grid design: https://habrahabr.ru/post/23792/

- grid system: http://htmlbook.ru/blog/css-grid-i-flexbox-sravnenie-na-praktike

---

## 11. Что такое `flexbox`?

Направлена на предоставление более эффективного способа выравнивания и распределения места между элементами в контейнере (родительском блоке), даже если их размер неизвестен или динамический.

Основная идея _flex-блоков_, обладать способностью изменять свою ширина/высота (и другое), чтобы наилучшим образом заполнять свободное место (в основном, для поддержки адаптивности на всех видах устройств и размеров экрана).

В основном элементы будут распределяться либо вдоль главной оси, либо вдоль поперечной оси контейнера.

_Flex-блоки_ лучше всего подходят для составных частей приложения и мелкомасштабных компонентов на странице, в то время как _grid-блоки_ больше используется для компонентов на странице большого масштаба.

Также как существует `inline-block`, `inline-table`, существует и `inline-flex`.

Подробней:

- https://habrahabr.ru/post/273471/#display

---

## 12. Как задать `flexbox`?

Для начала нам нужно выбрать, какие элементы следует выкладывать в виде flex блоков. Для этого мы устанавливаем специальное значение `display` в родительском элементе тех элементов, которые вы хотите оформить. `display: flex;`

**Примечание**: Вы также можете установить значение `display inline-flex`, если хотите расставить `inline` элементы как flex блоки.

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 13. Какие оси есть в `flexbox`?

Главная ось (`main axis`) проходит в том направлении, вдоль которого расположены Flex элемнеты (например, в строку слева направо или вдоль колонок вниз.) Начало и конец этой оси называются `main start` и `main end`.

Поперечная ось (`сross axis`) проходит перпендикулярно Flex элементам. Начало и конец этой оси называются `cross start` and `cross end`.

Родительский элемент, на который назначено свойство `display: flex` называется **flex container**.

Элементы, размещённые в нём как Flex блоки называются **flex items**

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 14. Какое свойство `flexbox` отвечает за направление `flex items`?

В Flexbox есть свойство под названием `flex-direction`, которое определяет направление главной оси (в каком направлении располагаются flexbox дети) — по умолчанию ему присваивается значение `row`, т.е. располагать дочерние элементы в ряд слева направо (для большинства языков) или справа налево (для арабских языков).

- `row` | `row-reverse` | `column` | `column-reverse`
- **row** Главная ось - `main-axis` гибкого контейнера определяется как направление текста. Точки `main-start` и `main-end` совпадают с направлением содержимого.
- **row-reverse** Ведет себя так же, как `row`, но главные и конечные точки переставляются.
- **column** Главная ось flex containera такая же, как ось блока. Точки `main-start` и `main-end` совпадают с точками до и после writing-mode.
- **column-reverse** Ведет себя так же, как `column`, но `main-start` и `main-end` переставляются.

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 15. Какое правило `flexbox` задает вывод `flex items` в одну строку или в несколько строк?

Свойство CSS `flex-wrap`

`nowrap` | `wrap` | `wrap-reverse`

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 16. `flex-flow` сокращение, расскажите?

На этом этапе нужно заметить, что сществует сокращение для свойств `flex-direction` и `flex-wrap` — `flex-flow`.

Например, вы можете заменить

`flex-direction: row;`

`flex-wrap: wrap;`

`flex-flow: row wrap;`

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 17. Как можно гибко изменять размеры `flex` элементов?

```css
article {
  flex: 1 200px;
}

article:nth-of-type(3) {
  flex: 2 200px;
}
```

Это просто означает, что каждому `flex` элементу сначала будет дано `200px` от свободного места. Потом оставшееся место будет поделено в соответствии с частями пропорций.

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 18. сокращённое свойство `flex`

`flex` это сокращённое свойство, в которым можно задать до трёх разных свойств:

- Значение пропорции. Оно может быть установлено отдельно с помощью свойства `flex-grow`.
- Следующее значение пропорции — `flex-shrink` — вступает в роль, когда flex элементы переполняют контейнер. Оно указывает, сколько забирается от размера каждого flex элемента, чтобы он перестал переполнять контейнер. Это продвинутая функция flexbox.
- Значение минимального размера, как мы обсуждали ранее. Оно может быть установлено отдельно с помощью свойства `flex-basis`.

Подробней:

- https://developer.mozilla.org/ru/docs/Learn/CSS/CSS_layout/Flexbox

---

## 19. Расскажите про `flex-grow`, `flex-shrink`, `flex-basis`?

Свойство CSS `flex-grow` определяет, какую часть свободного пространства может занять контейнер, в соотношении с другими контейнерами.

`flex-shrink` — свойство CSS, которое определяет фактор сжатия flex-элемента. Flex-элементы будут заполнять контейнер в зависимости от значения `flex-shrink`, когда стандартная ширина flex-элементов шире, чем flex-контейнер.

`flex-basis` CSS свойство задает базовые размеры флекс элемента, а именно ширину. Это свойство определяет размер содержимого контента, если оно не было заданно свойством `box-sizing`.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/CSS/flex-shrink
- https://developer.mozilla.org/ru/docs/Web/CSS/flex-grow
- https://developer.mozilla.org/ru/docs/Web/CSS/flex-basis

---

## 20. Что такое css grid?

Значение `grid` позволяет нам создавать макет сетки. Она направлена на решении проблем со старыми методами компоновки блоков, имеющих `float` и `inline-block`, которые в свою очередь имеют недостатки, и действительно не предназначались для макета страницы.

Основная идея `grid`-концепции, управлять содержимым, обеспечивая механизм распределения имеющегося пространство блоков в столбцы и строки, с помощью набора заранее установленных размеров.

Вместе с этим фактом мы можем устранить проблемы, которые появляются при разработке, опираясь на старую технику разработки сайтов, теперь вы тратите меньше усилий.
Не поддерживается. Только в IE10+.

Также как существует `inline-block`, `inline-table`, `inline-flex`, существует и `inline-grid`

Подробней:

- https://habrahabr.ru/post/273471/#display
- https://habrahabr.ru/post/325760/
- https://developer.mozilla.org/ru/docs/Web/CSS/CSS_Grid_Layout

---

## 21. Можно ли использовать `css grid` и `flexbox` вместе?

`Flexbox` и `Grid` это не два противоборствующих свойства, они наоборот дополняют друг друга.

`Grid` - инструмент позиционирования основных блоков страницы.

`Flexbox` - инструмент позиционирования элементов внутри блоков, спозиционированных с помощью `Grid`.

---

## 22. Как оптимизировать страницы для печати?

Оптимизация с помощью CSS:

1. Встраиваем стили для печати
   Лучший способ встроить стили для печати — описать директиву `@media` в своем CSS.

```css
body {
  font-size: 18px;
}
@media print {
  /* print styles go here */
  body {
    font-size: 28px;
  }
}
```

Также вы можете встроить стили для печати в HTML, но для этого потребуется дополнительный запрос.

```html
<link media="print" href="print.css" />
```

2. Тестирование
   Не нужно печатать страницу каждый раз, когда вы вносите небольшое изменение. В зависимости от браузера можно экспортировать страницу как файл PDF, сделать предпросмотр страницы или даже вносить корректировки в самом браузере.

Чтобы откорректировать стили для печати в Firefox, откройте Панель разработчика (`Shift` + `F2` или `Разработка` → `Веб-разработка` → `Панель разработчика`), введите `media emulate print` в строчке ввода внизу окна браузера и нажмите `Enter`. Активная вкладка будет вести себя, как если бы тип медиа был `print` до тех пор, пока вы не закроете или не обновите страницу.

В браузере Chrome откройте Инструменты разработчика (`CMD` + `Opt` + `I` (для macOS) или `Ctrl` + `Shift` + `I` (для Windows) или `View` → `Developer` → `Developer Tools`), отразите `Console drawer` (`Esc`), откройте панель `Rendering`, поставьте галочку в пункте `Emulate CSS Media` и выберите `Print`.

3. Абсолютные единицы
   Абсолютные единицы не годятся для экранов, но хорошо работают для печати. В стилях для печати совершенно безопасно и даже рекомендуется использование таких абсолютных единиц как `cm`, `mm`, `in`, `pt` или `pc`.

```css
section {
  margin-bottom: 2cm;
}
```

4. Отдельные правила для страницы
   Можно также определить параметры, действующие на этой странице: размеры, ориентация и поля, — с помощью директивы `@page`. Это очень удобно, если вы хотите, чтобы у всех страниц были определенные поля.

```css
@media print {
  @page {
    margin: 1cm;
  }
}
```

Директива `@page` — это часть модуля `Paged Media`, в которой есть много всего нужного, например, можно выбрать первую страницу печати или пустые страницы, позиционировать элементы в углах страницы и другое. Вы можете даже пользоваться ей для создания книг.

5. Управление разрывами страниц
   Так как печатные страницы, в отличие от интернет-страниц, не могут быть бесконечными, в конце концов, контент прервется на одной странице и продолжится на следующей. В таком случае, есть пять свойств, которые нужно проконтролировать.

**Разрыв страницы перед элементом**
Чтобы элемент всегда был в начале страницы, можно принудительно разрывать страницу с помощью правила `page-break-before`.

```css
section {
  page-break-before: always;
}
```

page-break-before на портале Mozilla Developer Network

- https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-before

**Разрыв страницы после элемента**
С помощью правила `page-break-after` можно принудительно разорвать или, наоборот, избежать разрыва страницы после элемента.

```css
h2 {
  page-break-after: always;
}
```

Правило `page-break-after` на портале Mozilla Developer Network.

- https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-after

**Разрыв страницы внутри элемента**
Это правило поможет избежать разделения элемента на две страницы.

```css
ul { page-break-inside: avoid;}​
```

Правило `page-break-inside` на портале Mozilla Developer Network.

- https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-inside

**Вдовы и сироты**
Иногда не нужно принудительно разрывать страницу, но нужно проконтролировать, сколько строчек отражается на текущей или следующей странице. Например, если последняя строчка целого параграфа не помещается на текущей странице, то на следующей странице напечатаются две последние строчки из параграфа, даже несмотря на то, что не вошла только одна строчка. Так происходит потому, что свойство, ответственное за подобные ситуации, — `widows` — по умолчанию настроено на два. Это можно поменять.

```css
p {
  widows: 4;
}
```

Если ситуация противоположна, и из всего параграфа только первая строка помещается на странице, остальная часть параграфа будет напечатана на следующей странице. Свойство, ответственное за это поведение, — orphans, и его значение по умолчанию также равняется двум.

```css
p {
  orphans: 3;
}
```

Код выше показывает, что по крайней мере три строчки должны поместиться на текущей странице, иначе весь параграф будет перенесен на следующую страницу. На [CodePen](https://codepen.io/matuzo/pen/oYvBjN) есть несколько примеров. А [здесь](https://cdpn.io/matuzo/debug/oYvBjN) — отладочная версия, чтобы было легче протестировать. Не все свойства и значения работают во всех браузерах одинаково, стили для печати надо проверять в каждом браузере.

6. Сброс стилей
   Стоит сбросить некоторые стили для печати, например `background-color`, `box-shadow` или `color`.

Вот фрагмент стандартной заготовки стилей для печати для HTML5:

- https://github.com/h5bp/html5-boilerplate/blob/master/dist/css/main.css

```css
*,
*:before,
*:after,
*:first-letter,
p:first-line,
div:first-line,
blockquote:first-line,
li:first-line {
  background: transparent !important;
  color: #000 !important;
  box-shadow: none !important;
  text-shadow: none !important;
}
```

Стили для печати являются исключением из правил, в них можно использовать ключевое слово `!important`.

7. Удаление ненужного контента
   Чтобы чернила не тратились зря, лучше удалить ненужный материал, например, presentational content, рекламу, навигацию и прочие с помощью свойства `display: none`.

Возможно, будет лучше вообще показать только основной контент, а все остальное спрятать.

```css
body > *:not(main) {
  display: none;
}
```

8. Отражение URL в ссылках
   Печать ссылок совершенно бесполезна, если не известно, куда они ведут.

Можно легко сделать так, чтобы цель ссылки отражалась рядом с ее текстом.

```css
a[href]:after {
  content: " (" attr(href) ")";
}
```

Предыдущая команда отразит и относительные, и абсолютные ссылки на ваш сайт, якоря и многое другое. А вот эта команда может быть лучше:

```css
a[href^="http"]:not([href*="mywebsite.com"]):after {
  content: " (" attr(href) ")";
}
```

Выглядит безумно, я знаю. Эти строчки означают следующее: отразить значение атрибута `hrefattribute`рядом с каждой ссылкой, у которой есть атрибут `href`, который начинается с `http`, но в значении которого не стоит `mywebsite.com`.

9. Отражение расшифровок абревиатур
   Аббревиатура должна заключаться в элементы `<abbr>`, а её расшифровка включается в атрибут `title`. Вполне логично выводить их на печать.

```css
abbr[title]:after {
  content: " (" attr(title) ")";
}
```

10. Принудительная печать фона
    По умолчанию браузеры не печатают цвет фона и фоновые изображения, но иногда их можно пустить на печать принудительно. Нестандартизированное свойство `print-color-adjust` позволит переписать настройки по умолчанию в некоторых браузерах.

```css
header {
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
```

11. Мультимедийный запрос
    Если вы пишете свои мультимедийные запросы как в приведенном ниже примере, следует помнить, что правила CSS в этом запросе не будут применяться к стилям для печати

```css
@media screen and (min-width: 48em) {
  /* screen only */
}
```

Почему? Потому что правила CSS применяются только в случае, если параметр `min-width` равняется `48em`, а тип медиа — `screen`. Если избавиться от ключевого слова `screen`, то мультимедийный запрос будет ограничиваться только параметром `min-width`.

```css
@media (min-width: 48em) {
  /* all media types */
}
```

12. Печать карт
    Текущие версии Firefox и Chrome могут печатать карты, но, например, Safari — не может. В таком случае можно воспользоваться статическими картами, которые предоставляются некоторыми сервисами.

```css
.map {
  width: 400px;
  height: 300px;
  background-image: url("http://maps.googleapis.com/maps/api/staticmap?center=Wien+Floridsdorf&zoom=13 &scale=false&size=400x300&maptype=roadmap&format =png&visual_refresh=true");
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
}
```

13. QR-коды
    Некоторые советы вы [найдете в статье журнала Smashing Magazine](https://www.smashingmagazine.com/2013/03/tips-and-tricks-for-print-style-sheets/#print-qr-codes-for-easy-url-references). Один из них заключается в том, что в страницах для печати лучше размещать QR-коды, чтобы пользователю не пришлось печатать URL полностью для перехода на актуальную страницу сайта.

Бонус: печать неоптимизированных страниц
Проводя исследование, я обнаружил инструмент, который поможет печатать неоптимизированные страницы. С помощью инструмента Printliminator [можно](https://css-tricks.github.io/The-Printliminator/) удалять элементы просто кликнув на них. Можно [посмотреть демо на Youtube](https://www.youtube.com/watch?v=Dt8hpqEIL1c) и прочитать о [проекте на Github](https://github.com/CSS-Tricks/The-Printliminator).

Второй бонус: [Gutenberg](https://github.com/BafS/Gutenberg)
Если вы ищете фреймворк, присмотритесь к инструменту Gutenberg. С ним оптимизация страниц для печати становится немного легче.

Третий бонус: Hartija
Есть еще один фреймворк, который называется [Hartija](https://github.com/vladocar/Hartija---CSS-Print-Framework). 

Подробнее:

- https://habrahabr.ru/company/ruvds/blog/317776/
- https://habrahabr.ru/post/160997/

---

## 23.Какие есть подводные камни в оптимизации производительности CSS?

- **Переотрисовка (repaint)**:
  Также известное, как redraw — это событие, которое происходит всякий раз, когда что-то делается видимым на странице, если ранее оно было скрыто (`visibility:hidden`, `overflow:hidden`, `display:none`, и др), или наоборот (`visibility:visible`, `overflow:auto`, `display:static`, и др), когда происходят какие-то изменения в макете. Примером может быть что угодно: добавление к элементу рамки, изменение цвета фона, изменение видимости стилей — все это приводит к переотрисовке страницы. Тем самым данное событие может дорого вам обойтись в плане производительности, так как нагружает браузерный движок поиском, проходами по всем элементам, чтобы определить, что является видимым уже, а что должно отобразиться.

- **Перерасчет (reflow)**:
  Перерасчет (или перекомпоновка) носит более значительный характер. Это событие будет происходить всякий раз, когда происходят манипуляции с DOM-деревом HTML документа, или когда стиль, который влияет на расположение, изменяется у элемента, это событие будет происходит всякий раз, когда атрибут class у элемента изменяется, или всякий раз, когда изменяется размер окна браузера. Цель перерасчета в том, чтобы определить, где различные части сайты теперь должны отображаться. Если вы измените родительские свойства, тогда его потомки также будут пересчитаны. Элементы, которые появляются после того, как DOM было сформировано, будут сформированы заново. Если изменяется дочерний элемент, тогда будет пересчитан и родительский элемент, чтобы учесть изменения своих потомков. Затем, происходит переотрисовка.

  Перерасчет также очень дорого обходится в плане производительности, и является одной из главных причин медленной работы скриптов, особенно на устройствах с низкой вычислительной мощности, таких как телефоны

- **Минимальный перерасчет (minimal reflow)**:
  Долгий перерасчет может повлиять на весь документ, всю веб-страницу. Чем больше документ, тем дольше перерасчет. Меньше HTML-кода лучше производительность. Элементы с абсолютным позиционирование или фиксированным, не влияют на структуру главного документа, так как они находятся в отдельном потоке, если в них произошли изменения, только они будут подвержены перерасчету. Конечно, документ, в котором произойдут изменения, все равно будут полностью переотрисованы, но эта проблема имеет слабый характер, чем перерасчет всего DOM-дерева.

  Так что анимация не должны быть применена ко всему документу, было бы лучшим, если бы анимации применялись только для позиционированных элементов. Для большинства случаев, это очень важно.

- **Что вызывает перерасчет**:

  - Изменение размера окна
  - Изменение шрифта
  - Добавлении или удалении стилей
  - Динамическое изменение, пользователь вводит текст в поле ввода
  - Активация CSS псевдо-классов, к примеру, событие `:hover`
  - Манипулирования с атрибутом `class`
  - Сценарии манипулирования с DOM-деревом
  - Расчет значений `offsetWidth` и `offsetHeight`
  - Задание свойств в атрибут `style`

- **Как свести к минимуму влияние перерасчета на производительность**:
  Изменение атрибутов класса у элементов, делайте как можно реже (минимум манипуляций в DOM-дереве).
  Избегайте установки нескольких встроенных стилей.
  Применяйте анимацию к элементам, которые имеют фиксированное или абсолютное позиционирование.
  Избегайте табличной разметки. Даже незначительные изменения в ячейке таблицы вызовут перерасчет на всех остальных узлах таблицы.
  Не используйте «CSS expressions» (также известное, как «IE expressions»)

- **Примечание**:
  Потеть над селекторами, используемых в современных браузерах, бесполезно. Большинство методов выборки сейчас настолько быстрые и эффективные, что на это действительно не стоит тратить много времени. Кроме того, есть различия в различных браузерах, и у каждого есть свои медленные селекторы.

  Чрезмерные неиспользуемые стили, скорее всего, они будут бить по производительность, чем любые селекторы, которые вы добавили в свой документ. Следует прибираться в своих css-стилях. 3000 строк неиспользуемых или избыточных на странице стилей, в наше время, это не редкость. Если разные стили используются на разных страницах вашего сайта, разбейте ваш один и единственный styles.css на несколько дополнительных, это будет лучшим вариантом.

Подробней: https://habrahabr.ru/post/273471/#repaints_and_reflows

---

## 24. Объясните, как браузер определяет, на какие элементы накладывать CSS стили?

CSSOM (объектная модель CSS) — это объект, представляющий стили, связанные с DOM. Он выглядит так же как DOM, но с соответствующими стилями для каждого узла. Не имеет значения были ли стили объявлены явно или наследуются.

Подробней: https://habrahabr.ru/post/320430/

---

## 25. Слышали ли о системе БЭМ (Блок-Элемент-Модификатор)?

https://ru.bem.info/methodology/quick-start/
https://habrahabr.ru/post/162385/
https://habrahabr.ru/post/203440/
https://medium.com/@dedguran/введение-в-методологию-бэм-e6b156e1f795

---

## 26. Какие еще методологии верстки вы знаете?

https://habrahabr.ru/post/256109/
https://operatino.github.io/MCSS/

---

---

# Часто задаваемые вопросы на интервью по JavaScript | Часть 1

<!-- ![logo for common questions](img/JS-common-bliz-50.jpg) -->
<p align="center">
<img src="img/JS-common-bliz-50.jpg" alt="logo-JS-common-blitz-poll">
</p>

## 1. Что такое JavaScript (JS)?

- JavaScript - это легкий интерпретируемый язык программирования с объектно-ориентированными возможностями, который позволяет встроить интерактивность в статические HTML-страницы.

---

## 2. Каковы основные особенности JavaScript?

- JavaScript - это легкий интерпретируемый язык программирования.
- JavaScript предназначен для создания сетевых приложений.
- JavaScript дополняет и интегрируется с Java.
- JavaScript дополняет и интегрируется с HTML.
- JavaScript открыт и кроссплатформенен.

---

## 3. Каковы преимущества JavaScript?

- Меньше взаимодействия с сервером. Вы можете проверить ввод пользователя перед отправкой страницы на сервер.
- Немедленная обратная связь с посетителями. Им не нужно ждать перезагрузки страницы, чтобы узнать, забыли ли они что-то ввести.
- Повышенная интерактивность. Вы можете создавать интерфейсы, которые реагируют, когда пользователь наводит на них курсор мыши или активирует их с помощью клавиатуры.

---

## 4. Почему javascript называется `Richer Interface` - (более богатый интерфейс)?

- Вы можете использовать JavaScript, чтобы включать такие элементы, как компоненты перетаскивания и ползунки, чтобы предоставить богатый интерфейс посетителям вашего сайта.

---

## 5. Является ли JavaScript чувствительным к регистру?

- Да, JavaScript - это **регистрозависимый язык**. Это означает, что ключевые слова языка, переменные, имена функций и любые другие идентификаторы всегда должны вводиться с одинаковой заглавной буквой.

---

## 6. Как мы можем создать объект в JS?

Например так:

```js
let object = {
  name: "obj",
  age: 10,
};
```

пустой объект можно создать:

1. синтаксис "конструктор объекта"

```js
let object = new Object();
```

2. синтаксис "литерал объекта"

```js
let obj = {};
```

---

## 7. Как мы можем прочитать свойства объекта в js?

- Можем записать и прочитать свойства объекта, используя точку (`.`).
- Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает. Для этого нужно использовать квадратные скобки `[name prop]`

```js
obj["big user"] = true;
```

или так:

```js
let key = "big user";
obj[key] = true;
```

Квадратные скобки в литеральной нотации можно использовать для создания _ввычисляемого свойства_.

```js
let car = prompt("Which car to buy?", "BMW");

let purchases = {
  [car]: 1, // имя свойства будет взято из переменной car
};

alert(purchases.BMW); // 1, если car="BMW"
```

Это точно тоже, как записать так:

```js
let car = prompt("Which car to buy?", "BMW");
let purchases = {};

// имя свойства будет взято из переменной car
purchases[car] = 1;
```

Первая фотрма записи более лаконична, понятна и предпочтительна!

---

## 8. Как создать массив в js и как читать элементы массива?

Мы можем определить пустые массивы с помощью литерала массива и конструктор следующим образом.

- `let x = [];`
- `let y = new Array;`

Можно объявить массив и так:

```js
let array = [1, "car", true, 55, NaN, { name: "Yaroslav" }];
```

Элемент массива можно получить указав в квадратных скобках его номер в массиве.

```js
console.log(array[1]); // car
```

Отсчет начинается с ноля!

Массив имеет свойство длины, которое полезно для итерации. Мы можем прочитать элементы массива следующим образом.

Самый старый цикл `for`

```js
for (var i = 0; i < x.length; i++)
```

Другой вариант цикла - `for..of`
Без доступа к ключам, но это бывает не так и важно.

```js
let cars = ["Mersedes", "Jaguar", "BMW", "Volvo"];
for (let car of cars) {
  console.log(car);
}
```

Так как массив является объектом, то можно и циклом `for..in`
Самый плохой подход использовать этот метод. Он затратный, медленный и переберет все что похоже на массив (псевдомасивы браузера и пр.)

```js
let cars = ["Mersedes", "Jaguar", "BMW", "Volvo"];
for (let key in cars) {
  console.log(cars[key]);
}
```

## 9. Сколько типов функций поддерживает JS?

- Функция в JavaScript может быть как именованной, так и анонимной. Может быть создана конструктором только в глобальной области видимости. Каждая функция JavaScript на самом деле является объектом функции.

```js
const sum = new Function("a", "b", "return a + b");
```

---

## 10. Как определить анонимную функцию?

- Анонимная функция может быть определена так же, как и обычная функция, но у нее не будет никакого имени.

---

## 11. Какой встроенный метод вызывает функцию для каждого элемента в массиве?

- Метод `forEach` вызывает функцию для каждого элемента в массиве.

```js
const array1 = ["a", "b", "c"];

array1.forEach((element) => console.log(element));
```

---

## 12. Какой тип переменной объявленной глобально или локально имеет приоритет над другими, если их имена совпадают?

- Локальная переменная имеет приоритет над глобальной переменной с тем же именем.

---

## 13. Разница между «`var`» и «`let`» ключевыми словами?

- `var` был в JS с самого начала, а `let` был представлен в ES2015 / ES6. `let` имеет область действия блока ограниченного скобками `{}`, а `var` имеет область действия функции.

---

## 14. Разница между «`==`» и «`===`»?

- «`==`» сравнивает только значения «`===`» сравнивает и значения, и типы.

---

## 15. Разница между «`undefined`» и «`null`» ключевыми словами?

- Когда вы определяете переменную, но не присваиваете ей никакого значения. `typeof (undefine) => undefine`
- Null- изночально присвоенное пустое значение переменной. `typeof(null)=> object`

---

## 16. Что такое прототипное наследование?

- Каждый объект имеет свойство, называемое прототипом, в которое мы можем добавлять методы, и когда вы создаете другой объект из него, то вновь созданный объект автоматически наследует свойство своего родителя.

---

## 17. Какой встроенный метод сортирует элементы массива?

- Метод сортировки - `sort()` сортирует элементы массива.

---

## 18. Какой встроенный метод меняет порядок элементов массива?

- Меняет порядок элементов массива - `reverse()` метод. Первый элемент становится последним, а последний становится первым элементом массива.

---

## 19. Что такое `SetTimeout()`?

- Когда вы устанавливаете время задержки выполнения функции, то она становится асинхронной, и ей приходится ждать в стеке, чтобы завершить выполнение.

---

## 20. Как добавить один новый элемент в конце массива в JavaScript?

- Метод `push()` добавляет один или несколько элементов в конец массива и возвращает новую длину массива.

---

## 21. Что такое замыкание и как вы его используете?

- Когда функция возвращает другую функцию, возвращающая функция сохраняет свою среду, и это называется замыканием.

Самый простой пример - счетчик:

```js
function makeCounter() {
  let count = 0;
  return function () {
    return count++;
  };
}

let counter1 = makeCounter();
let counter2 = makeCounter();

alert(counter1()); // 0
alert(counter1()); // 1
```

Внутренняя функция изменяет переменную во внешней функции, доступ к которой извне получить нельзя (сбросить счетчик извне).

---

## 22. Что выведит на страницу приведенный ниже код?

```html
<script>
  document.write({});
</script>
```

- `[object Object]`

---

## 23. Как вы можете перевести элемент в нижнем регистре в верхний регистр?

- Метод `toUpperCase()` возвращает значение вызывающей строки, преобразованное в верхний регистр.

---

## 24. Почему вызов `а()` проходит успешно, а вызов `b()` выдает ошибку?

```javascript
a(); //OK
b(); //error

var b = function () {
  alert("function b");
};

function a() {
  alert("function a");
}
```

- Функция `а()` инициализируется на этапе загрузки скрипта, она как бы "вслывает вверх" - **bubbling**, а функция `b()` инициализируется когда объявляется переменная `b`

---

## 25. Вывести алертом сообщение через три секунды после загрузки скрипта

- Два варианта:

```javascript
//---<<< 1 >>>
setTimeout(alert("Message", 3000));
// ---<<< 2 >>>
setTimeout(function () {
  alert("Message");
}, 3000);
```

---

---

# Часто задаваемые вопросы на интервью по JavaScript | Часть 2

## 26. Каковы все циклические структуры в JavaScript?

- Цикл `while`: Цикл `while` - это оператор потока управления, который позволяет повторно выполнять код в зависимости от заданного логического условия. Цикл `while` можно рассматривать как повторяющийся оператор `if`.

- цикл `for`: цикл `for` обеспечивает краткий способ записи структуры цикла. В отличие от цикла `while`, оператор `for` предоставляет инициализацию, условие и приращение / уменьшение в одной строке, обеспечивая тем самым более короткую и простую в отладке структуру цикла.

- `do while`: цикл `do-while` похож на цикл `while` с той лишь разницей, что он проверяет условие **после** выполнения операторов и, следовательно, является примером цикла управления выходом - Exit Control Loop.

- Метка (`label`) : Метка представляет собой оператор с индентификатором, который позволяет вам ссылаться на какое-то место в вашей программе. Например, вы можете использовать метку, чтобы обозначить цикл, а затем использовать операторы `break` или `continue`, чтобы указать, должна ли программа прерывать цикл или продолжать его выполнение.

  Инструкция метки (`label`) используется вместе с `break` или `continue` для альтернативного выхода из цикла. Оно добавляется перед блочным выражением в качестве ссылки, которая может быть использована в дальнейшем.

  Синтаксис метки следующий:

```js
let str = "";

loop1: for (let i = 0; i < 5; i++) {
  if (i === 1) {
    continue loop1;
  }
  str = str + i;
}

console.log(str);
// expected output: "0234"
```

- `break` : Используйте оператор `break`, чтобы прерывать цикл, переключать управление или в сочетании с оператором метка.

  Когда вы используете `break` без метки, он прерывает циклы `while`, `do-while` и `for` или сразу переключает управление к следующему выражению.
  Когда вы используете `break` с меткой, он прерывает специально отмеченное выражение.
  Синтаксис оператора может быть таким:

1. break;

Пример:

```js
for (i = 0; i < a.length; i++) {
  if (a[i] == theValue) {
    break;
  }
}
```

2. break Метка;
   Пример:

```js
var x = 0;
var z = 0;
labelCancelLoops: while (true) {
  console.log("Внешний цикл: " + x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Внутренний цикл: " + z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

- `continue` Оператор `continue` используется, чтобы шагнуть на шаг вперёд в циклах `while`, `do-while`, `for` или перейти к метке.

  Когда вы используете `continue` без метки, он прерывает текущую итерацию циклов `while`, `do-while` и `for` и продолжает выполнение цикла со следующей итерации. В отличие от `break`, `continue` не прерывает выполнение цикла полностью. В цикле `while` он прыгает к условию. А в `for` увеличивает шаг.
  Когда вы используете `continue` с меткой, он применяется к циклу с этой меткой.
  Синтаксис `continue` может выглядеть так:

1. continue;

```js
var i = 0;
var n = 0;
while (i < 5) {
  i++;
  if (i == 3) {
    continue;
  }
  n += i;
}
```

2. continue Метка;

```js
checkiandj: while (i < 4) {
  console.log(i);
  i += 1;
  checkj: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 != 0) {
      continue checkj;
    }
    console.log(j + " чётное.");
  }
  console.log("i = " + i);
  console.log("j = " + j);
}
```

- `for...in` .Оператор `for...in` проходит по всем перечислимым свойствам объекта. JavaScript выполнит указанные выражения для каждого отдельного свойства. Цикл `for...in` выглядит так:

Пример:

```js
let arr = ["AUDI A8", "2019", "brown"];
arr.cost = "$100.000";

for (key in arr) {
  console.log(`${key} = ${arr[key]}`);
}

// 0 = AUDI A8
// 1 = 2019
// 2 = brown
// cost = $100.000
```

- `for...of` Оператор `for...of` создаёт цикл, проходящий по перечислимым объектам (включая `Array`, `Map`, `Set`, объект `arguments` и так далее), вызывая на каждой итерации функцию с выражениями, которые надо выполнить для получения значения каждого отдельного свойства.

Пример:

```js
let arr = [3, 5, 7];
arr.foo = "hello";

for (let i in arr) {
  console.log(i); // выводит "0", "1", "2", "foo"
}

for (let i of arr) {
  console.log(i); // выводит "3", "5", "7"
}
```

---

## 27. Как изменить стиль / класс элемента?

Изменить стиль / класс элемента можно двумя способами.

- `document.getElementById("myText").style.fontSize = "16px;`

- `document.getElementById("myText").className = "class";`

---

## 28. Объясните, как читать и писать файл с помощью JavaScript?

- Функции [readFile()](https://ru.code-maven.com/reading-a-file-with-nodejs) используются для операции чтения.

```js
readFile(Path, Options, Callback);
```

Развернутое объяснение:

### Чтение файла с Node.js - блокирующее и неблокирующее

Node предоставляет библиотеку `fs` для работы с файловой системой. К примеру, для чтения файлов.

#### Асинхронное чтение файла (неблокирующее)

"Нормальный" способ чтения файлов в Node.js это чтение асинхронным способом. Это значит, что вы вызываете команду чтения файла и передаете `callback`, который будет вызван при завершении чтения. Это позволяет работать с несколькими запросами чтения параллельно.

Для этого мы можем использовать метод [readFile](https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback) из класса `fs`.

Пример:

```js
var fs = require("fs");

fs.readFile("DATA", "utf8", function (err, contents) {
  console.log(contents);
});

console.log("after calling readFile");
```

Для начала мы загружаем класс `fs` с помощью команды `require`. Затем вызываем метод `readFile`, который получает 3 параметра: имя файла ('DATA' в нашем случае), кодировку файла ('utf8' в примере) и функцию. Эта функция будет вызывана, когда завершится операция чтения файла. Функция получит два параметра. Первый - информация о каких-либо ошибках, второй - содержимое файла.

Как только программа будет запущена, Node начнет читать файл в фоновом режиме, но продолжит выполнение. Таким образом, сначала будет выполнен вызов `console.log('after calling readFile');`, который выведет этот текст в консоль. Затем, когда содержимое файла будет загружено в память, Node вызовет функцию, которую мы передали в метод `readFile`, и она выведет в консоль содержимое файла.

#### Синхронное чтение файла (блокирующее)

Люди, пришедшие из других языков программирования (из большинства), считают синхронное чтение файлов более очевидным. Я не знаю в какой ситуации вы захотите использовать синхронные операции в Node.js, но я вижу, что много асинхронных функций имеют синхронный вариант, наверное, этим кто-то пользуется.

Для чтения файлов вы можете использовать метод [readFileSync](https://nodejs.org/api/fs.html#fs_fs_readfilesync_path_options) из класса `fs`:

```js
var fs = require("fs");

var contents = fs.readFileSync("DATA", "utf8");
console.log(contents);
```

- Функции `writeFile()` используются для операции записи.

```js
writeFile(Path, Data, Callback);
```

Подробно:
Для записи файла в синхронном варианте используется функция `fs.writeFileSync()`, которая в качестве параметра принимает путь к файлу и записываемые данные:

```js
fs.writeFileSync("hello.txt", "Текст для записи в файл");
```

Также для записи файла можно использовать асинхронную функцию `fs.writeFile()`, которая принимает те же параметры:

```js
fs.writeFile("hello.txt", "Текст для записи в файл");
```

В качестве вспомогательного параметра в функцию может передаваться функция обратного вызова, которая выполняется после завершения записи:

```js
const fs = require("fs");

fs.writeFile("hello.txt", "Hello мир!", function (error) {
  if (error) throw error; // если возникла ошибка
  console.log("Асинхронная запись файла завершена. Содержимое файла:");
  let data = fs.readFileSync("hello.txt", "utf8");
  console.log(data); // выводим считанные данные
});
```

Следует отметить, что эти методы полностью перезаписывают файл. Если надо дозаписать файл, то применяются методы `fs.appendFile()/fs.appendFileSync()`:

```js
const fs = require("fs");

fs.appendFileSync("hello.txt", "Текст для записи в файл");

fs.appendFile("hello.txt", "Привет МИР!", function (error) {
  if (error) throw error; // если возникла ошибка

  console.log("Запись файла завершена. Содержимое файла:");
  let data = fs.readFileSync("hello.txt", "utf8");
  console.log(data); // выводим считанные данные
});
```

---

## 29. Что называется типизацией переменных в JavaScript?

- Возможность хранения в одной переменной разных типов данных.

```js
Geeks = 42;
Geeks = "GeeksforGeeks";
```

---

## 30. Как преобразовать строку любого формата в целое число в JavaScript?

- В JavaScript функция [parseInt()](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/parseInt) используется для преобразования строки в целое число. Эта функция возвращает целое число base, которое указано во втором аргументе функции `parseInt()`. Функция `parseInt()` возвращает `NaN` (не число), если строка не содержит число.

```js
console.log(parseInt("6", 10)); // 6
```

```js
console.log(parseInt("es6", 10)); //NaN
```

---

## 31. Объясните, как обнаружить операционную систему на клиентском компьютере?

- Чтобы обнаружить операционную систему на клиентском компьютере, можно просто использовать свойство `navigator.appVersion` или `navigator.userAgent`. Свойство `Navigator.appVersion` является свойством только для чтения и возвращает строку, представляющую информацию о версии браузера.

---

## 32. Какие типы всплывающих окон доступны в JavaScript?

- Существует три типа всплывающих окон, доступных в JavaScript.

1. Alert
2. Confirm
3. Prompt

---

## 33. В чем разница между окном предупреждения - `alert` и окном подтверждения - `confirmation`?

- В окне предупреждения - `alert` будет отображаться только одна кнопка, которая является кнопкой **«ОК»**. Он используется для информирования пользователя о соглашении, которое необходимо согласовать. Но в окне подтверждения - `confirmation` отображаются две кнопки **«ОК»** и **«Отмена»**, где пользователь может принять решение, соглашаться или нет.

---

## 34. В чем недостаток использования `innerHTML` в JavaScript?

- Использование `innerHTML` в JavaScript имеет много недостатков, поскольку контент будет заменён везде. Если вы используете `+= like “innerHTML = innerHTML + ‘html'”`, все равно старый контент заменяется HTML. Он сохраняет обработчики событий, прикрепленные к любым элементам DOM.

---

## 35. Какая польза от `void(0)`?

- [Void(0)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/void) используется для вызова другого метода без обновления страницы во время передачи параметра времени «ноль».

> Этот оператор позволяет вставлять выражения, которые производят дополнительные действия, в места, где ожидается undefined.

> Оператор void часто используется для получения примитивного значения undefined, используя "void(0)" (что эквивалентно "void 0"). В подобных случаях можно просто использовать глобальную переменную undefined (предполагая, что её значение по умолчанию не было изменено).

Когда браузер переходит по `javascript: URI`, он вычисляет код в URI и заменяет содержание страницы возвращенным значением, если оно не равно `undefined`. Можно воспользоваться оператором `void` для возврата `undefined`. Например:

```html
<a href="javascript:void(0);">
  Click here to do nothing
</a>

<a href="javascript:void(document.body.style.backgroundColor='green');">
  Click here for green background
</a>
```

Однако заметим, что не рекомендуется использовать псевдо-протокол `javascript:`. Лучше прибегнуть к другим альтернативам, таким, как обработчики событий.

---

## 36. Что такое `JavaScript Cookies`?

- Файлы `cookie` - это небольшие файлы, которые хранятся на компьютере пользователя. Они используются для хранения скромного объема данных, специфичных для конкретного клиента и веб-сайта, и могут быть доступны как веб-сервером, так и клиентским компьютером. Когда были изобретены файлы `cookie`, это были небольшие документы, содержащие информацию о вас и ваших предпочтениях. Например, когда вы выбираете язык, на котором вы хотите просматривать свой веб-сайт, веб-сайт будет сохранять информацию в документе, называемом `cookie`, на вашем компьютере, и в следующий раз, когда вы посетите веб-сайт, он сможет прочитать cookie сохраненные ранее.

---

## 37. Как создать `cookie` с помощью JavaScript?

- Чтобы создать `cookie` с помощью JavaScript, вам просто нужно присвоить строковое значение объекту `document.cookie`.

```js
document.cookie = "key1 = value1; key2 = value2; expires = date";
```

---

## 38. Как читать куки с помощью JavaScript?

- Значение `document.cookie` используется для создания файла `cookie`. Всякий раз, когда вы хотите получить доступ к `cookie`, вы можете использовать строку. Строка `document.cookie` содержит список пар **имя = значение**, разделенных точками с запятой, где **имя** - это имя файла `cookie`, а **значение** - его строковое значение.

---

## 39. Как удалить куки с помощью JavaScript?

- Удалить `cookie` гораздо проще, чем создать или прочитать `cookie`, вам просто нужно установить значение expires = «прошлое время» - `expires = “past time”` и убедиться, что определен правильный путь к `cookie`, только это не позволяет вам удалить `cookie`. :-)

---

## 40. Что такое escape-символы - `escape characters` и escape-функция - `escape() function`?

- Escape-символ `escape characters`: этот символ необходим, если вы хотите работать с некоторыми специальными символами, такими как одинарные и двойные кавычки, апострофы и амперсанды. Все специальные символы играют важную роль в JavaScript, чтобы проигнорировать это или напечатать этот специальный символ, вы можете использовать обратную косую черту escape-символа «`\`».

```javascript
// Need escape character
document.write("GeeksforGeeks: A Computer Science Portal "for Geeks" ")
document.write("GeeksforGeeks: A Computer Science Portal \"for Geeks\" ")
```

- Функция escape() - `escape() function`: функция escape () принимает строку в качестве параметра и кодирует ее, чтобы ее можно было передать на любой компьютер в любой сети, поддерживающей символы ASCII.

---

## 41. Имеет ли JavaScript область действия концептуального уровня - `concept level scope`?

- JavaScript не имеет области действия концептуального уровня, его объявленная переменная внутри любой функции имеет область действия внутри функции.

---

## 42. Как общие объекты могут быть созданы в JavaScript?

Для создания универсального объекта в JavaScript используйте:

```js
var I = new object();
```

---

## 43. Какие ключевые слова используются для обработки исключений?

- При выполнении кода JavaScript ошибки почти наверняка возникнут. Эти ошибки могут возникать из-за ошибки со стороны программиста из-за неправильного ввода или даже если есть проблемы с логикой программы. Но все ошибки могут быть решены с помощью приведенных ниже команд.

1. Оператор `try` позволяет вам протестировать блок кода на наличие ошибок.
2. Оператор `catch` позволяет вам обработать ошибку, если она есть.
3. Оператор `throw` позволяет вам создавать свои собственные ошибки.

---

## 44. Какая польза от `blur function`?

`blur function` используется для удаления фокуса с выбранного элемента. Этот метод запускает событие размытия - `blur event` или к нему можно прикрепить функцию, запускаемую при возникновении `blur event` - события размытия.

---

## 45. Что такое метод `unshift` в JavaScript?

Он используется для вставки элементов в начало массива. Это как метод `push`, но он вставляет элементы в начало массива.

---

## 46. В чем заключается разница между классовым и прототипным наследованием?

- **Классовое наследование**: экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор `new`. Экземпляр класса может не содержать дескриптор `class` начиная с ES6.

- **Прототипное наследование**: экземпляры наследуются напрямую от других объектов, реализуются через фабрики или `Object.create()` и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое.

---

## 47. Что такое двусторонняя связь данных и однонаправленный поток данных и в чем разница между ними?

- Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот.

- Однонаправленный поток данных означает, что только модель – источник истины. Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о намерении модели (или "`store`" в терминах React). Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание.

- Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.

---

## 48. Каковы плюсы и минусы функционального и объектно-ориентированного программирования?

- Плюсы ООП: простая для понимания концепция объектов и методов вызова. ООП стремится использовать _императивный_ стиль, нежели _декларативный_, который читается как прямой набор машинных инструкций.

- Минусы ООП: как правило, присутствует зависимость от общих состояний. Объекты и их поведение связаны одной сущностью, к которой случайно может быть получен доступ любым количеством функций в неопределенном порядке, что может привести к непредсказуемому поведению, например, состоянию гонки.

- Плюсы ФП: используется функциональная парадигма, позволяющая избежать общих состояний и нежелательных эффектов, исключаются ошибки, возможные из-за конкурирования функций. Благодаря таким фичам, как неявное программирование, функции, как правило, радикально упрощаются и легко перестраиваются для более легкого, по сравнению с ООП, повторного использования кода.

- Вычисления, использующие чистые функции легко масштабируются на несколько процессоров или распределенных вычислительных кластеров без опасения возникновения борьбы за ресурсы.

- Минусы ФП: чрезмерная эксплуатация функциональных подходов, вроде неявного программирования, может привести к снижению читабельности кода, так как конечный код получается более абстрактным, кратким и менее конкретным.

- Чаще люди больше знакомы с ООП и императивным подходом, так что некоторые общие идиомы функционального программирования могут вызывать трудности у новичков.

- Функциональное программирование имеет более крутую кривую обучения, нежели ООП, имеющего большую популярность и более понятного для изучения. Концепции ФП часто описываются идиомами и обозначениями из лямбда-исчислений, алгебры и теории категорий, требующих знаний основ в этих областях для понимания.

---

## 49. Когда классовое наследование – подходящий выбор?

- Вопрос с подвохом. Правильный ответ – никогда. Композиция – более простой и гибкий подход, чем наследование классов.

---

## 50 Что значит "композиция объектов лучше, чем наследование классов"?

- Это цитата из книги “Design Patterns: Elements of Reusable Object-Oriented Software”. Повторное использование кода должно достигаться за счет сборки малых единиц функциональности в новый объект, а не наследованием классов и созданием иерархий.

---

---

# Часто задаваемые вопросы на интервью по JavaScript | Часть 3

## 51. Что-такое хэш-таблица?

Хэш-табли́ца или хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции:

- операцию добавления новой пары,
- операцию поиска и
- операцию удаления пары по ключу.

Подробней: https://ru.wikipedia.org/wiki/Хеш-таблица

---

## 52. Что такое `web workers` и зачем они нужны?

`Web Workers` предоставляют простое средство для запуска скриптов в фоновом потоке. Поток Worker'а может выполнять задачи без вмешательства в пользовательский интерфейс. К тому же, они могут осуществлять ввод/вывод, используя `XMLHttpRequest` (хотя атрибуты `responseXML` и `channel` всегда будут равны `null`). Существующий Worker может отсылать сообщения в JavaScript код, который его создал, отправляя сообщения в обработчик событий, указанный этим кодом (и наоборот).

`Web worker` – это асинхронная система или протокол, позволяющий веб-страницам выполнять задачи в фоновом режиме независимо от основного потока и пользовательского интерфейса веб-сайта. Это изолированная среда, которая изолирована от объекта `window`, объекта `document`, прямого доступа в Интернет и лучше всего подходит для длительных или сложных вычислительных задач.

Помимо `web worker` – системы, предназначенной для многопоточности, – существуют и другие способы выполнения асинхронной обработки в JavaScript, такие как асинхронные вызовы Ajax и цикл обработки событий (`event loop`).

Подробней: https://developer.mozilla.org/ru/docs/DOM/Using_web_workers

---

## 53. Какие ограничения накладываются на поток `Web Worker`?

Потоки `web worker` не могут изменять HTML элементы, глобальные переменные и некоторые свойства окон, такие как `window.location`. Вы можете использовать типы данных javascript, вызовы `XMLHttpRequest` и прочее.

Сценарий должен обслуживаться с того же хоста или домена из соображений безопасности, и это также будет причиной того, что web worker не будут работать, если мы откроем файл локально с помощью схемы `file://`.

#### Разделение потоков

Здесь важно отметить разделение область видимости `window` и `document` в потоке основного окна браузера и `worker`.

Чтобы использовать поток `worker`, эти две области должны иметь возможность обмениваться данными. Для этого мы используем функцию `postMessage()` в файле `worker.js` – для отправки сообщений в основной поток браузера – и `listener` (слушиватель) `worker.onmessage` в главном потоке для получения сообщений от `worker`.

Мы также можем отправлять сообщения из основного потока браузера в поток `worker`. Единственное отличие состоит в том, что мы вызываем `worker.postMessage()` в главном потоке, а `onmessage` в потоке `worker`.

Мы можем использовать метод `terminate()`, чтобы завершить выполнение `worker`.

Имея все это в виду, мы подходим к этому примеру:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Web Workers Example</title>

    <style type="text/css">
      body {
        padding-top: 28px;
      }
      .output-cont {
        margin-left: 12%;
        margin-top: 28px;
      }

      .output-cont h3 {
        width: 200px;
        height: 100%;
      }
      .output-cont button {
        padding: 4px 8px;
        font-size: 1.1rem;
        font-family: sans-serif;
      }
    </style>
  </head>

  <body>
    <div class="output-cont">
      <button onclick="testWorker()">start worker</button>
      <h3 id="workerOutput"></h3>
      <button onclick="terminateWorker()">terminate worker</button>
    </div>
    <br />
    <div class="output-cont">
      <button onclick="testMainThread()">start blocking thread</button>
      <h3 id="mainThreadOutput"></h3>
    </div>
    <br />
    <div class="output-cont">
      <button onclick="alert('browser responsive!')">
        test browser responsiveness
      </button>
    </div>

    <script>
      var worker;

      function testWorker() {
        if (typeof Worker !== "undefined") {
          if (typeof worker == "undefined") {
            worker = new Worker("worker.js");
          }
          worker.onmessage = function (event) {
            document.getElementById("workerOutput").innerHTML = event.data;
          };
        } else {
          document.getElementById("workerOutput").innerHTML =
            "Web Workers are not supported in your browser";
        }
      }
      function terminateWorker() {
        worker.terminate();
        worker = undefined;
      }

      function testMainThread() {
        for (var i = 0; i < 200000; i++) {
          document.getElementById("mainThreadOutput").innerHTML =
            "Main Thread Counter: " + i;
        }
      }
    </script>
  </body>
</html>
```

и worker.js:

```js
i = 0;
while (i < 200000) {
  postMessage("Web Worker Counter: " + i);
  i++;
}
```

![Worker img](img/webworker.gif)

Теперь мы можем видеть, что рабочий поток не блокирует интерактивность основного процесса браузера, а циклический вывод 200 000 номеров не влияет на основной поток. Числа в элементе `#workerOutput` обновляются на каждой итерации.

Блокирующий поток, или основной поток, когда задействован в цикле, блокирует всю интерактивность (здесь мы установили число итераций 200 000, но это будет еще более очевидно, если мы увеличим его до 2 000 000).

Еще одна вещь, которая указывает нам на заблокированный основной поток, заключается в том, что рабочий процесс обновляет страницу на каждой итерации, а цикл в главном потоке (определенный в `index.html`) обновляет только элемент `#mainThreadOutput` на последней итерации.

Это связано с тем, что браузер слишком занят подсчетом (`цикл for`), чтобы иметь возможность перерисовывать DOM, поэтому он делает это только после того, как его работа с циклом `for` полностью завершена (в конце цикла)

---

## 54. Как создать поток `web worker` в JavaScript?

Мы используем их следующим образом: мы проверяем наличие конструктора `Worker()` в браузере, и, если он доступен, мы создаем экземпляр рабочего объекта с URL-адресом сценария в качестве аргумента. Этот скрипт будет выполняться в отдельном потоке.

```js
if (typeof Worker !== "undefined") {
  worker = new Worker("worker.js");
}
```

Подробней:

- https://developer.mozilla.org/ru/docs/DOM/Using_web_workers
- https://habrahabr.ru/post/132785/
- https://webdevblog.ru/javascript-web-workers-rukovodstvo-dlya-nachinajushhih/

---

## 55. Как уничтожить объект web worker?

`w.terminate();`

---

## 56. Зачем в HTML 5 введены события `server-sent`?

Разрабатывать web-приложения, использующие Server-Sent Events намного проще, чем с использованием websockets. Нужно всего лишь немного кода на стороне сервере, чтобы переправлять события web-приложению, но клиентская часть кода для обработки этих событий работает почти точно так же, как и для любых других событий.

Подробней:

- https://ru.wikipedia.org/wiki/Server-sent_events
- https://habrahabr.ru/post/120429/
- https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events/Using_server-sent_events

---

## 57. Что такое неопределенные (`undefined`) и необъявленные (`undeclared`) переменные?

- `undefined` - значение
- `undeclared`- ошибка ReferenceError

Пример:

```js
typeof a; //'undefined'
a; //ReferenceError: a is not defined
```

_Проблема_: оператор `typeof` говорит нам, что тип необъявленной переменной — `undefined`, но при обращении к ней происходит ошибка.
_Объяснение_: на самом деле, есть 2 понятия — `Undefined` и `Undeclared`. Так вот, необъявленная переменная является `Undeclared`-переменной и обращение к ней вызывает ошибку. Объявленная, но не инициализированная переменная принимает значение `undefined` и при обращении к ней ошибок не возникает.
_Совет_: перед обращением к переменной, вы должны быть уверенны, что она объявлена. Если вы обратитесь к `Undeclared`-переменной, то код, следующий за обращением, не будет выполнен.

Подробней: https://habrahabr.ru/post/159313/

---

## 58. Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.

```js
function numberGenerator() {
  // Локальная «свободная» переменная, которая доступна только в замыкании
  var num = 1;
  function checkNumber() {
    console.log(num);
  }
  num++;
  return checkNumber;
}

var number = numberGenerator();
number(); // 2
```

В примере функция `numberGenerator` создаёт локальную «свободную» переменную `num` (число) и `checkNumber` (функция, которая выводит число в консоль). Функция `checkNumber` не содержит собственной локальной переменной, но благодаря замыканию она имеет доступ к переменным внутри внешней функции, `numberGenerator`. Поэтому объявленная в `numberGenerator` переменная `num` будет успешно выведена в консоль, даже после того, как `numberGenerator` вернёт результат выполнения.

Подробней

- https://htmlacademy.ru/blog/195-lets-learn-javascript-closures
- https://habrahabr.ru/post/38642/

---

## 59.Объясните "JavaScript module pattern" и где он (паттерн) применяется?

Первостепенная задача не засорять пространство имен, но с модульностью ES2015 как таковая необходимость отпала.

«Модуль», позволяет скрывать приватную информацию в замыканиях, давая доступ лишь к тому, что решил сделать общедоступным разработчик.

Благодаря этому мы можем защищать код от несанкционированного вмешательства и защищать глобальную область видимости от загрязнения. Если этого не делать, то, с одной стороны, работа внутренних механизмов модулей может быть случайно или целенаправленно нарушена, из-за того, что внешний код обращается к функциям или переменным, к которым он обращаться не должен. С другой стороны, если не пользоваться описанным здесь подходом, в глобальную область видимости попадает много ненужного, что может, например, привести к конфликтам имён.

Этот шаблон позволяет скрывать детали реализации модулей, защищая их от случайных или намеренных изменений, и помогает поддерживать в чистоте глобальную область видимости.

Подробнее

- https://habr.com/ru/company/ruvds/blog/419997/

---

## 60. Как Вы организуете свой код? (`module pattern`, наследование)?

Теперь пришло время поговорить о приватных переменных и функциях. Например, это могут быть некие вспомогательные функции, обеспечивающие работу внутренних механизмов модуля.

Это могут быть временные переменные, или переменные, играющие роль хранилищ неких данных, доступ к которым мы хотим жёстко контролировать. Нас интересует такое устройство модуля, когда внешнему миру доступно лишь то, что должно быть доступно, а всё остальное оказывается скрытым. Собственно говоря, приватным станет всё то, что, в нашем примере, будет объявлено за пределами объекта, возвращаемого из IIFE.

```js
  var privateMethod = function () {

  };
  return {
    publicMethod: function () {

    }
  };
})();
```

Метод `publicMethod` из этого примера можно вызвать извне, а функцию `privateMethod` — нет, так как она находится в приватной области видимости, в замыкании. Именно подобные функции, недоступные извне, могут выполнять роль вспомогательных механизмов модулей. Они могут использоваться для управления внутренними структурами данных, для выполнения каких-то вызовов к неким сервисам, и в других ситуациях.

При работе с подобными функциями нужно учитывать, что к ним можно обращаться из других функций, объявленных в той же области видимости, в том числе — и из методов возвращённого из IIFE объекта, причём, даже после того, как выполнена команда `return`, возвращающая этот объект. То есть, общедоступные методы имеют доступ к приватным функциям, они могут с ними взаимодействовать, но в глобальной области видимости эти приватные функции недоступны.

```js
var Module = (function () {
  var privateMethod = function () {};
  return {
    publicMethod: function () {
      // у этого метода есть доступ к privateMethod, мы можем вызвать его здесь так:
      // privateMethod();
    },
  };
})();
```

Благодаря этому мы можем защищать код от несанкционированного вмешательства и защищать глобальную область видимости от загрязнения. Если этого не делать, то, с одной стороны, работа внутренних механизмов модулей может быть случайно или целенаправленно нарушена, из-за того, что внешний код обращается к функциям или переменным, к которым он обращаться не должен. С другой стороны, если не пользоваться описанным здесь подходом, в глобальную область видимости попадает много ненужного, что может, например, привести к конфликтам имён.

Вот пример объекта, возвращаемого из IIFE, который содержит общедоступные методы и может обращаться к приватным функциям:

```js
var Module = (function () {
  var myModule = {};
  var privateMethod = function () {};
  myModule.publicMethod = function () {};
  myModule.anotherPublicMethod = function () {};
  return myModule; // возвращает объект с общедоступными методами
})();

// использование модуля
Module.publicMethod();
```

#### Именование приватных и общедоступных функций

Существует одно соглашение, в соответствии с которым в начале имён приватных функций ставят знак подчёркивания. Это позволяет, лишь взглянув на код, понять, какие функции являются внутренними, а какие — общедоступными. Например, выглядеть это может так:

```js
var Module = (function () {
  var _privateMethod = function () {};
  var publicMethod = function () {};
  return {
    publicMethod: publicMethod,
  };
})();
```

Подробней:

- https://habr.com/ru/company/ruvds/blog/419997/
- https://habrahabr.ru/post/131714/

---

## 61. В чем разница между `host`-объектами и нативными объектами?

_Встроенные объекты_: `String`, `Math`, `RegExp`, `Object`, `Function` и т.д. - основные предопределенные объекты, всегда доступные в JavaScript. Определено в спецификации ECMAScript.

_Объекты хоста_: объекты типа `window`, `XmlHttpRequest`, узлы `DOM` и т.д., которые предоставляются средой браузера. Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста. Если JavaScript работает за пределами браузера, например, на языке сценариев на стороне сервера, например, в Node.js, будут доступны разные объекты хоста.

_Объекты пользователя_: объекты, определенные в JavaScript-коде.

---

## 62.В чем разница между `.call` и `.apply`?

- `.call()` - вызывает ту же функцию с указанными аргументами

* `.apply()` - вызывает ту же функцию с аргументами, указанными в массиве

* `.bind()` - создает новую функцию с тем же самым телом функции с заданным значением `this` (первый аргумент) и возвращает эту функцию.

Во всех случаях первый аргумент используется как значение `this` внутри функции.

Подробней:

- https://learn.javascript.ru/call-apply
- https://habrahabr.ru/sandbox/33838/

---

## 63.Что делает и для чего нужна функци `Function.prototype.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Подробней: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

---

## 64. Объясните, как работает наследование в JavaScript?

Модель наследования в JavaScript может озадачить опытных разработчиков на высокоуровневых объектно-ориентированных языках (таких, например, как Java или C++), поскольку она динамическая и не включает в себя реализацию понятия `class` (хотя ключевое слово `class`, бывшее долгие годы зарезервированным, и приобрело практическое значение в стандарте ES2015, однако, `class` в JavaScript ES>=6 представляет собой лишь "синтаксический сахар" поверх прототипно-ориентированной модели наследования).

В плане наследования JavaScript работает лишь с одной сущностью: объектами. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство `prototype` равно `null`. По определению, `null` не имеет прототипа и является завершающим звеном в цепочке прототипов.

Хотя прототипную модель наследования некоторые относят к недостаткам JavaScript, на самом деле она мощнее классической. К примеру, поверх неё можно предельно просто реализовать классическое наследование, а вот попытки совершить обратное непременно вынудят вас попотеть.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
- https://learn.javascript.ru/class-inheritance
- https://habrahabr.ru/post/131714/

---

## 65. Расскажите, как работает прототипное наследование

Этот вопрос очень часто задают на собеседованиях. Все объекты в JavaScript имеют свойство `prototype`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее [делегирование, чем наследование](https://davidwalsh.name/javascript-objects).

Ссылки

- https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson
- https://davidwalsh.name/javascript-objects

---

## 66.Что вы думаете о `AMD` против `CommonJS`?

Оба являются способами реализации системы модулей, которая изначально не присутствовала в JavaScript до появления ES2015. `CommonJS` является синхронным, в то время как `AMD` (Asynchronous Module Definition, асинхронное определение модуля) — соответственно, асинхронным. `CommonJS` разработан с учетом разработки на стороне сервера, в то время как `AMD` с поддержкой асинхронной загрузки модулей больше предназначена для браузеров.

Я считаю синтаксис `AMD` довольно многословным, а `CommonJS` ближе к стилю, который используется в выражениях импорта в других языках. В большинстве случаев я считаю `AMD` ненужным, потому что если вы разместите весь свой код в одном объединенном файле, то вы не сможете воспользоваться свойствами асинхронной загрузки. Кроме того, синтаксис `CommonJS` ближе к стилю написания модулей Node, и поэтому происходит меньше путаницы при переключении между клиентской и серверной разработкой на JavaScript.

Я рад, что с появлением модулей ES2015, которые поддерживают как синхронную, так и асинхронную загрузку, мы, наконец, можем придерживаться одного подхода. Несмотря на то, что они не полностью поддерживаются во всех браузерах и Node, мы можем использовать транспайлеры для преобразования нашего кода.

Ссылки

- https://auth0.com/blog/javascript-module-systems-showdown/
- https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs

---

## 67.Объясните, почему это не является IIFE: `function foo(){ }();`. Что необходимо изменить, чтобы это стало IIFE??

`IIFE` расшифровывается как `Immediately Invoked Function Expression` — немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ }();` как `function foo(){ }` и `();`, где первое выражение — это объявление функции, а второе (пара скобок) — попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются **объявлениями функций**. Оборачивая эту функцию внутри`()`, она становится **функциональным выражением**, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

Вы также можете использовать оператор `void` — `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше `IIFE` возвращает что-либо, вы не можете его использовать. Пример:

```js
const foo = void function bar() { return ‘foo’; }();
console.log(foo); // undefined
```

Ссылки

- http://lucybain.com/blog/2014/immediately-invoked-function-expression/
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void

---

## 68.В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?

**Необъявленные** переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`, `let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок`try/catch`.

```js
function foo() {
  x = 1; // ReferenceError в строгом режиме
}
foo();
console.log(x); // 1
```

Переменная `undefined` — это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Чтобы проверить это, сравните, используя оператор строгого равенства (`===`) или `typeof`, который вернет строку `undefined`. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет `true`, если значение равно `null`.

```js
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === ‘undefined’); // true
console.log(foo == null); // true. Неправильно, не используйте это для проверки!
function bar() {}
var baz = bar();
console.log(baz); // undefined
```

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (`==`) для проверки, так как он также вернет `true`, если значение равно `undefined`.

```js
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === ‘object’); // true
console.log(foo == undefined); // true. Неправильно, не используйте это для проверки!
```

Личная привычка — я никогда не оставляю свои переменные необъявленными или неприсвоенными. Я явно назначаю им null после объявления, если я не собираюсь их пока использовать. Если вы используете линтер в своем рабочем процессе, он обычно также проверяет, что вы не ссылаетесь на необъявленные переменные.

Ссылки

- https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables
- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var

---

## 69.Что такое замыкание и как/для чего его используют?

Замыкание — это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово “лексический” относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания — это функции, которые имеют доступ к переменным внешней (замыкающей) функции — цепочке областей видимости даже после того, как внешняя функция вернулась.

### Для чего его используют?

- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий. Обычно используется в [модульном паттерне](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript).

- [Частичное применение функций или каррирование.](https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8)

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
- https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36

---

## 70. Можете ли вы описать основное различие между циклом `.forEach` и циклом `.map()`? И в каких случаях каждый из них используется?

Чтобы понять разницу между ними, давайте посмотрим, что делает каждая функция.

### forEach

- Перебирает элементы в массиве.
- Вызывает `callback-функцию` для каждого элемента.
- Не возвращает значение.

```js
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  // Делаем что-либо с num и/или index.
});
// doubled = undefined
```

### map

- Перебирает элементы в массиве.
- “Сопоставляет” каждый элемент с новым элементом, вызывая функцию для каждого элемента, создавая в результате новый массив.

```js
const a = [1, 2, 3];
const doubled = a.map((num) => {
  return num * 2;
});
// doubled = [2, 4, 6]
```

Основное различие между `.forEach` и `.map()` состоит в том, что `.map()` возвращает новый массив. Если вам нужен результат, но вы не хотите изменять исходный массив, `.map()` — очевидный выбор. Если вам просто нужно перебрать массив, то стоит воспользоваться `forEach`.

Ссылки

- https://codeburst.io/javascript-map-vs-foreach-f38111822c0f

---

## 71. В каких случаях обычно используются анонимные функции?

Они могут использоваться в `IIFE` для инкапсуляции кода в локальную область видимости, чтобы объявленные в ней переменные не попадали в глобальную область видимости.

```js
(function () {
  // Здесь код функции.
})();
```

Как `callback`-функция, которая используется один раз и не должна использоваться где-либо еще. Код будет казаться более автономным и читаемым, когда обработчики будут определены прямо внутри вызывающего их кода, а не искать в другом месте, чтобы найти тело функции.

```js
setTimeout(function () {
  console.log("Hello world!");
}, 1000);
```

Аргументы в конструкциях функционального программирования или `Lodash` (аналогично `callback`-функциям).

```js
const arr = [1, 2, 3];
const double = arr.map(function (el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]
```

Ссылки

- https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions
- https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo

---

## 72.Как вы организуете свой код? (module pattern, classical inheritance)

В прошлом я использовал `Backbone`, который поощряет ООП подход, создавая Backbone модели и добавляя к ним методы.

Модульный паттерн до сих пор хорош, но в настоящее время я использую `React/Redux`, который использует однонаправленный поток данных на основе архитектуры `Flux`. Я создаю модели своего приложения при помощи простых объектов и пишу чистые функции для управления этими объектами. Состояние управляется при помощью экшенов и редьюсеров, как в любом другом приложении `Redux`.

Я избегаю использования наследования классов, где это возможно. Если же мне это необходимо сделать, то я придерживаюсь [этих правил](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4).

---

## 73. Что такое объект `arguments`?

`Arguments` — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство `length`, мы можем получить доступ к определенному значению с помощью `arguments[i]`, но у него отсутствуют методы `forEach`, `reduce`, `filter` и `map`. Он позволяет узнать количество параметров функции.

Преобразовать `arguments` в массив можно с помощью `Array.prototype.slice`:

`Array.prototype.slice.call(arguments)`

Запомните: в стрелочных функциях объект `arguments` **не работает**.

```js
function one() {
    return arguments
}
const two = function() {
    return arguments
}
const three = function three({
    return arguments
})
const four = () => arguments

four() // arguments is not defined
```

Вызов функции `four` приводит к ошибке `ReferenceError: arguments is not defined`. Эту проблему можно решить с помощью оператора `rest`:

```js
const four = (...args) => args;
```

Это автоматически поместит все параметры в массив.

---

## 74. В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Я полагаю, что суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` — это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает `Person` как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается `undefined`, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта `Person` с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например: `Object.create(Person.prototype)`.

```js
function Person(name) {
  this.name = name;
}
var person = Person(‘John’);
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: Cannot read property ‘name’ of undefined
var person = new Person(‘John’);
console.log(person); // Person { name: “John” }
console.log(person.name); // “john”
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new

---

## 75. В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

```js
function add(a, b) {
  return a + b;
}
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

---

## 76. Что делает и для чего нужна функция `Function.prototype.bind`?

Взято дословно с MDN:

> Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
> По моему опыту, это наиболее полезно для привязки значения `this` в методах классов, которые вы хотите передать в другие функции. Это часто делается в компонентах React.

Ссылки

- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind

---

## 77. В каких случаях используется `document.write()`?

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает `document.open`, который очищает весь документ (`<head>`и `<body>` будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

В Интернете есть несколько ответов, которые объясняют, что `document.write()` используется в коде отслеживания или когда вы хотите добавить стили, которые должны работать только при включенном JavaScript. Он даже используется в шаблоне HTML5 для параллельной загрузки скриптов и сохранения порядка выполнения! Тем не менее, я подозреваю, что эти причины могут быть устаревшими, и в наши дни они могут быть достигнуты без использования `document.write()`. Пожалуйста, поправьте меня, если я ошибаюсь по этому поводу.

Ссылки

- https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html
- https://github.com/h5bp/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag

---

## 78.В чем разница между `feature detection` (определение возможностей браузера), `feature inference` (предположение возможностей) и анализом строки `user-agent`?

### `Feature detection` (определение возможностей браузера)

Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода - и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:

```js
if ("geolocation" in navigator) {
  // Можно использовать navigator.geolocation
} else {
  // Обработка отсутствия возможности
}
```

`Modernizr` - отличная библиотека для обработки таких функций.

### `Feature inference` (предположение возможностей)

Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует, например:

```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

Этот подход не рекомендуется. Первый подход более надежен.

### Строка `User Agent`

Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя от которого исходит запрос. Доступ к ней можно получить через `navigator.userAgent`. Тем не менее, строка `User Agent` сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome, так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте этого метода.

Ссылки

- https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection
- https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent

---

## 79. Расскажите об `Ajax` как можно более подробно

`Ajax` (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью `Ajax` веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, `Ajax` позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных `JSON` вместо `XML` из-за того, что `JSON` основан на JavaScript.

Раньше для асинхронного взаимодействия использовали `XMLHttpRequest API`, а сейчас принято использовать `fetch API`.

Ссылки

- https://en.wikipedia.org/wiki/Ajax_(programming)
- https://developer.mozilla.org/en-US/docs/AJAX

---

## 80. Какие преимущества и недостатки в использовании `Ajax`?

### Преимущества

- Повышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.

- Сокращение количества подключений к серверу, поскольку скрипты и таблицы стилей нужно запрашивать только один раз.

- Состояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.

- Большая часть преимуществ SPA.

### Недостатки

- Сложнее реализовать добавление динамической веб-страницы в закладки.
- Не работает, если в браузере отключен JavaScript.
- Некоторые поисковые роботы не выполняют JavaScript и не видят данные, загружаемые при помощи JavaScript.
- Большая часть недостатков SPA.

### Объясните, как работает `JSONP` (и почему это не совсем AJAX)

- `JSONP` (`JSON` с набивкой) - это способ, часто используемый для обхода политики ограничения домена в браузерах, потому что `Ajax`-запросы с текущей страницы к серверу, находящемуся в другом домене, запрещены.
- `JSONP` работает, отправляя запрос к серверу в другом домене через тег `script` и обычно с параметром запроса `callback`, например:https://example.com?callback=printData. Затем сервер обернет данные внутри функции с именем `printData` и вернет их клиенту.

**HTML**:

```html
<!-- https://mydomain.com -->
<script>
  function printData(data) {
    console.log(`My name is ${data.name}!`);
  }
</script>
<script src="https://example.com?callback=printData"></script>
```

**JS**:

// Файл загружен с `https://example.com?callback=printData printData({ name: 'Yang Shun' });`

У клиента должна быть функция `printData` в своей глобальной области видимости, и эта функция будет выполнена клиентом, когда будет получен ответ с сервера из другого домена.

`JSONP` может быть небезопасным и иметь повышенный риск. Поскольку `JSONP` - это действительно JavaScript, и он может делать все остальное, что может делать JavaScript, то вы должны быть уверены в надежности поставщика данных `JSONP`.
В наши дни, CORS является рекомендуемым подходом и `JSONP` является способом для его обхода.

Ссылки

- https://stackoverflow.com/a/2067584/1751946

---

## 81.Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?

Да. Handlebars, Underscore, Lodash, AngularJS, и JSX. Мне не нравилась шаблонизация в AngularJS, потому что там активно использовались строки в директивах и легко допустить ошибку при опечатке. JSX - мой новый фаворит, так как он ближе к JavaScript и почти не имеет дополнительного синтаксиса. В настоящее время вы даже можете использовать строковые литералы шаблонов ES2015 в качестве быстрого способа создания шаблонов, не полагаясь на сторонний код.

```js
const template = `<div>My name is: \${name}</div>`;
```

Однако следует помнить о возможном XSS в вышеприведенном подходе, поскольку содержимое не экранируется, в отличие от библиотек шаблонизации.

---

## 82 Расскажите, что такое поднятие (`hoisting`)

Поднятие (`hoisting`) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова `var`, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Однако, "поднимается" только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.

Обратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.

// объявления переменных через `var` поднимаются.

```js
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1
// объявления переменных через let/const НЕ поднимаются.
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

При объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.

// Объявление функции

```js
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
console.log(foo); // [Function: foo]
// Функциональное выражение
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
  console.log("BARRRR");
};
console.log(bar); // [Function: bar]
```

---

## 83.Объясните, что такое всплытие событий (`event bubbling`)

Когда событие срабатывает на элементе DOM, оно попытается обработать событие (если привязан обработчик), затем событие всплывет вверх к своему родителю и это повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть до `document`. Всплытие событий является механизмом, на котором основано делегирование событий.

---

## 84. В чем разница между "атрибутом" (`attribute`) и "свойством" (`property`)?

Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы проиллюстрировать разницу, представьте, что у нас есть это текстовое поле в HTML:

```html
<input type="text" value="Hello" />. const input =
document.querySelector('input'); console.log(input.getAttribute('value')); //
Hello console.log(input.value); // Hello
```

Но после того, как вы измените значение текстового поля, добавив к нему "`World!`", будет:

```js
`console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

Ссылки

- https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html

---

## 84. Почему не следует расширять нативные JavaScript-объекты?

Расширение встроенного/нативног объекта JavaScript означает добавление свойств/функций к его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на практике это опасно. Представьте, что ваш код использует несколько библиотек, которые расширяют `Array.prototype`, добавляя один и тот же метод `contains`. В результате код будет работать неверно, если поведение этих двух методов не будет одинаковым.

Единственный случай, при котором можно расширить нативный объект — это при создании полифила, создав собственную реализацию метода, который является частью спецификации JavaScript, но может отсутствовать в устаревших браузерах.

Ссылки

- http://lucybain.com/blog/2014/js-extending-built-in-objects/

---

## 85. В чем разница между событием `load` и событием `DOMContentLoaded`?

Событие `DOMContentLoaded` вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.
Событие `load` происходит только после загрузки DOM и всех зависимых ресурсов.

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded
- https://developer.mozilla.org/en-US/docs/Web/Events/load

---

## 86. В чем разница между `==` и `===`?

`==` — это оператор абстрактного сравнения, а `===` — оператор строгого сравнения.

Оператор `==` будет сравнивать на равенство после выполнения любых необходимых преобразований типов.

Оператор `===` не будет выполнять преобразование типов, поэтому, если два значения не одного типа, `===` просто вернет `false`. При использовании `==` могут происходить такие странные вещи, как:

```js
1 == "1"; // true
1 == [1]; // true
1 == true; // true
0 == ""; // true
0 == "0"; // true
0 == false; // true
```

А если сравнить null и undefined с другими ложными значениями при помощи оператора нестрогого сравнения (`==`), то окажется, что они не равны ничему, кроме самих себя:

```js
null == 0; // false
undefined == ""; // false
null == false; // false
undefined == false; // false
null == undefined; // true
```

Мой совет — никогда не используйте оператор `==`, за исключением удобного сравнения с `null` или `undefined`, где выражение `a == null` вернет `true`, если `a` принимает значение `null` или `undefined` .

```js
var a = null;
console.log(a == null); // true
console.log(a == undefined); // true
```

Ссылки

- https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons
- https://frontender.info/exploring-the-abyss-of-null-and-undefined-in-javascript/

---

## 87. Объясните `same-origin policy` в контексте JavaScript

`Same-origin policy` (принцип одинакового источника) не позволяет JavaScript выполнять запросы за границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа `DOM` этой страницы.

Ссылки

- https://en.wikipedia.org/wiki/Same-origin_policy

---

## 88. Сделайте так, чтобы этот код работал:

```js
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
```

Решение:

```js
function duplicate(arr) {
  return arr.concat(arr);
}
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
```

---

## 89. Почему тернарный оператор так называется?

“Тернарный” означает три. Троичное выражение принимает три операнда: условие, выражение “`then`” и выражение “`else`”. Тернарные операторы не являются исключительными для JavaScript, и я не знаю, почему подобный вопрос был добавлен в этот список.

Ссылки

- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operat

---

## 90. Что делает строчка “`use strict`”;? Какие достоинства и недостатки от ее использования?

`use strict` это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.

**Преимущества**:

- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).
- Требует, чтобы имена параметров функции были уникальными.
- `this` в глобальной области видимости равно `undefined`.
- Перехватывает распространенные ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.

**Недостатки**:

- Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- Нет доступа к `function.caller` и `function.arguments`.
- Объединение скриптов, написанных в строгом режиме может вызвать проблемы.

В целом, я думаю, что преимущества перевешивают недостатки, и мне никогда не приходилось полагаться на функции, которые заблокированы в строгом режиме. Я бы порекомендовал использовать строгий режим.

Ссылки

- http://2ality.com/2011/10/strict-mode-hatred.html
- http://lucybain.com/blog/2014/js-use-strict/

---

## 91. Напишите цикл, который перебирает числа до `100`, возвращая ”`fizz`” на числа кратные`3`, ”`buzz`” на числа кратные `5` и ”`fizzbuzz`” на числа кратные `3` и `5`.

```js
for (let i = 1; i <= 100; i++) {
  let f = i % 3 == 0,
    b = i % 5 == 0;
  console.log(f ? (b ? "FizzBuzz" : "Fizz") : b ? "Buzz" : i);
}
```

Хотя я бы не советовал вам использовать этот код во время интервью. Просто придерживайтесь длинного, но ясного подхода. Также можете взглянуть на разные безумные реализации FizzBuzz, по ссылке ниже.

Ссылки

- https://gist.github.com/jaysonrowe/1592432

---

## 92. Почему считается хорошим тоном оставить глобальную область видимости (`global scope`) в нетронутом состоянии?

Каждый скрипт имеет доступ к глобальной области видимости, и если каждый будет использовать глобальное пространство имен для определения своих переменных, то могут возникнуть конфликты. Используйте модульный паттерн (используя IIFE) для инкапсуляции ваших переменных в локальное пространство имен.

---

## 93. Для чего используют событие `load`? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?

Событие `load` происходит в конце процесса загрузки документа. На этом этапе все объекты в документе находятся в DOM, и все изображения, скрипты и ссылки загрузились.
Событие DOM `DOMContentLoaded` будет запущено после создания DOM для страницы, но не будет ждать окончания загрузки других ресурсов. Оно предпочтительно в тех случаях, когда вам не нужно загружать страницу целиком перед инициализацией.

Ссылки:

- https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload

---

## 94. Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.

Текст ниже взят из замечательного [руководства по фронтенду от Grab](https://github.com/grab/front-end-guide).

В наши дни веб-разработчики называют свои продукты веб-приложениями, а не веб-сайтами. Хотя между этими двумя терминами нет строгой разницы, веб-приложения, как правило, очень интерактивны и динамичны, что позволяет пользователю выполнять действия и получать мгновенный ответ.

Традиционно браузер получает HTML с сервера и отображает его. Когда пользователь переходит на другой URL-адрес, требуется полное обновление страницы, и сервер отправляет свежий HTML-код на новую страницу. Это называется рендерингом на стороне сервера.

Однако в современных SPA вместо этого используется рендеринг на стороне клиента.

Браузер загружает начальную страницу с сервера вместе со скриптами (фреймворками, библиотеками, кодом приложения) и таблицами стилей, необходимыми для всего приложения. Когда пользователь переходит на другие страницы, обновление страницы не происходит. URL-адрес страницы обновляется при помощи [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).

Новые данные, необходимые для страницы (обычно в формате JSON), извлекаются браузером посредством запросов [AJAX](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started) к серверу. Затем SPA динамически обновляет страницу данными через JavaScript, которые были получены при начальной загрузке страницы. Эта модель похожа на работу нативных мобильных приложений.

### Преимущества:

- Приложение становится более отзывчивым, и пользователи не видят мерцание при навигации, т.к. страница не обновляется целиком.
- На сервер поступает меньше HTTP-запросов, так как одни и те же ресурсы не нужно загружать снова для каждой загрузки страницы.
- Четкое разделение на клиент и сервер. Вы можете легко создавать новые клиентские приложения для разных платформ (например, для мобильных устройств, чат-ботов, умных часов) без необходимости изменять код сервера. Вы также можете изменить технологический стек на клиенте и сервере независимо, пока между ними существует интерфейс.

### Недостатки:

- Более тяжелая первоначальная загрузка страницы из-за загрузки кода фреймворка, самого приложения и ресурсов.
- Ваш сервер должен быть сконфигурирован так, чтобы он направлял все запросы к единой точке входа, и переложил обязанности по навигации на сторону клиента.
- Для отображения содержимого SPA полагается на JavaScript, но не все поисковые системы выполняют JavaScript во время индексации, и они могут не увидеть содержимое страницы. Это вредит поисковой оптимизации (SEO) вашего приложения. Тем не менее, в большинстве случаев, когда вы создаете приложения, SEO не является наиболее важным фактором, так как не весь контент должен индексироваться поисковыми системами. Чтобы преодолеть это, вы можете либо рендерить свое приложение на стороне сервера, либо использовать такие сервисы, как Prerender, чтобы “рендерить ваш javascript в браузере, сохранять статический HTML и передавать его поисковым роботам”.

Ссылки

- https://github.com/grab/front-end-guide#single-page-apps-spas
- http://stackoverflow.com/questions/21862054/single-page-app-advantages-and-disadvantages
- http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/
- https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52

---

## 95. Насколько вы опытны в работе с промисами (`promises`) и/или их полифилами?

Обладаю практическими знаниями о них. Промис — это объект, который может вернуть одно значение в будущем: либо выполненное значение, либо причина, по которой оно не было выполнено (например, произошла ошибка сети).

Промис может находиться в одном из 3 возможных состояний: выполнено, отклонено или ожидает выполнения. При использовании промисов можно добавлять `callback`-функции для обработки выполненного значения или причины отказа.

Некоторыми распространенными полифилами являются `$.deferred`,`Q` и `Bluebird`, но не все они соответствуют спецификации. ES2015 поддерживает промисы “из коробки”, и в настоящее время полифилы обычно не нужны.

Ссылки

- https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261

---

## 96. Какие преимущества и недостатки при использовании промисов вместо колбэков (`callbacks`)?

### Преимущества:

- Помогает избежать “callback hell”, который может быть нечитаемым.
- Упрощает написание последовательного удобочитаемого асинхронного кода с помощью `.then()`.
- Упрощает написание параллельного асинхронного кода с помощью `Promise.all()`.
- С использованием промисов можно избежать следующих проблем, которые возникают при использовании `callback`-функций:
- Колбэк-функция была вызвана слишком рано
- Колбэк-функция была вызвана слишком поздно (или вовсе не была вызвана)
- Колбэк-функция была вызвана слишком мало или слишком много раз
- Не удалось передать необходимую среду/параметры
- Были пропущены ошибки/исключения

Недостатки

- Чуть более сложный код (спорно).
- В старых браузерах, где не поддерживается ES2015, вам нужно загрузить полифил, чтобы их использовать.

Ссылки

- https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md

---

## 97.Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?

Вот несколько языков, которые компилируются в JavaScript: CoffeeScript, Elm, ClojureScript, PureScript и TypeScript.

Преимущества:

- Исправляют некоторые давние проблемы в JavaScript и препятствует использованию анти-паттернов в JavaScript.
- Позволяют писать более короткий код, предоставляя синтаксический сахар поверх JavaScript, которого, как мне кажется, не хватало в ES5, но с приходом ES2015 все изменилось.
- Статическая типизация идеальна (в случае TypeScript) для больших проектов, которые необходимо поддерживать с течением времени.

Недостатки:

- Необходима сборка/компиляция кода, так как браузеры запускают только JavaScript, и ваш код должен быть скомпилирован в JavaScript перед тем, как он будет передан в браузеры.
- Отладка может быть трудной, если карты кода (source maps) плохо сопоставляются с исходным кодом.
- Большинство разработчиков не знакомы с этими языками и должны будут изучить их. Если ваша команда будет использовать их для своих проектов, это приведет к увеличению затрат.
- Меньшее сообщество (зависит от языка), что означает, что будет труднее найти ресурсы, учебные пособия, библиотеки и инструменты.
- Может отсутствовать поддержка в IDE/редакторе.
- Эти языки всегда будут позади последнего стандарта JavaScript.
- Разработчики должны знать, во что компилируется их код — потому что это то, что будет запускаться в браузере, и это наиболее важно.
  По большому счету, ES2015 значительно улучшил JavaScript и сделал разработку на нем намного удобнее. Я не вижу причин использовать CoffeeScript в наши дни.

Ссылки

- https://softwareengineering.stackexchange.com/questions/72569/what-are-the-pros-and-cons-of-coffeescript

---

## 98. Какие инструменты и методы вы используете при отладке кода?

### React и Redux:

- [React Devtools](https://github.com/facebook/react-devtools)
- [Redux Devtools](https://github.com/reduxjs/redux-devtools)

### Vue:

- [Vue Devtools](https://github.com/vuejs/vue-devtools)

### JavaScript:

- [Chrome Devtools](https://medium.com/hackernoon/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d)
- Выражение `debugger`
- Отладка при помощи старого доброго `console.log`

Ссылки

- https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d
- https://raygun.com/blog/javascript-debugging/

---

## 99. Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?

### Для объектов:

- `for-in` циклы — `for (var property in obj) { console.log(property); }`. Тем не менее, он также будет перебирать его унаследованные свойства, и вам нужно добавить проверку `obj.hasOwnProperty(property)` перед его использованием.
- `Object.keys() — Object.keys(obj).forEach(function (property) { … }). Object.keys()`- это статический метод, который возвращает все перечисляемые свойства объекта.
- `Object.getOwnPropertyNames() — Object.getOwnPropertyNames(obj).forEach(function (property) { … }). Object.getOwnPropertyNames()` — это статический метод, который возвращает все перечисляемые и неперечисляемые свойства объекта.

### Для массивов:

- Циклы `for — for (var i = 0; i < arr.length; i++)`. Распространенной ошибкой здесь является то, что `var` находится в области видимости функции, а не в блочной области видимости, и в большинстве случаев нам нужна переменная-итератор блочной области. ES2015 позволяет использовать `let`, который имеет блочную область видимости, и рекомендуется использовать его вместо `var`. В итоге: `for (let i = 0; i < arr.length; i++)`.
- `forEach — arr.forEach(function (el, index) { … })`. Эта конструкция иногда может быть более удобной, потому что вам не нужно использовать `inde`, если все, что вам нужно, это элементы массива. Существуют также методы `every и some`, которые позволят вам досрочно завершить итерацию.
- `for-of циклы — for (let elem of arr) { … }`. ES6 представил новый цикл `for-of`, который позволяет перебирать объекты, которые соответствуют [итерируемому протоколу](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols) такие как `String`, `Array`, `Map`, `Set`, и т.д. Он сочетает в себе преимущества цикла`for`и метода `forEach()`. Преимущество цикла`for` заключается в том, что его можно преждевременно завершить, а преимущество `forEach()` заключается в том, что он более лаконичен, чем цикл `for`, поскольку вам не нужна переменная счетчика. С циклом `for-of` вы получаете возможность выхода из цикла и более сжатый синтаксис.

В большинстве случаев я бы предпочел метод `.forEach`, но он зависит от того, что вы пытаетесь сделать. До ES6 мы использовали циклы `for`, если нам нужно было преждевременно завершить цикл при помощи `break`. Но теперь с ES6 мы можем сделать это с помощью циклов `for-of`. Я использую циклы `for`, когда мне нужно еще больше гибкости, например, в случае увеличения итератора более одного раза за цикл.
Кроме того, при использовании цикла `for-of`, если вам нужен доступ как к индексу, так и к значению каждого элемента массива, вы можете сделать это с помощью метода ES6 `entries()` и деструктуризации:

```js
const arr = ["a", "b", "c"];
for (let [index, elem] of arr.entries()) {
  console.log(index, ": ", elem);
}
```

Ссылки

- http://2ality.com/2015/08/getting-started-es6.html#from-for-to-foreach-to-for-of
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries

---

## 100. Объясните разницу между синхронными и асинхронными функциями

Синхронные функции являются блокирующими, а асинхронные — нет. В синхронных функциях одна операция должна завершиться, прежде чем будет запущена следующая операция. В этом случае скрипт выполняется строго по порядку операций, и выполнение скрипта приостанавливается, если одна из операций занимает очень много времени.

Асинхронные функции обычно принимают `callback`-функцию в качестве параметра, и выполнение продолжается на следующей строке сразу после вызова асинхронной функции. Callback-функция вызывается только тогда, когда асинхронная операция завершена и стек вызовов пуст. Ресурсоемкие операции, такие как загрузка данных с веб-сервера или запросы к базе данных, должны выполняться асинхронно, чтобы основной поток мог продолжать выполнять другие операции вместо блокировки до завершения этой долгой операции (в случае браузеров пользовательский интерфейс будет зависать).

---

## 101. Что такое цикл событий (`event loop`)? В чем разница между стеком вызовов (`call stack`) и очередью событий (`task queue`)?

Цикл событий — это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть `callback`-функции, то функция удаляется из очереди и помещается в стек вызовов для выполнения.

Рекомендую ознакомиться с [докладом о цикле событий от Philip Robert](https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html). Это одно из самых популярных видео о JavaScript.

Ссылки

- https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html
- http://theproactiveprogrammer.com/javascript/the-javascript-event-loop-a-stack-and-a-queue/

---

## 102.Объясните разницу при использовании `foo` в `function foo() {}` и `var foo = function() {}`

Первое — объявление функции, а второе — функциональное выражение. Ключевое отличие состоит в том, что тело функции при объявлении поднимается наверх, а тело функциональных выражений — нет (они имеют такое же поведение поднятия, что и переменные).

Для получения более подробной информации, обратитесь к вопросу выше о поднятии. Если вы попытаетесь вызвать выражение функции до того, как оно будет определено, вы получите ошибку `Uncaught TypeError: XXX is not a function`.

#### Объявление функции

```js
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
```

#### Функциональное выражение

```js
foo(); // Uncaught TypeError: foo is not a function
var foo = function () {
  console.log("FOOOOO");
};
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function

---

## 103. В чем различие между переменными, созданными при помощи `let`, `var` и `const`?

Переменные, объявленные при помощи ключевого слова `var`, относятся к области видимости функции, в которой они созданы. Или, если они созданы вне какой-либо функции — к глобальному объекту. `let` и `const` относятся к блочной области видимости — это означает, что они доступны только в пределах ближайшего набора фигурных скобок (функция, блок `if-else` или цикл `for`).

```js
function foo() {
  // Все переменные доступны внутри функции.
  var bar = "bar";
  let baz = "baz";
  const qux = "qux";
  console.log(bar); // bar
  console.log(baz); // baz
  console.log(qux); // qux
}
console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
  var bar = "bar";
  let baz = "baz";
  const qux = "qux";
}
// переменные, объявленные при помощи var, доступны в любом месте функции.
console.log(bar); // bar
// переменные, объявленные при помощи let и const не доступны вне блока, в котором были определены.
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
```

`var` позволяет поднимать переменные, что означает, что на них можно ссылаться в коде до их объявления. `let` и `const` не позволяют этого, и выдают ошибку.

```js
console.log(foo); // undefined
var foo = "foo";
console.log(baz); // ReferenceError: can’t access lexical declaration 'baz' before initialization
let baz = "baz";
console.log(bar); // ReferenceError: can’t access lexical declaration 'bar' before initialization
const bar = "bar";
```

Переопределение переменной с помощью `var` не вызовет ошибку, в отличие от `let` и `const`.

```js
var foo = "foo";
var foo = "bar";
console.log(foo); // “bar”
let baz = "baz";
let baz = "qux"; // Uncaught SyntaxError: Identifier ‘baz’ has already been declared
```

`let` отличается от const тем, что изменять значение `const` нельзя.

```js
// Это нормально.
let foo = "foo";
foo = "bar";
// Это вызывает исключение.
const baz = "baz";
baz = "qux";
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

## 104. В чем разница между классом в ES6 и функцией-конструктором в ES5?

Для начала посмотрим на примеры:

```js
// ES5 функция-конструктор
function Person(name) {
  this.name = name;
}
// ES6 класс
class Person {
  constructor(name) {
    this.name = name;
  }
}
```

Они выглядят довольно похоже, если рассматривать простые конструкторы.
Основное отличие в конструкторе возникает при использовании наследования. Если мы хотим создать класс `Student` (который будет являться подклассом класса `Person`) и добавить поле `studentId`, то, в дополнение к вышеописанному, мы должны сделать следующее:

```js
// ES5 функция-конструктор
function Student(name, studentId) {
  // Вызов конструктора суперкласса для инициализации производных от суперкласса членов.
  Person.call(this, name);
  // Инициализация собственных членов подкласса.
  this.studentId = studentId;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
// ES6 класс
class Student extends Person {
  constructor(name, studentId) {
    super(name);
    this.studentId = studentId;
  }
}
```

Наследование в синтаксисе ES5 является намного более многословным, а в ES6 более понятное и усваиваемое.

Ссылки

- https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance
- https://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5

---

## 105.Можете ли вы привести пример использования стрелочных функции `=>`? Чем они отличаются от других функций?

Одним очевидным преимуществом стрелочных функций является упрощение синтаксиса, необходимого для создания функций, без необходимости использования ключевого слова `function`. `this` внутри стрелочных функций также привязано к замыкающей области видимости, в отличие от обычных функций, где `this` определяется контекстом, в котором они вызываются. Лексически привязанное `this` полезно при вызове `callback`-функций, особенно в компонентах React.

---

## 106. В чем преимущество использования стрелочных функций для метода в конструкторе?

Основным преимуществом использования стрелочной функции в качестве метода внутри конструктора является то, что значение `this` устанавливается во время создания функции и не может измениться после этого. Таким образом, когда конструктор используется для создания нового объекта, `this` всегда будет ссылаться на этот объект. Например, допустим, у нас есть конструктор `Person`, который принимает имя - `name` в качестве аргумента, имеет два метода для вывода в консоль этого имени, один в качестве обычной функции, а другой в качестве стрелочной:

```js
const Person = function(firstName) {
  this.firstName = firstName;
  this.sayName1 = function() { console.log(this.firstName); };
  this.sayName2 = () => { console.log(this.firstName); };
};
const john = new Person(‘John’);
const dave = new Person(‘Dave’);
john.sayName1(); // John
john.sayName2(); // John
// У обычной функции значение `this` может быть изменено, но у стрелочной функции нет
john.sayName1.call(dave); // Dave (потому что ‘this’ сейчас ссылается на объект dave)
john.sayName2.call(dave); // John
john.sayName1.apply(dave); // Dave (потому что ‘this’ сейчас ссылается на объект dave)
john.sayName2.apply(dave); // John
john.sayName1.bind(dave)(); // Dave (потому что ‘this’ сейчас ссылается на объект dave)
john.sayName2.bind(dave)(); // John
var sayNameFromWindow1 = john.sayName1;
sayNameFromWindow1(); // undefined (потому что ‘this’ сейчас ссылается на объект window)
var sayNameFromWindow2 = john.sayName2;
sayNameFromWindow2(); // John
```

Смысл заключается в том, что `this` можно изменить для обычной функции, но для стрелочных функций контекст всегда остается неизменным. Поэтому, даже если вы передаете стрелочную функцию в разные части вашего приложения, вам не нужно беспокоиться об изменении контекста.

Это может быть особенно полезно в классовых React-компонентах. Если вы определяете метод класса для чего-то такого, как обработчик клика, используя обычную функцию, а затем передаете этот обработчик в дочерний компонент в качестве `prop`, вам также необходимо привязать `this` в конструкторе родительского компонента , Если вместо этого вы используете стрелочную функцию, то нет необходимости привязывать `this`, так как метод автоматически получит свое значение `this` из замыкающего лексического контекста. (Прочитайте эту статью о стрелочных функциях: [https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb](https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb))

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
- https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb

---

## 107.Дайте определение функции высшего порядка

Функция высшего порядка — это любая функция, которая принимает одну или несколько функций в качестве аргументов, которые она использует для работы с данными и/или возвращает функцию в качестве результата.

Функции высшего порядка предназначены для абстрагирования некоторой операции, которая выполняется повторно. Классическим примером является метод `map`, который принимает массив и функцию в качестве аргументов.

Затем `map` использует эту функцию для преобразования каждого элемента в массиве, возвращая новый массив с преобразованными данными.

Другими популярными примерами в JavaScript являются `forEach`, `filter` и `reduce`. Функции высшего порядка используют не только для манипуляций с массивами, но также и для возврата функции из другой функции, например при использовании `Function.prototype.bind`.

#### Map

Допустим, у нас есть массив с именами, которые нам нужны о преобразовать в верхний регистр.

```js
const names = ["irish", "daisy", "anna"];
```

Императивное решение будет выглядеть так:

```js
const transformNamesToUppercase = function (names) {
  const results = [];
  for (let i = 0; i < names.length; i++) {
    results.push(names[i].toUpperCase());
  }
  return results;
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
```

Воспользууемся `.map(transformerFn)`, чтобы сделать код декларативным и более коротким:

```js
const transformNamesToUppercase = function (names) {
  return names.map((name) => name.toUpperCase());
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
```

Ссылки

- https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99
- https://hackernoon.com/effective-functional-javascript-first-class-and-higher-order-functions-713fde8df50a
- https://eloquentjavascript.net/05_higher_order.html

---

## 108. Можете ли вы привести пример деструктуризации объекта или массива?

Деструктуризация — это выражение, доступное в ES6, которое предоставляет краткий и удобный способ извлекать значения из объектов или массивов и помещать их в отдельные переменные.

#### Деструктуризация массива

```js
// Присваивание переменной
const foo = [‘one’, ‘two’, ‘three’];
const [one, two, three] = foo;
console.log(one); // “one”
console.log(two); // “two”
console.log(three); // “three”
// Перестановка переменных местами
let a = 1;
let b = 3;
[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
```

#### Деструктуризация объекта

```js
// Присваивание переменной
const o = { p: 42, q: true };
const { p, q } = o;
console.log(p); // 42
console.log(q); // true
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
- https://ponyfoo.com/articles/es6-destructuring-in-depth

---

## 109. Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?

Шаблонные строки помогают упростить написание строк и делают возможным включение переменных в строку. До ES2015 писали так:

```js
var person = { name: ‘Tyler’, age: 28 };
console.log('Hi, my name is ' + person.name + ' and I am ' + person.age + ' years old!');
// ‘Hi, my name is Tyler and I am 28 years old!’
```

С приходом шаблонных строк в ES6 стало намного проще:

```js
const person = { name: ‘Tyler’, age: 28 };
console.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);
// ‘Hi, my name is Tyler and I am 28 years old!’
```

Обратите внимание, что для шаблонных строк используются обратные кавычки, а не простые. Переменные добавляются в подстановки `${}`, обозначаемые знаком доллара и фигурными скобками.

Второй пример использования заключается в создании многострочных литералов. До ES2015 перенос осуществлялся следующим образом:

```js
console.log("This is line one.\nThis is line two.");
// This is line one.
// This is line two.
```

Или же, чтобы не приходилось прокручивать длинную строку в текстовом редакторе, можно было разбить код на несколько строк в коде, таким образом:

```js
console.log("This is line one.\n" + "This is line two.");
// This is line one.
// This is line two.
```

Однако шаблонные строки сохраняют любой интервал, который вы добавляете к ним. Например, чтобы создать тот же многострочный литерал, который мы создали выше, вы можете просто написать:

```js
console.log(`This is line one.
This is line two.`);
// This is line one.
// This is line two.
```

Еще одним вариантом использования шаблонных строк будет использование в качестве замены библиотек шаблонизации для интерполяции переменных:

```js
const person = { name: "Tyler", age: 28 };
document.body.innerHTML = `
  <div>
    <p>Name: ${person.name}</p>
    <p>Name: ${person.age}</p>
  </div>`;
```

**Обратите внимание, что ваш код может быть восприимчив к XSS при использовании `.innerHTML`. Очищайте ваши данные перед отображением, если они получены от пользователя!**

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals

---

## 110. Можете ли вы привести пример каррированной функции (`curry function`) и в чем их преимущество?

Каррирование — это паттерн, где функция с более чем одним параметром разбивается на несколько функций, которые при последовательном вызове будут накапливать все необходимые параметры по одному. Этот метод может быть полезен для облегчения чтения и написания кода, написанного в функциональном стиле. Важно отметить, что каррированная функция должна начинаться как одна функция, а затем разбиваться на последовательность функций, каждая из которых принимает один параметр.

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }
  function _curried(depth, args) {
    return function(newArgument) {
      if (depth — 1 === 0) {
        return fn(…args, newArgument);
      }
      return _curried(depth — 1, […args, newArgument]);
    };
  }
  return _curried(fn.length, []);
}
function add(a, b) {
  return a + b;
}
var curriedAdd = curry(add);
var addFive = curriedAdd(5);
var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

Ссылки

- https://hackernoon.com/currying-in-js-d9ddc64f162e

---

## 111. В чем преимущества использования `spread` оператора и чем он отличается от `rest` оператора?

`Spread` оператор синтаксиса ES6 очень полезен при написании кода в функциональном стиле, поскольку мы можем легко создавать копии массивов или объектов, не прибегая к `Object.create`, `slice` или функции библиотеки. Эта языковая функция часто используется в проектах с Redux и rx.js.

```js
function putDookieInAnyArray(arr) {
  return […arr, ‘dookie’];
}
const result = putDookieInAnyArray([‘I’, ‘really’, “don’t”, ‘like’]); // [“I”, “really”, “don’t”, “like”, “dookie”]
const person = {
  name: ‘Todd’,
  age: 29,
};
const copyOfTodd = { …person };
```

В свою очередь, `rest` оператор синтаксиса ES6 позволяет в сокращенном виде указывать неопределенное количество аргументов, передаваемых в функцию. Можно сказать, что он противоположен `spread` оператору: собирает данные и добавляет их в массив, вместо разделения массива данных. Он используется в аргументах функций, а также при деструктуризации массивов и объектов.

```js
function addFiveToABunchOfNumbers(…numbers) {
  return numbers.map(x => x + 5);
}
const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]
const [a, b, …rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]
const { e, f, …others } = {
  e: 1,
  f: 2,
  g: 3,
  h: 4,
}; // e: 1, f: 2, others: { g: 3, h: 4 }
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

---

## 112.Каким образом можно обмениваться кодом между файлами?

Это зависит от среды выполнения JavaScript.

На клиенте (в среде браузера), пока переменные/функции объявлены в глобальной области видимости (`window`), все скрипты могут на них ссылаться. В качестве альтернативы, используйте `Asynchronous Module Definition` (AMD) через `RequireJS` для модульного подхода.

На сервере (Node.js) обычно используется `CommonJS`. Каждый файл считается модулем, и он может экспортировать переменные и функции, добавляя их к объекту `module.exports`.

ES2015 позволяет использовать модульный синтаксис, который призван заменить как `AMD`, так и `CommonJS`. В конечном итоге он будет поддерживаться как в браузере, так и в Node.

Ссылки

- http://requirejs.org/docs/whyamd.html
- https://nodejs.org/docs/latest/api/modules.html
- http://2ality.com/2014/09/es6-modules-final.html

---

## 113. Для чего используются статические члены класса?

Члены статических классов (свойства/методы) не привязаны к конкретному экземпляру класса и имеют одинаковое значение вне зависимости от того, какой экземпляр ссылается на них. Статические свойства обычно являются конфигурационными переменными, а статические методы обычно являются чисто служебными функциями, которые не зависят от состояния экземпляра.

Ссылки

- https://stackoverflow.com/questions/21155438/when-to-use-static-variables-methods-and-when-to-use-instance-variables-methods

---

---

# Часто задаваемые вопросы на интервью по ES6

<p align="center">
<img src="img/es6-blitx-50.jpg" alt="logo-es6-blitz-poll">
</p>

## 1. Что такое ES6?

- ES6 также известен как ECMAScript 2015.
- ES6 или ECMAScript 2015 является 6-ым основным выпуском ECMAScript.
- Если ваш браузер не поддерживает ES6, вы можете написать совместимый код ES6, используя Babel и Webpack.
- ES10 (ECMAScript 2019) - это последняя версия ECMAScript.

---

## 2. Что такое ECMAScript?

ECMAScript - это спецификация, определенная в стандарте ECMA-262 для создания языка сценариев общего назначения.

---

## 3. Что такое JavaScript?

Язык сценариев общего назначения, соответствующий спецификации ECMAScript.

---

## 4. Что такое JavaScript Engine?

Программа или интерпретатор, который понимает и выполняет код JavaScript.

Самый популярный движок JavaScript:

- Google Chrome - V8 // Fastest JavaScript Engine
- Mozilla FireFox - SpiderMonkey
- Microsoft Edge - Chakra

---

## 5. Что такое Babel?

- Babel - один из самых популярных javascript-транспортеров.
- Babel в основном используется для преобразования кода ES6 + (ECMAScript 2015+) в обратно совместимую версию JavaScript, которая может быть запущена старыми механизмами JavaScript.

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6.html

---

## 6. Что такое Webpack?

- Webpack позволяет запускать среду, в которой работает Babel.
- Webpack - это пакет модулей javascript с открытым исходным кодом, который принимает модули с зависимостями и генерирует статические ресурсы, представляющие эти модули.

**Преимущества использования Webpack:**

1. Он объединяет несколько ваших модулей и упаковывает их в один файл `.js`.
2. Он поставляется с интегрированным сервером разработки. Небольшое экспресс-приложение для локальной разработки. Вы просто включаете один тег Javascript, указывающий на сервер, например `localhost: 8080 / assets / bundle.js`, и получаете бесплатное обновление кода и управление ресурсами.

---

## 7. Перечислите некоторые новые функции в ES6?

**Новые функции в ES6:**
Лучшие 10 функций ES6, которые должен знать каждый разработчик JavaScript.

- а). `Let` и `Const` ключевые слова
- b). `Arrow functions` - стрелочные функции
- c). `Template Literals` - шаблонные литералы
- d). `Object Literals` - литералы объекта
- e). `Default Parameters` - параметры по умолчанию
- f). `Destructuring Assignment` - деструктурирующее присваивание
- g). `Rest and Spread Operators` - операторы rest и spread
- h). `Modules`, `Classes`, `Iterators`, `Generators` in ES6 - Модули, классы, итераторы и генераторы
- i). `Promises` in ES6 -Обещания
- j). `Support for Map/Set & WeakMap/WeakSet`

---

## a). `let` и `const`:

**`Const` Ключевое слово**:

- Ключевое слово `const` используется для определения констант в ES6.
  это также известно как неизменяемые переменные.
- Значение константы **не может** быть изменено путем переназначения, и оно **не может** быть повторно объявлено.

```js
const MY_CONST = "Javascript ES6 Interview Questions";
console.log(MY_CONST);
//Javascript ES6 Interview Questions
MY_CONST = "ES6 Interview Questions";
console.log(MY_CONST);
// Uncaught TypeError: Присвоение постоянной переменной,
// потому что мы не можем переназначить новое значение константе
```

В случае `Object` и `Array` мы можем добавить в него новые элементы

```js
const myObject = { name: "Full Stack Tutorials" };
// Если вы попытаетесь
// перезаписать / переназначить / переопределить объект,
//  выдается ошибка.

myObject = { name: "Full Stack Tutorials" };
//Uncaught TypeError: Присвоение постоянной переменной.
myObject = { fullname: "Full Stack Tutorials" };
//Uncaught TypeError: Присвоение постоянной переменной..

// Поскольку ключи объектов не защищены,
//  приведенный ниже код будет успешно выполнен.
myObject.name = "Anonymous User";
// Вы можете использовать Object.freeze (),
// чтобы сделать объект неизменным

const myArray = ["Javascript", "Node.js", "React.js"];
// Можно помещать элементы в массив
myArray.push("jQuery");
// Но присвоение нового массива той же переменной
// приведет к ошибке.

myArray = ["jQuery"];
//Uncaught TypeError: Присвоение постоянной переменной.
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-let-ii.html
- https://abcinblog.blogspot.com/2018/09/es6-const-let-variii.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md
- https://abcinblog.blogspot.com/2018/05/es6-1.html

`Object.freeze()`

> `Object.freeze` работает со значениями и делает объект неизменным.

_`Object.freeze ()` принимает объект в качестве аргумента и возвращает тот же объект, что и неизменный объект_

Как только вы заморозили объект, вы не можете изменять, добавлять или удалять свойства объекта, но вы можете назначить другой экземпляр.

```js
const myObject = { name: "Full Stack Tutorials" };
Object.freeze(myObject);
myObject.name = "Anonymous User";
// выдает ошибку в строгом режиме
console.log(myObject.name);
// Выведет: Full Stack Tutorials
```

**`let` ключевое слово**:
ES6 представляет новое ключевое слово `let`, которое позволяет нам объявлять локальные переменные в области видимости блока.

Позволяет вам объявлять переменные, которые ограничены по видимости блоком, оператором или выражением, в котором они используются.

```js
let a = 10;
funtion testMe(){
	let a = 20;
	console.log(a); // 20
}
console.log(a); // 10

```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-let-ii.html
- https://abcinblog.blogspot.com/2018/09/es6-const-let-variii.html

---

## b). Функции стрелки:

- Функция стрелки имеет более короткий синтаксис, чем обычная функция.
- Можно считать, что в функции Arrow `this` ключевого слова не существует. Более подробно - см. "Общие вопросы по JS"

```js
(param1, param2, …, paramN) => {
//statements or code
}
```

```js
//in ES5
var sum = function(a, b) {
return a + b;
};
console.log(sum(10,40)); // 50

----------------------------
//in ES6
var total = (x, y) => {
	return (x + y);
}
console.log(total(20,30)); // 50
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-xi.html
- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## c). `Template literals` - Шаблонные литералы:

ES6 представляет новые и простые в использовании строковые шаблоны с заполнителями для переменных.

- Шаблонные литералы заключены в обратную кавычку (русская буква "ё" в английской раскладке) (``).
- Вы можете использовать многострочные строки.
- Вы можете использовать новый синтаксис `$ {variable_name}` внутри строки, помеченной галочкой.
- До ES6 это называлось `Template Strings`.

```js
//Пример-1

var num1 = 10;
var num2 = 20;
console.log(`The sum of ${num1} and ${num2} is ${num1 + num2}.`);

//Выведет: The sum of 10 and 20 is 30

//Пример-2

var TempBody = `Hello Users! Your are reading about ES6 Features,
    In ES6, you are implementing Template Literals.
    Let me show you the sum of ${num1} and ${num2} is ${num1 + num2}. 
	Hope you have understood the concept of Template Literals.`;

console.log(TempBody);
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-template-strings-v.html
- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## d). `Object literals`:

Объектный литерал JavaScript представляет собой разделенный запятыми список пар имя-значение, заключенных в фигурные скобки.

```js
var myObject = {
  title: "ES6 Interview Questions and Answers",
  topic: "Object Literals",
  status: true,
  myFunction: () => {
    // Блок кода
  },
};
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-viii.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part2.md

---

## e). `Default Parameters`:

Параметры функции по умолчанию позволяют инициализировать именованные параметры с некоторыми значениями по умолчанию, если значение не передано или не определено.

```js
//3-й параметр имеет значение по умолчанию ноль.

let addNumbers = (a, b, c = 0) => {
  return a + b + c;
};

console.log(addNumbers(1, 2, 2)); //5
console.log(addNumbers(5, 20)); //25
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-vi.html

---

## f). `Destructuring Assignment`:

Деструктурирующее присваивание - это специальный синтаксис, который позволяет вам «распаковывать» массивы или объекты в кучу переменных, так как иногда они более удобны.

```js
// у нас есть массив с именем, отчеством и фамилией
let arr = ["Full", "Stack", "Tutorials"];

// destructuring assignment
let [first_name, middle_name, last_name] = arr;

console.log(first_name); // Full
console.log(middle_name); // Stack
console.log(last_name); // Tutorials
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-xii.html
- https://abcinblog.blogspot.com/2018/09/es6-xiii.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## g).`REST` and `Spread` operator:

Оператор спреда, или три точки, (`…`) - это новый оператор, введенный в ES6. Это позволяет расширять итерируемый объект (например, Array) на составляющие его элементы.

```js
const t = [1, 2, 3];

const s = [...t, 4, 5, 6];

console.log(s);
// [1, 2, 3, 4, 5, 6];
```

Подробне:

- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://abcinblog.blogspot.com/2018/09/es6-spread-operator-iv.html

**Пример: - Удалить дубликаты элементов из массива с помощью ES6 `Set`?**

> Объект `Set` позволяет хранить уникальные значения любого типа, будь то примитивные значения или объект

Вот одна строка для удаления дубликатов из массива. (ES6, конечно!)

```js
const numbers = [1, 2, 3, 4, 5, 5, 5, 5, 5, 5];

function removeDuplicates(array) {
  return [...new Set(array)];
}
console.log(removeDuplicates(numbers));
// [1, 2, 3, 4, 5]
```

Набор - `Set` был введен в ES6 и похож на наборы, с которыми мы сталкиваемся в математике: они не могут иметь дубликаты. После этого мы просто конвертируем `Set` обратно в массив, используя оператор распространения - `...`.

Подробне:

- https://abcinblog.blogspot.com/2018/05/es6-1.html

---

## h). `Class` In ES6:

```js
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  getUserDetails() {
    console.log(this.name + " is " + this.age + " years old!");
  }
}

var userObj = new User("Full Stack Tutorials", 5);
console.log(userObj.getUserDetails());

//Вывод: Full Stack Tutorials is 5 years old!
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-ix.html
- https://abcinblog.blogspot.com/p/blog-page_15.html#jsphp
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

**Генераторы**

Генератор - это функция, которая может остановиться на полпути, а затем продолжить с того места, где остановилась. Короче говоря, генератор выглядит как функция, но ведет себя как итератор.

```js
function* process() {
  console.log("Start process 1");
  console.log("Pause process2 until call next()");

  yield;

  console.log("Resumed process2");
  console.log("Pause process3 until call next()");

  yield;

  console.log("Resumed process3");
  console.log("End of the process function");
}

let _process = process();
```

**yield**:

- Ключевое слово `yield` просто помогает приостановить и возобновить функцию в любое время асинхронно.
- Кроме того, это помогает вернуть значение из функции генератора.

**в использовании**

- Ленивая оценка -`Lazy evaluation`
- Бесконечные последовательности - `Infinite sequences`
- Асинхронные потоки управления - `Asynchronous control flows`

---

## i). `Promise`:

> Обещания используются для обработки асинхронных операций в JavaScript.

Обещание - это объект, который может быть возвращен синхронно из асинхронной функции.

Обещание преодолеть проблему ада обратного вызова - **callback hell**.

**Promise States**:

- `Fulfilled`:будет вызвано `onFulfilled ()` (например, `resolve()` - разрешено был вызван)
- `Rejected`: отклонено - вызывается `onRejected ()` (например, вызывается `reject ()`).
- `Pending`: ожидание - исходное состояние, не выполнено и не отклонено.

Promise Consumers: `then`, `catch`, `finally`

```js
var promise = new Promise(function (resolve, reject) {
  const A = "fullstacktutorials";
  const B = "fullstacktutorials";
  if (A === B) {
    resolve();
  } else {
    reject();
  }
});

promise
  .then(function () {
    console.log("Success, Your promise has been resolved successfully");
  })
  .catch(function () {
    console.log("Something went wrong!");
  });
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-promise-xiv-1.html
- https://abcinblog.blogspot.com/2018/09/es6-promisesxiv-2.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part3.md

---

## j). Map:

Объект Map представляет собой простую карту - ключ / значение.

Любое значение (как объекты, так и примитивные значения) может использоваться в качестве ключа или значения. Синтаксис [ключ, значение].

```js
hash = new Map();
hash.set(
  "FullStackTutorials",
  "Learn Full Stack Tutorials free Online, Javascript ES6 Interview Questions"
);
hash.set(1, 200);

console.log(hash);
//Output: Map(2) {"FullStackTutorials" =>
// "Learn Full Stack Tutorials free Online, Javascript ES6 Interview Questions",
//  1 => 200}
```

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-3.html

---

## 8. Разница между функцией стрелки и обычной функцией в JavaScript?

Существуют следующие различия между функцией стрелки и обычной (обычной) функцией:

**1. Syntax:**
И Стрелка, и Нормальная (Обычная) функция имеют разный синтаксис.

```js
//Normal Function:

let func = function myFunc(params) {
  // body of the function
};

OR;

function myFunc(params) {
  // body of the function
}
```

```js
//Arrow Function:

let func = (params) => {
  // body of the function
};
```

**2. Использование `this` ключевого слова:**

> В функциях Arrow нет привязки `this`

В отличие от обычных функций, функции стрелок не имеют своего собственного `this`.

```js
let myFunc = {
  name: "Full Stack Tutorials",
  arrowFunc: () => {
    console.log(`Welcome to, ${this.name}`);
    // no 'this' binding
  },
  regFunc() {
    console.log(`Welcome to, ${this.name}`);
    // 'this' binding works
  },
};
myFunc.arrowFunc();
myFunc.regFunc();
```

**3. Используя `new` ключевое слово:**
Функции со стрелками нельзя использовать как конструктор с `new`, это вызовет ошибку.

```js
let myFunc = () => {};
let func = new myFunc();
// Uncaught TypeError: myFunc is not a constructor
```

**4. Наличие объекта аргументов:**
Функции стрелок не имеют своих собственных объектов аргументов. Следовательно, arguments - это просто ссылка на аргументы внутренней области.

**5. Использование свойства прототипа:**
Функции стрелок не имеют свойства прототипа.

```js
let myFunc = () => {};
console.log(myFunc.prototype);
// undefined
```

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md
- https://abcinblog.blogspot.com/2018/09/es6-xi.html

---

## 9. Как бы вы фильтровали массив объектов в ES6?

```javascript
var testArray = [
  { name: "Jai", age: 26 },
  { name: "Shiv", age: 22 },
  { name: "Anuj", age: 5 },
  { name: "Jenny", age: 20 },
];
var data = testArray.filter((person) => person.age > 18);
//Filters the Array of Objects to condition set
console.log(data);
/*
0:{name: "Jai", age: 26}
1:{name: "Shiv", age: 22}
2:{name: "Jenny", age: 20}
length:3
*/
```

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-3.html
- https://abcinblog.blogspot.com/2019/01/js-es6-arrays.html

---

## 10. Что вы подразумеваете под IIFE - `Immediately Invoked Function Expressions`(выражениями с немедленным вызовом функций)?

Выражения IIFE или немедленно вызванные функции - это выражения, которые выполняются сразу же после его создания. IIFEs используются, чтобы избежать чрезмерного использования глобального пространства имен, потому что все переменные, которые используются внутри IIFE, не могут быть просмотрены вне его области. Другими словами, IIFE - это шаблоны проектирования, также известные как самоисполняющиеся анонимные функции (Self Executing Anonymous Functions), поскольку они выполняются самостоятельно.

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part3.md

---

## 11. Объясните, почему следующее не работает как `IIFE`. Что нужно изменить, чтобы правильно сделать его `IIFE`?

```js
function foo(){ }();
```

IIFE расшифровывается как выражения для немедленного вызова функций (Immediately Invoked Function Expressions). Парсер JavaScript читает `function foo () {} ();` as `function foo () {}` и `();` где первая часть - это объявление функции, а вторая (пара скобок) - попытка вызова функции, но имя функции не указано, поэтому он выбрасывает `Uncaught SyntaxError: Unexpected token` Неожиданный токен ).

Вот два способа исправить это, которые включают добавление дополнительных скобок: `(function foo () {}) ()` и `(function foo () {} ())`. Эти функции не отображаются в глобальной области видимости, и вы можете даже опустить ее имя, если вам не нужно, чтобы она ссылалась на саму себя внутри тела.

Вы также можете использовать оператор `void`: `void function foo () {} ();`. К сожалению, с таким подходом есть одна проблема. Оценка данного выражения всегда не определена - `undefined`, поэтому, если ваша функция IIFE возвращает что-либо, вы не можете ее использовать. Пример:

```js
// Don't add JS syntax to this code block to prevent Prettier from formatting it.
const foo = void (function bar() {
  return "foo";
})();

console.log(foo); // undefined
```

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part3.md

---

## 12. Объясните мотивацию использования `Simbols` в ES6.

Символы - `Simbols` представляют собой особый вид объекта, недавно добавленный в шестую версию ECMAScript, который можно использовать в качестве уникального имени свойства в объектах. Использование Symbol вместо String (как это было в предыдущих версиях) позволяет программисту использовать разные модули, которые могут создавать свойства, которые не будут проблематичными друг для друга. Другим огромным преимуществом Символов является то, что они могут быть приватными, и к определенным свойствам не может получить доступ ни один пользователь или разработчик, не имеющий прямого доступа к `Simbols`. Они состоят из функции, которую можно использовать для создания разных символов, которые могут работать по-разному. Но у них нет буквального синтаксиса, в отличие от других примитивов JavaScript.

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-symbols-xv.html

---

## 13. Объясните преимущества использования `spread` syntax (синтаксиса распространения) в ES6. Чем он отличается от остального синтаксиса?

Что касается кодирования в функциональной парадигме, использование spread syntax в ES6 может оказаться весьма полезным. Spread syntax может быть легко использован для создания копий массивов или объектов. Использование распространенного синтаксиса в программе не требует использования `Object.create`, `slice` или какой-либо библиотечной функции. Spread syntax широко используется в проектах Redux и rx.js.

С другой стороны, функция синтаксиса `rest` в ES6 используется для передачи произвольного числа аргументов функции. Это также можно рассматривать как сокращение в программировании на JavaScript. Rest syntax может рассматриваться как противоположность Spread syntax. Он берет данные и помещает их в массив вместо распаковки данных. В дополнение к этому, он работает подходящим образом в аргументах функций, массивах, а также в назначениях деструктурирования объектов.

> Примечание. Этот вопрос задается почти во всех интервью ES6.

Подробнее:

- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://abcinblog.blogspot.com/2018/09/es6-spread-operator-iv.html

---

## 14. Какая разница между ES6 class ES5 function constructors?

| ES6 class                                                                                                                                                                  | ES5 Function Constructors                                                                                                                                          |
| :------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Класс ES6 в основном выполняет работу по определению нового объекта и добавлению функций к его прототипу.                                                                  | ES5 Конструкторы функций работают и выглядят одинаково, но основное различие наблюдается, когда разработчик использует свойство `Inheritance`.                     |
| Их можно рассматривать как основу синтаксиса для функций конструктора.                                                                                                     | Они могут быть выполнены только с помощью нового оператора.                                                                                                        |
| Класс ES6 позволяет разработчикам создавать объекты с помощью оператора `new`.                                                                                             | Конструкторы функций ES5 фокусируются на том, как создаются объекты.                                                                                               |
| Они также гарантируют разработчику, что `this` ключевое слово, которое в основном используется внутри класса, относится только к объекту, который создается разработчиком. | Конструктор функций ES5 фокусируется на реализации кода создания многократно используемых объектов. Любая функция может быть использована в качестве конструктора. |

---

## 15. Разница между `.call` и `.apply`?

| .call                                                                                                                          | .apply                                                                                                                                                            |
| :----------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `.call` используется для вызова функций, и первый параметр станет значением этого значения в функции, созданной разработчиком. | `.apply` также используется для вызова функций, но он принимает массив аргументов. Этот массив работает как следующий аргумент, и функция работает таким образом. |
| `.call` используется для вызова метода, который принимает объект-владелец в качестве аргумента.                                | Метод `.apply` используется для написания методов. Эти методы могут быть использованы для нескольких объектов.                                                    |
| Он принимает два параметра, а именно `objectInstance` и `arguments`.                                                           | Он принимает два параметра, а именно `objectInstance` и `arrayofArguments`.                                                                                       |
| `.call` принимает несколько аргументов, разделенных запятыми.                                                                  | `.apply` принимает несколько аргументов с помощью массива аргументов.                                                                                             |

---

## 16. Объясните причину использования классов ES6.

Классы ES6 оказались очень полезными для разработчиков. Некоторые из основных видов использования классов ES6:

- Классы ES6 имеют более простой и менее подверженный ошибкам синтаксис.
- Что касается настройки иерархий наследования, то ES6 считается наилучшим вариантом, поскольку он использует новый синтаксис со старым синтаксисом, который минимизирует ошибки и облегчает процесс.
- Классы ES6 помогают защитить разработчиков от неправильного использования новых функций с помощью функции конструктора. Это одна из самых распространенных ошибок, возникающих у разработчиков при использовании нового оператора. Классы устраняют эту ошибку, заставляя конструктор генерировать исключение, если это оказывается недопустимым объектом для конструктора.
- Классы также помогают вызывать метод, имеющий версию прототипа. Эта версия намного проще с новым синтаксисом ES6, чем старые версии.

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-ix.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## 17. Что такое `generator` (генератор) в JavaScript?

С запуском ES6 появился новый способ работы с функциями и итераторами. Они называются генераторами. Генератор - это не что иное, как функция, которая может остановиться в тот момент, когда пользователь прикажет ему сделать это, а затем продолжить работу только с того места, где он остановился. Другими словами, генератор имеет свойства функции, но также работает как итератор. Он не работает как другие строки кода, которые необходимо заполнить для выполнения.

Генераторы работают по модели «от завершения к завершению», которая облегчает разработчикам компиляцию программы. Генераторы также могут быть определены как специальный класс функций, которые работают для упрощения задачи кодирования итераторов в программе. Это производит последовательность результатов, а не производит единственное значение. Это позволяет разработчику создавать серию значений одновременно.

> Это очень важный вопрос интервью для javascript ES6.

Подробнее:

- https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Generator

---

## 18. Определить `temporal dead zone` (временную мертвую зону) в ES6.

Временная мертвая зона `temporal dead zone` - может быть определена как промежуток времени, который существует между временем, связанным с привязкой переменной к ее объявлению в программе. Временная мертвая зона существует, так что программные ошибки можно легко идентифицировать как переменную, которая может быть доступна до ее объявления. Также для правильной работы `const` можно использовать временную мертвую зону. Он также используется для защиты JavaScript, который в основном является механизмом, используемым во время выполнения.

Подробнее:

- https://developer.mozilla.org/uk/search?q=temporal+dead+zone

---

## 19. Что такое `spread` -параметр распространения, `default` - по умолчанию и `rest` параметры?

**Spread Operator** - Пожертвовано «...» и сопровождается переменной. Например, синтаксис оператора распространения может выглядеть следующим образом: - «`... X`». Операторы распространения манипулируют объектами и массивами, что является основной причиной его использования в ES6. Он используется для копирования свойства одного объекта другому.
Spread оператор разбивает коллекцию на отдельные аргументы функции, это позволяет вызывать функцию, которая принимает три параметра, с одним параметром.

```js
const day = [2015, 10, 12];
const dayOff = new Date(...day);
let firstArray = [4, 5, 6];
let secondArray = [1, 2, 3, ...firstArray]; // [1,2,3,4,5,6]
```

**Default Operator** (Оператор по умолчанию) - для инициализации функции с использованием значений по умолчанию используется оператор по умолчанию. Значением параметра может быть что угодно - число, функция или null.
Синтаксис похож на другие языки: argumentName = someValue.
`function join(arr,separator=','){ return arr.join(separator)}`

**Rest Parameter** . Этот оператор используется для восстановления всех аргументов, необходимых для вызова функции. Это позволяет нам разделять элементы, принадлежащие к разным категориям. Параметр `rest` позволяет объединить параметры в общий параметр массива.

```js
function push(arr, elem, ...otherElems) {
  arr.push(elem);

  if (otherElems.length) {
    otherElems.forEach((e) => push(arr, e));
  }
}
```

Подробнее:

- https://abcinblog.blogspot.com/2018/09/es6-spread-operator-iv.html
- https://abcinblog.blogspot.com/2018/05/es6-1.html

---

## 20. Что такое `classes` и `proxies`?

**Class** - Вы можете легко использовать шаблоны с объявлением класса на основе ООП. Он легко работает с конструкторами, поддерживает доступ к базовому классу, наследование и статические методы. ООП относится к объектно-ориентированному программированию.

**Proxies**. С помощью прокси вы можете создавать объекты и размещать объекты с огромным разнообразием поведения. Прокси могут также помочь в профилировании и регистрации.
Прокси-это объект, который перехватывает попытки доступа к другому объекту и может изменять их. Синтаксис:

```js
let proxy = new Proxy(target, handler);
```

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy
- https://abc-react.blogspot.com/2018/10/react.html#proxy_component

---

## 21. Когда я должен использовать функции стрелки в ES6?

Сейчас я использую следующее правило для функций в ES6 и более поздних версиях:

- Используйте `function` в глобальной области видимости и для свойств `Object.prototype`.
- Используйте `class` для конструкторов объектов.
- Используйте `=>` везде в осальном.

Зачем использовать функции стрелок почти везде?

- **Scope safety** - Безопасность области: Когда функции стрелок используются последовательно, все гарантированно будет использовать тот же объект `thisObject`, что и корневой. Если даже один стандартный вызов функции смешивается с кучей функций со стрелками, есть вероятность, что область видимости испортится.
- **Compactness** - Компактность: функции со стрелками легче читать и писать. (Это может показаться самоуверенным, поэтому я приведу несколько примеров далее).
- **Clarity** - Ясность: когда почти все является функцией стрелки, любая обычная функция немедленно выделяется для определения области видимости. Разработчик всегда может найти следующий более высокий оператор функции, чтобы увидеть, что это за `thisObject.`

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/when_not_to_use_arrow_functions.md
- https://abcinblog.blogspot.com/2018/05/es6-1.html
- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/es6-part1.md

---

## 22. Когда НЕ следует использовать функции стрелок в ES6? Назовите три или более случаев.

Функции стрелок НЕ должны использоваться:

- Когда мы хотим использовать поднятие функции (hoisting) - так как функции стрелок являются анонимными.
- Когда мы хотим использовать `this` / `arguments` в функции - поскольку функции стрелок не имеют собственных аргументов / arguments, они зависят от своего внешнего контекста.
- Когда мы хотим использовать именованную функцию - в качестве стрелки функции анонимны.
- Когда мы хотим использовать функцию в качестве конструктора - функции стрелок не имеют своих собственных.
- Когда мы хотим добавить функцию как свойство в литерал объекта и использовать в нем объект - так как мы не можем получить к нему доступ (которым должен быть сам объект).

Подробнее:

- https://github.com/YaroslavW/trening-js/blob/master/Texts/ES6/when_not_to_use_arrow_functions.md

---

## 23. Объясните разницу между `Object.freeze ()` и `const`.

`const` и `Object.freeze` - это две совершенно разные вещи.

`const` применяется к привязкам («переменным»). Он создает неизменяемую привязку, то есть вы не можете назначить новое значение привязке.

```js
const person = {
  name: "Leonardo",
};
let animal = {
  species: "snake",
};
person = animal; // ERROR "person" is read-only
```

`Object.freeze` работает со значениями и, более конкретно, со значениями объектов. Это делает объект неизменным, то есть вы не можете изменить его свойства.

```js
let person = {
  name: "Leonardo",
};
let animal = {
  species: "snake",
};
Object.freeze(person);
person.name = "Lima"; //TypeError: Cannot assign to read only property 'name' of object
console.log(person);
```

---

## 24. Объясните `Prototype Design Pattern`.

_Prototype Pattern_ Шаблон прототипа создает новые объекты, но вместо создания неинициализированных объектов он возвращает объекты, инициализированные значениями, которые он скопировал из объекта-прототипа или образца. _Prototype Pattern_ также называется шаблоном Properties (Properties pattern).

Примером использования _Prototype Pattern_ является инициализация бизнес-объектов со значениями, которые соответствуют значениям по умолчанию в базе данных. Объект-прототип содержит значения по умолчанию, которые копируются во вновь созданный бизнес-объект.

Классические языки редко используют Properties pattern, но JavaScript, являющийся языком-прототипом, использует этот шаблон при конструировании новых объектов и их прототипов.

Подробнее:

- https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes
- https://drive.google.com/drive/folders/1MJIG5MUXzz40uSctpPtYlPJz7N9dJ7rw?usp=sharing

---

## 25. Не могли бы вы сравнить использование `Module Pattern` против `Constructor / Prototype pattern`?

Module Pattern - Шаблон модуля обычно используется для пространства имен, где у вас будет один экземпляр, выступающий в качестве хранилища для группировки связанных функций и объектов. Это другой вариант использования, из которого хорошо подходит прототипирование. Они на самом деле не конкурируют друг с другом; вы можете с радостью использовать оба вместе (например, поместить функцию-конструктор внутри модуля и объявить `new MyNamespace.MyModule.MyClass (arguments))`.

Функции-конструкторы и прототипы являются одним из разумных способов реализации классов и экземпляров. Они не совсем соответствуют этой модели, поэтому обычно вам нужно выбрать конкретную схему или вспомогательный метод для реализации классов с точки зрения прототипов.

Подробнее:

- https://drive.google.com/drive/folders/1MJIG5MUXzz40uSctpPtYlPJz7N9dJ7rw?usp=sharing

---

## 26. Каковы предпосылки использования в ES6 `WeakMap` ?

`WeakMaps` предоставляют возможность расширять объекты извне, не мешая сборке мусора. Всякий раз, когда вы хотите расширить объект, но не можете, потому что он запечатан - или из внешнего источника - можно применить WeakMap.

`WeakMaps` доступны только для ES6 и выше. WeakMap - это набор пар ключ-значение, где ключ должен быть объектом.

```js
var map = new WeakMap();
var pavloHero = {
  first: "Pavlo",
  last: "Hero",
};
var gabrielFranco = {
  first: "Gabriel",
  last: "Franco",
};
map.set(pavloHero, "This is Hero");
map.set(gabrielFranco, "This is Franco");
console.log(map.get(pavloHero)); //This is Hero
```

Интересным аспектом `WeakMaps` является тот факт, что он содержит слабую ссылку на ключ внутри карты. Слабая ссылка означает, что если объект будет уничтожен, сборщик мусора удалит всю запись из `WeakMap`, освободив таким образом память.

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap

---

## 27. В чем разница между ES6 `Map` и `WeakMap`?

Они оба ведут себя по-разному, когда объект, на который ссылаются их ключи / значения, удаляется. Давайте возьмем следующий пример кода:

`var map = new Map ();`

`var weakmap = new WeakMap ();`

```js
(function () {
  var a = {
    x: 12,
  };
  var b = {
    y: 12,
  };

  map.set(a, 1);
  weakmap.set(b, 2);
})();
```

Вышеупомянутый IIFE выполняется, и мы больше не можем ссылаться на `{x: 12}` и `{y: 12}`. Сборщик мусора идет вперед и удаляет указатель ключа `b` из «WeakMap», а также удаляет `{y: 12}` из памяти. Но в случае «Map» сборщик мусора не удаляет указатель из «Map», а также не удаляет `{x: 12}` из памяти.

WeakMap позволяет сборщику мусора выполнять свою задачу, но не Map. С картами, написанными вручную, массив ключей будет хранить ссылки на ключевые объекты, предотвращая их сборку мусора. В собственных WeakMaps ссылки на ключевые объекты хранятся «слабо - _weakly_», что означает, что они не предотвращают сборку мусора в случае, если не будет другой ссылки на объект.

Подробнее:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap

---

## 28. Можете ли вы привести пример функции каррирования (curry function) и почему этот синтаксис дает преимущество?

Карринг (каррирование) - это шаблон, в котором функция с более чем одним параметром разбивается на несколько функций, которые при последовательном вызове будут накапливать все необходимые параметры по одному. Этот метод может быть полезен для облегчения чтения и написания кода, написанного в функциональном стиле. Важно отметить, что для функции, которую нужно каррировать, она должна начинаться как одна функция, а затем разбиваться на последовательность функций, каждая из которых принимает один параметр.

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }

  function _curried(depth, args) {
    return function (newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument);
      }
      return _curried(depth - 1, [...args, newArgument]);
    };
  }

  return _curried(fn.length, []);
}

function add(a, b) {
  return a + b;
}

var curriedAdd = curry(add);
var addFive = curriedAdd(5);

var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

Подробнее:

- https://learn.javascript.ru/currying-partials
- https://habr.com/ru/company/ruvds/blog/427295/

---

## 29. Как «заморозить» ("deep-freeze") объект в JavaScript?

Если вы хотите убедиться, что объект глубоко заморожен, вы должны создать рекурсивную функцию для замораживания каждого свойства, имеющего тип объекта:

Без глубокой заморозки (Without deep freeze):

```js
let person = {
  name: "Leonardo",
  profession: {
    name: "developer",
  },
};
Object.freeze(person); // make object immutable
person.profession.name = "doctor";
console.log(person); //output { name: 'Leonardo', profession: { name: 'doctor' } }
```

C deep freeze:

```js
function deepFreeze(object) {
  let propNames = Object.getOwnPropertyNames(object);
  for (let name of propNames) {
    let value = object[name];
    object[name] =
      value && typeof value === "object" ? deepFreeze(value) : value;
  }
  return Object.freeze(object);
}
let person = {
  name: "Leonardo",
  profession: {
    name: "developer",
  },
};
deepFreeze(person);
person.profession.name = "doctor"; // TypeError: Cannot assign to read only property 'name' of object
```

---

---
