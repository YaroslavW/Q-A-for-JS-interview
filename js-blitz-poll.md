# Вопросы по javascript

## 1. Что-такое хэш-таблица?

Хэш-табли́ца или хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

Подробней: https://ru.wikipedia.org/wiki/Хеш-таблица

---

## 2. Что такое web workers и зачем они нужны?

Web Workers предоставляют простое средство для запуска скриптов в фоновом потоке. Поток Worker'а может выполнять задачи без вмешательства в пользовательский интерфейс. К тому же, они могут осуществлять ввод/вывод, используя XMLHttpRequest (хотя атрибуты responseXML и channel всегда будут равны null). Существующий Worker может отсылать сообщения в JavaScript код, который его создал, отправляя сообщения в обработчик событий, указанный этим кодом (и наоборот).

Подробней: https://developer.mozilla.org/ru/docs/DOM/Using_web_workers

---

## 3. Какие ограничения накладываются на поток Web Worker?

Потоки web worker не могут изменять HTML элементы, глобальные переменные и некоторые свойства окон, такие как `window.location`. Вы можете использовать типы данных javascript, вызовы `XMLHttpRequest` и прочее.

---

## 4. Как создать поток web worker в JavaScript?

Подробней:

- https://developer.mozilla.org/ru/docs/DOM/Using_web_workers
- https://habrahabr.ru/post/132785/

---

## 5. Как уничтожить объект web worker?

`w.terminate();`

---

## 6. Зачем в HTML 5 введены события `server-sent`?

Подробней:

- https://ru.wikipedia.org/wiki/Server-sent_events
- https://habrahabr.ru/post/120429/

---

## 7. Что такое неопределенные (`undefined`) и необъявленные (`undeclared`) переменные?

- `undefined` - значение
- `undeclared`- ошибка ReferenceError

Подробней: https://habrahabr.ru/post/159313/

---

## 8.Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.

Подробней

- https://htmlacademy.ru/blog/195-lets-learn-javascript-closures
- https://habrahabr.ru/post/38642/

---

## 9.Объясните "JavaScript module pattern" и где он (паттерн) применяется?

Первостепенная задача не засорять пространство имен, но с модульностью ES2015 как таковая необходимость отпала.

## Вторстепенная задача классическое ООП. Публичные члены класса доступны всем, приватные только самому классу. В первой части есть ссылка на реальный пример модуля в ts

---

## 10. Как Вы организуете свой код? (module pattern, наследование)?

Подробней: https://habrahabr.ru/post/131714/

---

## 11. В чем разница между host-объектами и нативными объектами?

_Встроенные объекты_: `String`, `Math`, `RegExp`, `Object`, `Function` и т.д. - основные предопределенные объекты, всегда доступные в JavaScript. Определено в спецификации ECMAScript.

_Объекты хоста_: объекты типа `window`, `XmlHttpRequest`, узлы DOM и т.д., которые предоставляются средой браузера. Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста. Если JavaScript работает за пределами браузера, например, на языке сценариев на стороне сервера, например, в Node.js, будут доступны разные объекты хоста.

_Объекты пользователя_: объекты, определенные в JavaScript-коде.

---

## 12.В чем разница между `.call` и `.apply`?

- `.call()` - вызывает ту же функцию с указанными аргументами

* `.apply()` - вызывает ту же функцию с аргументами, указанными в массиве

* `.bind()` - создает новую функцию с тем же самым телом функции с заданным значением `this` (первый аргумент) и возвращает эту функцию.

Во всех случаях первый аргумент используется как значение this внутри функции.

Подробней:

- https://learn.javascript.ru/call-apply
- https://habrahabr.ru/sandbox/33838/

---

## 13.Что делает и для чего нужна функци `Function.prototype.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

Подробней: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

---

## 14. Объясните, как работает наследование в JavaScript?

Модель наследования в JavaScript может озадачить опытных разработчиков на высокоуровневых объектно-ориентированных языках (таких, например, как Java или C++), поскольку она динамическая и не включает в себя реализацию понятия class (хотя ключевое слово `class`, бывшее долгие годы зарезервированным, и приобрело практическое значение в стандарте ES2015, однако, `class` в JavaScript ES>=6 представляет собой лишь "синтаксический сахар" поверх прототипно-ориентированной модели наследования).

В плане наследования JavaScript работает лишь с одной сущностью: объектами. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство `prototype` равно `null`. По определению, `null` не имеет прототипа и является завершающим звеном в цепочке прототипов.

Хотя прототипную модель наследования некоторые относят к недостаткам JavaScript, на самом деле она мощнее классической. К примеру, поверх неё можно предельно просто реализовать классическое наследование, а вот попытки совершить обратное непременно вынудят вас попотеть.

Подробней:

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
- https://learn.javascript.ru/class-inheritance
- https://habrahabr.ru/post/131714/

---

## 15. Расскажите, как работает прототипное наследование

Этот вопрос очень часто задают на собеседованиях. Все объекты в JavaScript имеют свойство `prototype`, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее [делегирование, чем наследование](https://davidwalsh.name/javascript-objects).

Ссылки

- https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson
- https://davidwalsh.name/javascript-objects

---

## 16.Что вы думаете о `AMD` против `CommonJS`?

Оба являются способами реализации системы модулей, которая изначально не присутствовала в JavaScript до появления ES2015. CommonJS является синхронным, в то время как AMD (Asynchronous Module Definition, асинхронное определение модуля) — соответственно, асинхронным. CommonJS разработан с учетом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначена для браузеров.

Я считаю синтаксис AMD довольно многословным, а CommonJS ближе к стилю, который используется в выражениях импорта в других языках. В большинстве случаев я считаю AMD ненужным, потому что если вы разместите весь свой код в одном объединенном файле, то вы не сможете воспользоваться свойствами асинхронной загрузки. Кроме того, синтаксис CommonJS ближе к стилю написания модулей Node, и поэтому происходит меньше путаницы при переключении между клиентской и серверной разработкой на JavaScript.

Я рад, что с появлением модулей ES2015, которые поддерживают как синхронную, так и асинхронную загрузку, мы, наконец, можем придерживаться одного подхода. Несмотря на то, что они не полностью поддерживаются во всех браузерах и Node, мы можем использовать транспайлеры для преобразования нашего кода.

Ссылки

- https://auth0.com/blog/javascript-module-systems-showdown/
- https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs

---

## 17.Объясните, почему это не является IIFE: `function foo(){ }();`. Что необходимо изменить, чтобы это стало IIFE??

IIFE расшифровывается как Immediately Invoked Function Expression — немедленно вызываемое функциональное выражение. Синтаксический анализатор JavaScript читает `function foo(){ } ();` как `function foo(){ }` и `();`, где первое выражение — это объявление функции, а второе (пара скобок) — попытка вызова функции, но так как имя не указано, он выдает ошибку `Uncaught SyntaxError: Unexpected token`.

Вот два способа исправить это, которые заключаются добавление дополнительных скобок: `(function foo(){ })()` и `(function foo(){ }())`. Выражения, начинающиеся с `function`, считаются **объявлениями функций**. Оборачивая эту функцию внутри`()`, она становится **функциональным выражением**, которое затем может быть выполнено с последующим `()`. Подобные функции не отображаются в глобальной области видимости, и вы можете даже не указывать им имя, если вы не будете на них ссылаться.

Вы также можете использовать оператор `void` — `void function foo(){ }()`. К сожалению, с таким подходом есть одна проблема. Выполнение данного выражения всегда возвращает `undefined`, поэтому, если ваше IIFE возвращает что-либо, вы не можете его использовать. Пример:

```js
const foo = void function bar() { return ‘foo’; }();
console.log(foo); // undefined
```

Ссылки

- http://lucybain.com/blog/2014/immediately-invoked-function-expression/
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void

---

## 18.В чем различие между переменными, значение которых: `null`, `undefined` и не объявлено? Как бы вы проверили их на каждое из этих значений?

**Необъявленные** переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`, `let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок`try/catch`.

```js
function foo() {
  x = 1; // ReferenceError в строгом режиме
}
foo();
console.log(x); // 1
```

Переменная `undefined` — это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Чтобы проверить это, сравните, используя оператор строгого равенства (`===`) или `typeof`, который вернет строку `undefined`. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет `true`, если значение равно `null`.

```js
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === ‘undefined’); // true
console.log(foo == null); // true. Неправильно, не используйте это для проверки!
function bar() {}
var baz = bar();
console.log(baz); // undefined
```

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (`==`) для проверки, так как он также вернет `true`, если значение равно `undefined`.

```js
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === ‘object’); // true
console.log(foo == undefined); // true. Неправильно, не используйте это для проверки!
```

Личная привычка — я никогда не оставляю свои переменные необъявленными или неприсвоенными. Я явно назначаю им null после объявления, если я не собираюсь их пока использовать. Если вы используете линтер в своем рабочем процессе, он обычно также проверяет, что вы не ссылаетесь на необъявленные переменные.

Ссылки

- https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables
- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined

---

## 19.Что такое замыкание и как/для чего его используют?

Замыкание — это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово “лексический” относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна. Замыкания — это функции, которые имеют доступ к переменным внешней (замыкающей) функции — цепочке областей видимости даже после того, как внешняя функция вернулась.

### Для чего его используют?

- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий. Обычно используется в [модульном паттерне](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript).

- [Частичное применение функций или каррирование.](https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8)

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
- https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36

---

## 20. Можете ли вы описать основное различие между циклом `.forEach` и циклом `.map()`? И в каких случаях каждый из них используется?

Чтобы понять разницу между ними, давайте посмотрим, что делает каждая функция.

### forEach

- Перебирает элементы в массиве.
- Вызывает `callback-функцию` для каждого элемента.
- Не возвращает значение.

```js
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  // Делаем что-либо с num и/или index.
});
// doubled = undefined
```

### map

- Перебирает элементы в массиве.
- “Сопоставляет” каждый элемент с новым элементом, вызывая функцию для каждого элемента, создавая в результате новый массив.

```js
const a = [1, 2, 3];
const doubled = a.map((num) => {
  return num * 2;
});
// doubled = [2, 4, 6]
```

Основное различие между `.forEach` и `.map()` состоит в том, что `.map()` возвращает новый массив. Если вам нужен результат, но вы не хотите изменять исходный массив, `.map()` — очевидный выбор. Если вам просто нужно перебрать массив, то стоит воспользоваться `forEach`.

Ссылки

- https://codeburst.io/javascript-map-vs-foreach-f38111822c0f

---

## 21. В каких случаях обычно используются анонимные функции?

Они могут использоваться в IIFE для инкапсуляции кода в локальную область видимости, чтобы объявленные в ней переменные не попадали в глобальную область видимости.

```js
(function () {
  // Здесь код функции.
})();
```

Как callback-функция, которая используется один раз и не должна использоваться где-либо еще. Код будет казаться более автономным и читаемым, когда обработчики будут определены прямо внутри вызывающего их кода, а не искать в другом месте, чтобы найти тело функции.

```js
setTimeout(function () {
  console.log("Hello world!");
}, 1000);
```

Аргументы в конструкциях функционального программирования или Lodash (аналогично callback-функциям).

```js
const arr = [1, 2, 3];
const double = arr.map(function (el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]
```

Ссылки

- https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions
- https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo

---

## 22.Как вы организуете свой код? (module pattern, classical inheritance)

В прошлом я использовал Backbone, который поощряет ООП подход, создавая Backbone модели и добавляя к ним методы.
Модульный паттерн до сих пор хорош, но в настоящее время я использую React/Redux, который использует однонаправленный поток данных на основе архитектуры Flux. Я создаю модели своего приложения при помощи простых объектов и пишу чистые функции для управления этими объектами. Состояние управляется при помощью экшенов и редьюсеров, как в любом другом приложении Redux.
Я избегаю использования наследования классов, где это возможно. Если же мне это необходимо сделать, то я придерживаюсь [этих правил](https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4).

---

## 23. В чем разница между host-объектами и нативными объектами?

Нативные объекты — это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript, такие как String, Math, RegExp, Object, Function и т.д.

Хост-объекты предоставляются средой выполнения (браузером или Node), такие как `window`, `XMLHTTPRequest` и т.д.

Ссылки

- https://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects

---

## 24. В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Я полагаю, что суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` — это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает `Person` как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается undefined, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта `Person` с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например: `Object.create(Person.prototype)`.

```js
function Person(name) {
  this.name = name;
}
var person = Person(‘John’);
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: Cannot read property ‘name’ of undefined
var person = new Person(‘John’);
console.log(person); // Person { name: “John” }
console.log(person.name); // “john”
```

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new

---

## 25. В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

```js
function add(a, b) {
  return a + b;
}
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

---

## 26. Что делает и для чего нужна функция `Function.prototype.bind`?

Взято дословно с MDN:

> Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
> По моему опыту, это наиболее полезно для привязки значения this в методах классов, которые вы хотите передать в другие функции. Это часто делается в компонентах React.

Ссылки

- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind

---

## 27. В каких случаях используется `document.write()`?

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает document.open, который очищает весь документ (`<head>`и `<body>` будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

В Интернете есть несколько ответов, которые объясняют, что `document.write()` используется в коде отслеживания или когда вы хотите добавить стили, которые должны работать только при включенном JavaScript. Он даже используется в шаблоне HTML5 для параллельной загрузки скриптов и сохранения порядка выполнения! Тем не менее, я подозреваю, что эти причины могут быть устаревшими, и в наши дни они могут быть достигнуты без использования `document.write()`. Пожалуйста, поправьте меня, если я ошибаюсь по этому поводу.

Ссылки

- https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html
- https://github.com/h5bp/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag

---

## 28.В чем разница между feature detection (определение возможностей браузера), feature inference (предположение возможностей) и анализом строки user-agent?

### Feature detection (определение возможностей браузера)

Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода - и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:

```js
if ("geolocation" in navigator) {
  // Можно использовать navigator.geolocation
} else {
  // Обработка отсутствия возможности
}
```

`Modernizr` - отличная библиотека для обработки таких функций.

### Feature inference (предположение возможностей)

Предположение возможностей проверяет на наличие определенных возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определенная возможность уже существует, например:

```js
if (document.getElementsByTagName) {
  element = document.getElementById(id);
}
```

Этот подход не рекомендуется. Первый подход более надежен.

### Строка User Agent

Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя от которого исходит запрос. Доступ к ней можно получить через `navigator.userAgent`. Тем не менее, строка User Agent сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome, так и Safari. Таким образом, чтобы обнаружить браузер Safari, вы должны проверить на наличие строки Safari и отсутствие строки Chrome. Избегайте этого метода.

Ссылки

- https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection
- https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th
- https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent

---

## 29. Расскажите об Ajax как можно более подробно

Ajax (асинхронный JavaScript и XML) - это набор методов веб-разработки, использующих множество веб-технологий на стороне клиента для создания асинхронных веб-приложений. С помощью Ajax веб-приложения могут отправлять данные на сервер и получать их с сервера асинхронно (в фоновом режиме), не влияя на отображение и поведение открытой страницы. Отделяя уровень обмена данными от уровня представления, Ajax позволяет веб-страницам и, в частности, веб-приложениям динамически изменять содержимое без необходимости перезагрузки всей страницы. На практике для получения/передачи данных используется формат данных JSON вместо XML из-за того, что JSON основан на JavaScript.

Раньше для асинхронного взаимодействия использовали `XMLHttpRequest API`, а сейчас принято использовать `fetch API`.

Ссылки

- https://en.wikipedia.org/wiki/Ajax_(programming)
- https://developer.mozilla.org/en-US/docs/AJAX

---

## 30. Какие преимущества и недостатки в использовании Ajax?

### Преимущества

- Повышение интерактивности. Новые данные с сервера могут быть добавлены динамически без перезагрузки всей страницы.

- Сокращение количества подключений к серверу, поскольку скрипты и таблицы стилей нужно запрашивать только один раз.

- Состояние может быть сохранено на странице. Переменные JavaScript и состояние DOM сохраняется, поскольку главная страница контейнера не перезагружается.

- Большая часть преимуществ SPA.

### Недостатки

- Сложнее реализовать добавление динамической веб-страницы в закладки.
- Не работает, если в браузере отключен JavaScript.
- Некоторые поисковые роботы не выполняют JavaScript и не видят данные, загружаемые при помощи JavaScript.
- Большая часть недостатков SPA.
- Объясните, как работает JSONP (и почему это не совсем AJAX)
- `JSONP` (`JSON` с набивкой) - это способ, часто используемый для обхода политики ограничения домена в браузерах, потому что Ajax-запросы с текущей страницы к серверу, находящемуся в другом домене, запрещены.
- `JSONP` работает, отправляя запрос к серверу в другом домене через тег `script` и обычно с параметром запроса callback, например:https://example.com?callback=printData. Затем сервер обернет данные внутри функции с именем printData и вернет их клиенту.
  HTML:

```html
<!-- https://mydomain.com -->
<script>
  function printData(data) {
    console.log(`My name is ${data.name}!`);
  }
</script>
<script src="https://example.com?callback=printData"></script>
```

JS:
// Файл загружен с `https://example.com?callback=printData printData({ name: 'Yang Shun' });`
У клиента должна быть функция `printData` в своей глобальной области видимости, и эта функция будет выполнена клиентом, когда будет получен ответ с сервера из другого домена.
JSONP может быть небезопасным и иметь повышенный риск. Поскольку JSONP - это действительно JavaScript, и он может делать все остальное, что может делать JavaScript, то вы должны быть уверены в надежности поставщика данных JSONP.
В наши дни, CORS является рекомендуемым подходом и JSONP является способом для его обхода.
Ссылки

- https://stackoverflow.com/a/2067584/1751946

---

## 31.Вы когда-нибудь использовали шаблонизацию на JavaScript? Если да, то какие библиотеки вы использовали?

Да. Handlebars, Underscore, Lodash, AngularJS, и JSX. Мне не нравилась шаблонизация в AngularJS, потому что там активно использовались строки в директивах и легко допустить ошибку при опечатке. JSX - мой новый фаворит, так как он ближе к JavaScript и почти не имеет дополнительного синтаксиса. В настоящее время вы даже можете использовать строковые литералы шаблонов ES2015 в качестве быстрого способа создания шаблонов, не полагаясь на сторонний код.

`const template =`<div>My name is: \${name}</div>`;`

Однако следует помнить о возможном XSS в вышеприведенном подходе, поскольку содержимое не экранируется, в отличие от библиотек шаблонизации.

---

## 32 Расскажите, что такое поднятие (`hoisting`)

Поднятие (`hoisting`) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова var, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Однако, "поднимается" только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.
Обратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.
// объявления переменных через var поднимаются.

```js
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1
// объявления переменных через let/const НЕ поднимаются.
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
При объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.
// Объявление функции
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log('FOOOOO');
}
console.log(foo); // [Function: foo]
// Функциональное выражение
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function() {
  console.log('BARRRR');
};
console.log(bar); // [Function: bar]
```

---

## 33.Объясните, что такое всплытие событий (`event bubbling`)

Когда событие срабатывает на элементе DOM, оно попытается обработать событие (если привязан обработчик), затем событие всплывет вверх к своему родителю и это повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть до `document`. Всплытие событий является механизмом, на котором основано делегирование событий.

---

## 34. В чем разница между "атрибутом" (attribute) и "свойством" (property)?

Атрибуты определены в разметке HTML, а свойства определены в DOM. Чтобы проиллюстрировать разницу, представьте, что у нас есть это текстовое поле в HTML:

```js
<input type="text" value="Hello">.
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
```

Но после того, как вы измените значение текстового поля, добавив к нему "`World!`", будет:

```js
`console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
```

Ссылки

- https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html

---

## 34. Почему не следует расширять нативные JavaScript-объекты?

Расширение встроенного/нативног объекта JavaScript означает добавление свойств/функций к его прототипу. Хотя на первый взгляд это может показаться хорошей идеей, на практике это опасно. Представьте, что ваш код использует несколько библиотек, которые расширяют Array.prototype, добавляя один и тот же метод contains. В результате код будет работать неверно, если поведение этих двух методов не будет одинаковым.

Единственный случай, при котором можно расширить нативный объект — это при создании полифила, создав собственную реализацию метода, который является частью спецификации JavaScript, но может отсутствовать в устаревших браузерах.

Ссылки

- http://lucybain.com/blog/2014/js-extending-built-in-objects/

---

## 35. В чем разница между событием `load` и событием `DOMContentLoaded`?

Событие `DOMContentLoaded` вызывается, когда исходный HTML-документ полностью загружен и обработан, не дожидаясь окончания загрузки таблиц стилей, изображений и скриптов.
Событие `load` происходит только после загрузки DOM и всех зависимых ресурсов.

Ссылки

- https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded
- https://developer.mozilla.org/en-US/docs/Web/Events/load

---

## 36. В чем разница между `==` и `===`?

`==` — это оператор абстрактного сравнения, а `===` — оператор строгого сравнения. Оператор `==` будет сравнивать на равенство после выполнения любых необходимых преобразований типов. Оператор `===` не будет выполнять преобразование типов, поэтому, если два значения не одного типа, `===` просто вернет `false`. При использовании `==` могут происходить такие странные вещи, как:

```js
1 == "1"; // true
1 == [1]; // true
1 == true; // true
0 == ""; // true
0 == "0"; // true
0 == false; // true
```

Мой совет — никогда не используйте оператор `==`, за исключением удобного сравнения с `null` или `undefined`, где выражение a `== null` вернет `true`, если a принимает значение `null` или `undefined` .

```js
var a = null;
console.log(a == null); // true
console.log(a == undefined); // true
```

Ссылки

- https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons

---

## 37.Объясните `same-origin policy` в контексте JavaScript

`Same-origin policy` (принцип одинакового источника) не позволяет JavaScript выполнять запросы за границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера порта. Этот принцип не позволяет вредоносному сценарию на одной странице получить доступ к конфиденциальным данным на другой через объектную модель документа этой страницы.

Ссылки

- https://en.wikipedia.org/wiki/Same-origin_policy

---

## 38. Сделайте так, чтобы этот код работал:

```js
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
```

Решение:

```js
function duplicate(arr) {
  return arr.concat(arr);
}
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
```

---

## 39. Почему тернарный оператор так называется?

“Тернарный” означает три. Троичное выражение принимает три операнда: условие, выражение “`then`” и выражение “`else`”. Тернарные операторы не являются исключительными для JavaScript, и я не знаю, почему подобный вопрос был добавлен в этот список.
Ссылки

- https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operat

---

## 40. Что делает строчка “`use strict`”;? Какие достоинства и недостатки от ее использования?

`use strict` это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.

**Преимущества**:

- Не позволяет случайно создавать глобальные переменные.
- Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.
- При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).
- Требует, чтобы имена параметров функции были уникальными.
- `this` в глобальной области видимости равно `undefined`.
- Перехватывает распространенные ошибки, выдавая исключения.
- Исключает неочевидные особенности языка.

**Недостатки**:

- Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.
- Нет доступа к `function.caller` и `function.arguments`.
- Объединение скриптов, написанных в строгом режиме может вызвать проблемы.

В целом, я думаю, что преимущества перевешивают недостатки, и мне никогда не приходилось полагаться на функции, которые заблокированы в строгом режиме. Я бы порекомендовал использовать строгий режим.

Ссылки

- http://2ality.com/2011/10/strict-mode-hatred.html
- http://lucybain.com/blog/2014/js-use-strict/

---

## 41. Напишите цикл, который перебирает числа до `100`, возвращая ”`fizz`” на числа кратные`3`, ”`buzz`” на числа кратные `5` и ”`fizzbuzz`” на числа кратные `3` и `5`.

```js
for (let i = 1; i <= 100; i++) {
  let f = i % 3 == 0,
    b = i % 5 == 0;
  console.log(f ? (b ? "FizzBuzz" : "Fizz") : b ? "Buzz" : i);
}
```

Хотя я бы не советовал вам использовать этот код во время интервью. Просто придерживайтесь длинного, но ясного подхода. Также можете взглянуть на разные безумные реализации FizzBuzz, по ссылке ниже.

Ссылки

- https://gist.github.com/jaysonrowe/1592432

---

## 42. Почему считается хорошим тоном оставить глобальную область видимости (`global scope`) в нетронутом состоянии?

Каждый скрипт имеет доступ к глобальной области видимости, и если каждый будет использовать глобальное пространство имен для определения своих переменных, то могут возникнуть конфликты. Используйте модульный паттерн (используя IIFE) для инкапсуляции ваших переменных в локальное пространство имен.

---

## 43. Для чего используют событие `load`? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?

Событие `load` происходит в конце процесса загрузки документа. На этом этапе все объекты в документе находятся в DOM, и все изображения, скрипты и ссылки загрузились.
Событие DOM `DOMContentLoaded` будет запущено после создания DOM для страницы, но не будет ждать окончания загрузки других ресурсов. Оно предпочтительно в тех случаях, когда вам не нужно загружать страницу целиком перед инициализацией.

Ссылки:

- https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload

---

## 44. Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.

Текст ниже взят из замечательного [руководства по фронтенду от Grab](https://github.com/grab/front-end-guide), который по счастливой случайности тоже был написан мной.
В наши дни веб-разработчики называют свои продукты веб-приложениями, а не веб-сайтами. Хотя между этими двумя терминами нет строгой разницы, веб-приложения, как правило, очень интерактивны и динамичны, что позволяет пользователю выполнять действия и получать мгновенный ответ. Традиционно браузер получает HTML с сервера и отображает его. Когда пользователь переходит на другой URL-адрес, требуется полное обновление страницы, и сервер отправляет свежий HTML-код на новую страницу. Это называется рендерингом на стороне сервера.
Однако в современных SPA вместо этого используется рендеринг на стороне клиента. Браузер загружает начальную страницу с сервера вместе со скриптами (фреймворками, библиотеками, кодом приложения) и таблицами стилей, необходимыми для всего приложения. Когда пользователь переходит на другие страницы, обновление страницы не происходит. URL-адрес страницы обновляется при помощи [HTML5 History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API). Новые данные, необходимые для страницы (обычно в формате JSON), извлекаются браузером посредством запросов [AJAX](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started) к серверу. Затем SPA динамически обновляет страницу данными через JavaScript, которые были получены при начальной загрузке страницы. Эта модель похожа на работу нативных мобильных приложений.

### Преимущества:

- Приложение становится более отзывчивым, и пользователи не видят мерцание при навигации, т.к. страница не обновляется целиком.
- На сервер поступает меньше HTTP-запросов, так как одни и те же ресурсы не нужно загружать снова для каждой загрузки страницы.
- Четкое разделение на клиент и сервер. Вы можете легко создавать новые клиентские приложения для разных платформ (например, для мобильных устройств, чат-ботов, умных часов) без необходимости изменять код сервера. Вы также можете изменить технологический стек на клиенте и сервере независимо, пока между ними существует интерфейс.

### Недостатки:

- Более тяжелая первоначальная загрузка страницы из-за загрузки кода фреймворка, самого приложения и ресурсов.
- Ваш сервер должен быть сконфигурирован так, чтобы он направлял все запросы к единой точке входа, и переложил обязанности по навигации на сторону клиента.
- Для отображения содержимого SPA полагается на JavaScript, но не все поисковые системы выполняют JavaScript во время индексации, и они могут не увидеть содержимое страницы. Это вредит поисковой оптимизации (SEO) вашего приложения. Тем не менее, в большинстве случаев, когда вы создаете приложения, SEO не является наиболее важным фактором, так как не весь контент должен индексироваться поисковыми системами. Чтобы преодолеть это, вы можете либо рендерить свое приложение на стороне сервера, либо использовать такие сервисы, как Prerender, чтобы “рендерить ваш javascript в браузере, сохранять статический HTML и передавать его поисковым роботам”.

Ссылки

- https://github.com/grab/front-end-guide#single-page-apps-spas
- http://stackoverflow.com/questions/21862054/single-page-app-advantages-and-disadvantages
- http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/
- https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52

---

## 45. Насколько вы опытны в работе с промисами (promises) и/или их полифилами?

Обладаю практическими знаниями о них. Промис — это объект, который может вернуть одно значение в будущем: либо выполненное значение, либо причина, по которой оно не было выполнено (например, произошла ошибка сети). Промис может находиться в одном из 3 возможных состояний: выполнено, отклонено или ожидает выполнения. При использовании промисов можно добавлять callback-функции для обработки выполненного значения или причины отказа.
Некоторыми распространенными полифилами являются `$.deferred`, Q и Bluebird, но не все они соответствуют спецификации. ES2015 поддерживает промисы “из коробки”, и в настоящее время полифилы обычно не нужны.

Ссылки

- https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261

---

## 46. Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?

### Преимущества:

- Помогает избежать “callback hell”, который может быть нечитаемым.
- Упрощает написание последовательного удобочитаемого асинхронного кода с помощью `.then()`.
- Упрощает написание параллельного асинхронного кода с помощью `Promise.all()`.
- С использованием промисов можно избежать следующих проблем, которые возникают при использовании callback-функций:
- Колбэк-функция была вызвана слишком рано
- Колбэк-функция была вызвана слишком поздно (или вовсе не была вызвана)
- Колбэк-функция была вызвана слишком мало или слишком много раз
- Не удалось передать необходимую среду/параметры
- Были пропущены ошибки/исключения

Недостатки

- Чуть более сложный код (спорно).
- В старых браузерах, где не поддерживается ES2015, вам нужно загрузить полифил, чтобы их использовать.

Ссылки

- https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md

---

## 47.
