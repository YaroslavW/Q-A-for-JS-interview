# Вопросы по HTML

![logo General Web Dev](img/html-bliz-50.jpg)

## 1. Для чего нужен `doctype` и сколько разновидностей Вы можете назвать?

Элемент `DOCTYPE` предназначен для указания типа текущего документа — DTD (document type definition, описание типа документа). Это необходимо, чтобы браузер понимал, как следует интерпретировать текущую веб-страницу, поскольку HTML существует в нескольких версиях, кроме того, имеется XHTML (EXtensible HyperText Markup Language, расширенный язык разметки гипертекста), похожий на HTML, но различающийся с ним по синтаксису. Чтобы браузер «не путался» и понимал, согласно какому стандарту отображать веб-страницу и необходимо в первой строке кода задавать DOCTYPE.

- HTML 4.01
- HTML 5
- XHTML 1.0
- XHTML 1.1

1. Подробней про то, как указывать теги для определенного Doctype: http://htmlbook.ru/html/%21doctype
2. Хорошая полезная подробная статья: https://habrahabr.ru/post/71364/

---

## 2. Что такое режим совместимости (Quirks Mode) и стандартный режим (Standards Mode)

На сегодняшний день существует **три режима отображения**, которые используются движками разметки (_layout engines_) браузеров: режим совместимости (_quirks mode_), частично стандартный режим (_almost standards mode_) и стандартный режим (_full standards mode_).

В режиме совместимости (_quirks mode_), разметка эмулирует нестандартное поведение браузеров Navigator 4 и Internet Explorer 5. Этот режим необходим для поддержки сайтов, созданных до начала широкого применения веб стандартов.

В стандартном режиме (_full standards mode_) поведение браузера соответствует (будем надеяться) описанному в спецификациях HTML и CSS.

В частично стандартном режиме (_almost standards mode_) реализовано лишь незначительное количество так называемых "странностей" (quirks).

Если вы будете пользоваться неполным тегом DOCTYPE, устаревшим его видом, или вообще забудете про него, броузер перейдет в «загадочный» (_quirk_) режим и будет исходить из предположения, что вы писали код страницы с ошибками и вольно отступали от стандартов, т.е. так, как писали в конце 90-ых годов. В этом режиме броузер попытается разобрать вашу страницу по правилам обратной совместимости и выведет на экран, например, CSS так, как его вывел бы Internet Explorer 4-ой версии, а DOM будет работать так, как он работал именно в этом броузере (IE переключается в свой старый DOM, а Mozilla и Netscape 6 переключается вообще в бог знает что).

Подробней

- https://developer.mozilla.org/ru/docs/Web/HTML/Quirks_Mode_and_Standards_Mode
- https://habrahabr.ru/post/71364/

---

## 3. В чем разница между HTML и XHTML?

XHTML - это приложение XML, которое является довольно строгим языком с угловыми скобками.
HTML - это приложение SGML, которое является гораздо менее строгим языком с угловой скобкой.
(XML также является применением SGML.)
При написании кода XHTML придерживаются того же синтаксиса, который характерен для HTML. При этом разница между HTML и XHTML состоит в наборе некоторых обязательных правил.

Правила XHTML следующие.

- Все теги и их атрибуты должны быть набраны в нижнем регистре (строчными символами).
- Значения любых атрибутов необходимо заключать в кавычки.
- Требуется закрывать все теги, даже такие, которым не сопоставлен закрывающий тег.
- Должна соблюдаться правильная вложенность тегов.
- Нельзя использовать сокращенные атрибуты тегов.
- Вместо атрибута `name` следует указывать `id`.
- Следует определять DTD (_document type definition_, описание типа документа) с помощью элемента `DOCTYPE`.

Подробнее с примерами: http://htmlbook.ru/xhtml/sintaksis-xhtml

---

## 4. Могут ли возникнуть проблемы при подаче страниц с типом `application/xhtml+xml`?

MIME (Multipurpose Internet Mail Extensions, многоцелевые расширения интернет-почты) — стандарт Интернет, является частью протокола HTTP. Задача MIME это идентификация типа содержимого документа по его заголовку. К примеру, текстовый файл имеет тип `text/plain`, а HTML-файл — `text/html`. Отправка заголовка обычно происходит на основе расширения файла веб-сервером.

Документы XHTML по умолчанию отправляются как `text/html`, что в действительности говорит о том, что мы имеем дело с HTML, а не XHTML-файлом. Чтобы задействовать возможности XHTML требуется отдавать файл с типом `application/xhtml+xml`. Если у вас установлен веб-сервер Apache, то вы можете сделать это через директиву AddType, добавив следующую строку в файл `.htaccess`, расположенный в корне сайта.

`AddType application/xhtml+xml .xhtml`

В данном случае мы говорим, что все файлы с расширением `.xhtml` отдавать как `application/xhtml+xml`. Если документы формируются через PHP, то можно отдавать заголовок следующим образом:

`header ("Content-type: application/xhtml+xml");`

Учтите, что эта строка должна идти до вывода любого текста на странице.

Браузер Internet Explorer до версии 8.0 включительно не поддерживает тип `application/xhtml+xml` и не сможет отобразить страницу, которая отдаётся с этим типом. Остальные браузеры, в том числе IE9, понимают этот тип как переход в стандартный режим.

Тип `application/xhtml+xml` необходим в случае, когда в документе применяется MathML (Mathematical Markup Language, язык математической разметки), предназначенный для добавления формул или SVG (Scalable Vector Graphics, масштабируемая векторная графика), язык разметки для создания на странице векторных рисунков. Если вы ничего не знаете об этих технологиях и пока не собираетесь их использовать, лучше отдавать документ как `text/html`. Это позволит охватить наибольшее количество браузеров и поисковых систем.

По сути, тип `text/html` для файлов с расширением `.html` или `.htm` настроен автоматически, поэтому не требуется предпринимать каких-либо действий для этого типа.

согласование содержимого для переключения между `application/xhtml+xml` и `text/html` так же, как вы описываете, не замечая проблем с поисковыми роботами. Строго говоря, вы должны учитывать значения `q` в заголовке `accept`, который указывает предпочтение пользовательского агента к каждому типу контента. Если пользовательский агент предпочитает принимать `text/html`, но будет принимать `application/xhtml+xml` в качестве альтернативы, то для обеспечения максимальной безопасности вы должны иметь страницу `text/html`.

---

## 5. Какая связь между SGML, HTML, XML и XHTML?

**SGML** (_Standard generalized markup language_ — стандартный обобщённый язык разметки) – это стандарт, который определяет разметку документа.

**HTML** – это язык разметки, который описывается с помощью SGML.

Итак, с помощью SGML было создано DTD (определение типа документа), на которое ссылается и которого должен придерживаться HTML. Поэтому вы всегда можете найти декларацию «DOCTYPE» в начале страницы HTML, которая определяет, какое DTD будет использовать браузер при разборе кода страницы.

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

Разбор кода по стандарту SGML был связан с определёнными трудностями, поэтому был создан XML, чтобы облегчить эту процедуру. XML использует SGML. Например, в SGML вы должны использовать открывающие и закрывающие теги, тогда как в XML вы можете использовать самозакрывающиеся теги, которые закрываются автоматически. XHML был создан из XML и использовался в HTML 4.0. Поэтому, например, в HTML, основанном на SGML, тег недопустим, а в XHTML он допускается. Вы можете использовать XML определение документа, как показано в следующем примере:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

Вкратце, SGML стоит в основе всего. Старые версии HTML основаны на SGML, а HTML 4.0 использует XHTML, построенный на основе XML.

---

## 6. Как установить язык содержимого моей HTML страницы?

Всегда используйте языковой атрибут тэга `html` для объявления языка по умолчанию на странице. Если страница содержит контент на другом языке, добавляйте языковой атрибут к элементам, окружающим этот контент.

Используйте `lang` атрибут для HTML страниц и `xml:lang` атрибут для страниц XML. Для XHTML 1.x и документов HTML5 Polyglot используйте оба атрибута вместе.

Используйте языковые тэги из _IANA Language Subtag Registry_. Вы можете найти тэги также с помощью _Language Subtag Lookup_.

Используйте вложенные элементы для того, чтобы позаботиться о контенте и значения атрибутов для одинаковых элементов на разных языках.

Подробнее: https://www.w3.org/International/questions/qa-html-language-declarations.ru

---

## 7. Чем полезны data- атрибуты?

HTML5 спроектирован с возможностью расширения данных ассоциированных с каким-либо элементом, но в то же время не обязательно имеющих определённое значение. `data-*` атрибуты позволяют хранить дополнительную информацию в стандартных элементах HTML, без хаков вроде нестандартных атрибутов, лишних DOM-свойств или `Node.setUserData()`.

Синтаксис HTML

```html
<article
  id="electriccars"
  data-columns="3"
  data-index-number="12314"
  data-parent="cars"
></article>
```

Доступ в JavaScript

```js
var article = document.getElementById("electriccars");
article.dataset.columns; // "3"
article.dataset.indexNumber; // "12314"
article.dataset.parent; // "cars"
```

Доступ в CSS

```css
article::before {
  content: attr(data-parent);
}
```

Подробнее: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Using_data_attributes

---

## 8. Если рассматривать HTML5 как открытую web-платформу, на чем она строится, из каких компонентов состоит?

HTML5 (англ. _HyperText Markup Language, version 5_) — язык для структурирования и представления содержимого всемирной паутины. Это пятая версия HTML. Хотя стандарт был завершён (рекомендованная версия к использованию) только в 2014 году (предыдущая, четвёртая, версия опубликована в 1999 году), ещё с 2013 года браузерами оперативно осуществлялась поддержка, а разработчиками — использование рабочего стандарта (англ. _HTML Living Standard_). Цель разработки HTML5 — улучшение уровня поддержки мультимедиа-технологий с одновременным сохранением обратной совместимости, удобочитаемости кода для человека и простоты анализа для парсеров.

Во всемирной паутине долгое время использовались стандарты _HTML 4.01, XHTML 1.0 и XHTML 1.1._ Веб-страницы на практике оказывались свёрстаны с использованием смеси особенностей, представленных различными спецификациями, включая спецификации программных продуктов, например веб-браузеров, а также сложившихся общеупотребительных приёмов. HTML5 был создан как единый язык разметки, который мог бы сочетать синтаксические нормы HTML и XHTML. Он расширяет, улучшает и рационализирует разметку документов, а также добавляет единый API для сложных веб-приложений.

В HTML5 реализовано множество новых синтаксических особенностей. Например, элементы `video`, `audio` и `canvas`, а также возможность использования SVG и математических формул. Эти новшества разработаны для упрощения создания и управления графическими и мультимедийными объектами в сети без необходимости использования сторонних API и плагинов. Другие новые элементы, такие как `section`, `article`, `header` и `nav`, разработаны для того, чтобы обогащать семантическое содержимое документа (страницы). Новые атрибуты были введены с той же целью, хотя ряд элементов и атрибутов был удалён. Некоторые элементы, например a, `menu` и `cite`, были изменены, переопределены или стандартизированы. API и DOM стали основными частями спецификации HTML5. HTML5 также определяет некоторые особенности обработки ошибок вёрстки, поэтому синтаксические ошибки должны рассматриваться одинаково всеми совместимыми браузерами.

Подробнее: https://ru.wikipedia.org/wiki/HTML5

---

## 9. В чем отличия HTML5 от HTML4.01 и XHTML1.0

Ниже представлен список отличий(не все):

Изменён синтаксис

Встраивание SVG и MathML в text/html

Новые элементы:
```html
<article>, <aside>, <audio>, <canvas>, <command>, <datalist>, <details>, <embed>, <figcaption>, <figure>, <footer>, <header>, <hgroup>, <keygen>, <main>, <mark>, <meter>, <nav>, <output>, <progress>, <rp>, <rt>, <ruby>, <section>, <source>, <summary>, <time>, <video>, <wbr>
```

Новые компоненты ввода:
```html
date/time, email, url, search, number, range, tel, color
```

Новые атрибуты: `charset` (в meta), `async` (в script)

Глобальные атрибуты, которые могут быть применены ко всем элементам: `id`, `tabindex`, `hidden`, `data-*` (пользовательские атрибуты данных)

Элементы, которые будут исключены:
```html
<acronym>, <applet>, <basefont>, <big>, <center>, <dir>, <font>, <frame>, <frameset>, <isindex>, <noframes>, <strike>, <tt>
```

Подробнее: https://ru.wikipedia.org/wiki/HTML5

---

## 10. Что такое HTTP cookie?

HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.

Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту оно отсылается.

Подробней: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки

---

## 11.Что такое Secure ("безопасные") и HttpOnly cookies?

"Безопасные" (secure) cookie отсылаются на сервер только если запрос выполняется по протоколу SSL и HTTPS. Однако важные данные никогда не следует передавать или хранить в cookies, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг secure никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 and Firefox 52, незащищенные сайты (http:) не могут создавать куки с флагом secure.

Куки HTTPonly не доступны из JavaScript через свойства Document.cookie, и через XMLHttpRequest и Request API, что помогает избежать межсайтового скриптинга (XSS). Устанавливайте этот флаг для тех cookie, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг HttpOnly.

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly`

Подробней: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки

---

## 12. Объясните разницу между cookies, sessionStorage и localStorage.

* LocalStorage

  **Плюсы**:

  * Веб-хранилище можно рассматривать упрощенно как усовершенствование файлов cookie, обеспечивая гораздо большую емкость хранилища. Если вы посмотрите исходный код Mozilla, мы увидим, что 5120KB (5 МБ), равный 2,5 миллионам символов в Chrome), является размером хранилища по умолчанию для весь домен. Это дает вам значительно больше возможностей для работы, чем обычный cookie 4 КБ.

  * Данные не отправляются обратно на сервер для каждого HTTP-запроса (HTML, изображения, JavaScript, CSS и т.д.) - уменьшение количества трафика между клиентом и сервером.

  * Данные, хранящиеся в localStorage, сохраняются до явного удаления. Сделанные изменения сохраняются и доступны для всех текущих и будущих посещений сайта.

  **Минусы**:

  * Он работает в политике одного и того же происхождения. Таким образом, сохраненные данные будут доступны только в том же месте.

* Cookies

  **Плюсы**:

  * По сравнению с другими, ничего.

  **Минусы**:

  * Предел 4Kб предназначен для всего файла cookie, включая имя, значение, дату истечения срока годности и т.д. Чтобы поддерживать большинство браузеров, держите имя менее 4000 байт и общий размер файла cookie под 4093 байтами.

  * Данные отправляются обратно на сервер для каждого HTTP-запроса (HTML, изображения, JavaScript, CSS и т.д.) - увеличение количества трафика между клиентом и сервером.

  **Обычно допустимы следующие действия:**
  * 300 файлов cookie
  * 4096 байт для каждого файла cookie
  * 20 файлов cookie для каждого домена
  * 81920 байт для каждого домена (задано 20 файлов cookie максимального размера 4096 = 81920 байт.)

* sessionStorage
  **Плюсы**:

  * Он похож на localStorage.
  * Изменения доступны только для каждого окна (или вкладки в браузерах, таких как Chrome и Firefox). Сделанные изменения сохраняются и доступны для текущей страницы, а также для будущих посещений сайта в том же окне. Когда окно закрыто, хранилище удаляется.

  **Минусы**:
  * Данные доступны только внутри окна/вкладки, в котором он был установлен.
  * Данные не сохраняются, т.е. будут потеряны после закрытия окна/вкладки.
  * Подобно localStorage, работает в политике одинакового происхождения.  Таким образом, сохраненные данные будут доступны только в том же месте.

Подробней:
* LocalStorage: https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage
* Cookies: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки
* SessionStorage: https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage

---

## 13. Каким способом, возможно вложить js-объект в localstorage?

`localStorage.setItem(‘Object’, JSON.stringify(Object))`

---

## 14. Нужно ли в 5-м ХТМЛ закрывать /> одиночные теги ?

По спецификации - не нужно. Закрывающие слэши предполагаются в XHTML, а в HTML (любой версии) они не нужны.

По здравому смыслу - тоже не нужно. Валидатор w3c так же не ругается.

---

## 15.Что такое кэш приложения в HTML5?

Доступность в оффлайне становится всё более важной для веб-приложений. Да, все браузеры имеют механизмы кэширования, но они ненадежны и работают не всегда ожидаемо. HTML5 устраняет некоторые из этих неприятностей с помощью интерфейса ApplicationCache.

Использование интерфейса кэша даёт вашему приложению три преимущества:

* автономный просмотр — пользователи могут исследовать ваш сайт целиком, когда они находятся в оффлайне;
* скорость — ресурсы кэшируются локально, поэтому загружаются быстрее;
* снижение нагрузки на сервер — браузер загружает с сервера только изменённые ресурсы.
* Кэш приложения (или AppCache) позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Ваше приложение будет работать корректно, даже если пользователь нажимает кнопку «Обновить», находясь в автономном режиме.

Подробней, как настроить и обновлять: http://htmlbook.ru/blog/rukovodstvo-po-ispolzovaniyu-kesha-prilozheniya

---

## 16. Дайте описание след. разделам в файле манифеста кеша: CACHE, NETWORK и FALLBACK.

* CACHE - Это стандартный раздел для записи. Файлы, перечисленные в этом блоке (или сразу после CACHE MANIFEST) будут явно кэшированы после того как они скачаны в первый раз.
* NETWORK - Файлы, перечисленные в этом разделе, это ресурсы, которые требуют подключения к серверу. Все запросы к этим ресурсам идут в обход кэша, даже если пользователь находится в оффлайне. Можно использовать * для задания шаблона.
* FALLBACK Дополнительный раздел указывает резервные страницы, если ресурс недоступен. Первый URL является ресурсом, второй резервом. Оба адреса должны быть относительны и быть в том же месте, что и файл манифеста. Можно использовать * для задания шаблона.

Подробней, как настроить и обновлять: http://htmlbook.ru/blog/rukovodstvo-po-ispolzovaniyu-kesha-prilozheniya

---

## 17. Объясните разницу между `<script>, <script async>` и `<script defer>`

**Просто script с src:**
* Получить страницу HTML (например, index.html)
* Начните синтаксический анализ HTML
* Парсер встречает тег `<script>`, ссылающийся на внешний файл `script`.
* Браузер запрашивает файл `script`. Между тем, синтаксический анализатор блокирует и останавливает анализ другого HTML на вашей странице.
* Через некоторое время загрузится и затем выполняется `script`.
* Парсер продолжает анализировать остальную часть HTML-документа.

**async**: Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении `<script async src="...">` браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.

**defer**: Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от `async`.

_Первое_ – браузер гарантирует, что относительный порядок скриптов с `defer` будет сохранён.

_Второе отличие_ – скрипт с `defer` сработает, когда ***весь HTML-документ*** будет обработан браузером.

Подробнее: https://learn.javascript.ru/external-script#асинхронные-скрипты-defer-async

---

## 18. Какое будет поведение `<script async defer>`?

При одновременном указании `async` и `defer` в современных браузерах будет использован **только** `async`, в IE9- – **только** `defer` (не понимает `async`).

Подробнее: https://learn.javascript.ru/external-script#асинхронные-скрипты-defer-async

---

## 19. Что такое прогрессивный рендеринг?

Прогрессивное рендеринг - это имя, данное методам, используемым для рендеринга содержимого для отображения как можно быстрее. Раньше он был гораздо более распространенным в дни перед широкополосным доступом в Интернет, но он по-прежнему полезен в современном развитии, поскольку мобильные соединения данных становятся все более популярными (и ненадежными!)

**Примеры таких методов**:
* Ленивая загрузка изображений, где (как правило) некоторые javascript загружают изображение, когда оно попадает в окно просмотра браузеров, вместо загрузки всех изображений при загрузке страницы.
* Приоритет видимого содержимого (или выше рендеринга сложения), где вы включаете только минимальные css/content/скрипты, необходимые для количества страницы, которая будет отображаться в чтобы браузер отображался как можно быстрее, вы можете использовать отложенный javascript (domready/load) для загрузки других ресурсов и контента.

Подробнее:
* Совсем глубоко: https://habrahabr.ru/post/210558/
* Как рендерит: https://habrahabr.ru/post/224187/
* https://habrahabr.ru/post/320430/
* https://stackoverflow.com/questions/33651166/what-is-progressive-rendering

---

## 20. Что такое meta теги?

Мета теги — часть программного HTML кода, заключенная между тегом `<head>...</head>` (заголовок страницы). Эти атрибуты не являются обязательными: они не видны пользователю, но сообщают определенную информацию поисковой системе (описание, заголовок, ключевые слова и т.д.).. Как правило, атрибуты любого метатега сводятся к парам «имя=значение», которые определяются ключевыми словами `content`, `name` или `http-equiv`.

**Аттрибуты**:
* `charset`: Задает кодировку документа.
* `content`: Устанавливает значение атрибута, заданного с помощью `name` или `http-equiv`.
* `http-equiv`: Предназначен для конвертирования метатега в заголовок HTTP.
* `name`: Имя метатега, также косвенно устанавливает его предназначение.

Подробнее об аттрибутах:
* http://htmlbook.ru/html/META
* https://www.ashmanov.com/education/articles/meta-tegi/

---

## 21. Как можно с помощью meta-тега, указать HTTP - заголовок?

`<meta http-equiv="Content-Type" content="text/html" />`

Много подброней: https://ru.wikipedia.org/wiki/Метатеги

---

## 22. Расскажите о meta-теге с name=viewport
Типичный сайт, оптимизированный для мобильных устройств, содержит следующий мета-тег:

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```
Свойство `width` определяет размер окна просмотра. Он может быть установлен на определенное количество пикселей, скажем,`width=600` или на специальное значение `device-width`, которое означает ширину экрана в пикселях CSS в масштабе `100%`. (Есть также соответствующие значения `height` и `device-height`, которые могут быть полезны для страниц с элементами, которые изменяют размер или положение на основе высоты окна просмотра).

Свойство `initial-scale` контролирует уровень масштабирования при первой загрузке страницы. Свойства `maximum-scale`, `minimum-scale` и `user-scalable` определяют, как пользователям разрешено увеличивать или уменьшать страницу.

`"user-scalable=no"` запрещается любое масштабирование

Подброней: https://developer.mozilla.org/ru/docs/Mozilla/Mobile/Viewport_meta_tag

---

## 23. Какие теги практически обязательно должны быть в ```head```?

```html
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge"> <!-- Use the content="ie-edge" tag if your project
    supports Internet Explorer prior to version 11. -->
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Page Title</title>
```

Много больше информации о том, что должно быть в head: https://gethead.info/

---

## 24. Есть ли разница: `meta charset="utf-8"` и `meta http-equiv="Content-Type" content="text/html; charset=utf-8"`?
В HTML5 они эквивалентны

Используйте `meta charset="utf-8"` для веб-браузеров при использовании HTML5.

Используйте `meta http-equiv="Content-Type" content="text/html; charset=utf-8"` при использовании HTML4 или XHTML или для устаревших парсеров dom, например DOMDocument в php

---

## 25. Как сделать чтобы все гиперссылки сайта открывались в новом окне, т.е чтобы по умолчанию использовался `target="_blank"`?

Нужно в области `head` прописать тег `base` с атрибутом `target="_blank"`:

```html
<head><base target=”_blank”></head>
```

---

## 26. А как теперь быть, если какую-то из гиперссылок я захочу открыть в этом же окне, т.е. не создавая новое?

В тег `a` этой ссылки вам уже нужно будет добавить атрибут `target="_self"`, ибо по умолчанию сейчас у нас используется `target="_blank"`

---

## 27. Что такое аттрибут `target` и какие значения он принимает и что делает?

По умолчанию, при переходе по ссылке документ открывается в текущем окне или фрейме. При необходимости, это условие может быть изменено атрибутом `target` тега `a`. В XHTML применение этого атрибута запрещено. Все значения аттрибуты начинаются с `_`

* `blank` - Загружает страницу в новое окно браузера.
* `self` - Загружает страницу в текущее окно.
* `parent` - Загружает страницу во фрейм-родитель, если фреймов нет, то это значение работает как self.
* `top` - Отменяет все фреймы и загружает страницу в полном окне браузера, если фреймов нет, то это значение работает как `self`.

Подробней: http://htmlbook.ru/html/a/target

---

## 28. Что такое абсолютная и относительная ссылка?

```html
<a href=”http://google.com/example.html”>Абсолютная ссылка</a>

<a href=”../../example.html”>Относительная ссылка</a>
```

---

## 29. Какие новые элементы форм введены в HTML 5?

**В HTML 5 введены десять новых важных элементов форм**:
* Color;
* Date;
* Datetime-local;
* Email;
* Time;
* Url;
* Range;
* Telephone;
* Number;
* Search;

---

## 30. Что такое элемент datalist в HTML 5?

Элемент datalist в HTML 5 помогает реализовать функцию автозаполнения в поле для ввода.

```html
<input list="Country">
<datalist id="Country">
	<option value="India">
	<option value="Italy">
	<option value="Iran">
	<option value="Israel">
	<option value="Indonesia">
</datalist>
```

Подробней: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist

---

## 31. Что такое элемент `output` в HTML 5?

Элемент `output` требуется, когда вы хотите отобразить сумму двух введённых чисел в виде текста. Например, у вас есть два поля для ввода и вы хотите сложить числа из этих двух полей и отобразить их сумму в виде текста. Ниже приведён пример использования элемента `output` в HTML 5:

```html
<form onsubmit="return false" oninput="o.value = parseInt(a.value) + parseInt(b.value)">
	<input name="a" type="number"> +
	<input name="b" type="number"> =
	<output name="o" />
</form>
```

Вы можете заменить «`parseInt`» на «`valueAsNumber`» для простоты. Также вы можете использовать атрибут «`for`» элемента `output` для повышения читаемости.

```html
<output name="o" for="a b"></output>
```

Подробней: http://htmlbook.ru/blog/element-output

---

## 32. Что такое свойство `valueAsNumber`?

В HTML5 представлено свойство JavaScript `valueAsNumber` для полей формы (в частности: `number`, `date`, `range`). Оно возвращает значение в виде числа, а не строки, то есть нам больше не нужно использовать `parseInt` или `parseFloat`, и оператор `+` складывает, а не склеивает.

```html
<form onsubmit="return false" oninput="o.value = a.valueAsNumber + b.valueAsNumber">
	<input name="a" id="a" type="number" step="any"> +
	<input name="b" id="b" type="number" step="any"> =
	<output name="o" for="a b"></output>
</form>
```

Подробней: http://htmlbook.ru/blog/element-output

---

## 33. Для чего нужен атрибут `autocomplete`? Какие параметры принимает?

Этот атрибут помогает заполнять поля форм текстом, который был введён в них ранее. Значения сохраняет и подставляет браузер, при этом автозаполнение по соображениям безопасности может отключаться пользователем в настройках и не может в таком случае управляться атрибутом `autocomplete`.

* `on` - Включает автозаполнение текста.
* `off` - Отключает автозаполнение. Это значение обычно используется для отмены сохранения в браузере важных данных (паролей, номеров банковских карт), а также редко вводимых или уникальных данных (капча).

Подробней: http://htmlbook.ru/html/input/autocomplete

---

## 34. Какой формат у input type="date" в HTML5

`YYYY-MM-DD`

---

## 35. Какой метод запускает проигрывание аудио-файла?

`var sound = new Audio(«file.wav»);`

`sound.play();`

---

## 36. Какой формат видео файлов сейчас поддерживается html5?

`MPEG 4`

---

## 37. Какие элементы в HTML5 могут иметь aria атрибут?

Любой элемент

---

## 38. Знаете ли вы тег `dfn` и за что он отвечает?

Как правило, в документе, когда упоминается новый термин, он выделяется _курсивом_ и дается его определение. При использовании этого термина в дальнейшем, он считается уже известным читателю. Тег `dfn` применяется для выделения таких терминов при их первом появлении в тексте.

Браузеры отображают содержимое контейнера с помощью курсивного начертания.

Подробней: http://htmlbook.ru/html/DFN

---

## 39. Что такое SVG?

язык разметки масштабируемой векторной графики, созданный Консорциумом Всемирной паутины (W3C) и входящий в подмножество расширяемого языка разметки XML, предназначен для описания двумерной векторной и смешанной векторно/растровой графики в формате XML. Поддерживает как неподвижную, так и анимированную интерактивную графику — или, в иных терминах, декларативную и скриптовую.

Подробней: https://ru.wikipedia.org/wiki/SVG

---

## 40. Что такое canvas в HTML 5?
Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript). Он может, к примеру, использоваться для рисования графов, создания коллажей или простой (и не очень) анимации. Изображения в правой части статьи являются примерами использования , примеры их создания приводятся в этой статье.

Подробней: https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial

---

## 41. В чём разница между canvas и SVG?

### SVG
* Плюсы:
  * Нет зависимости от разрешения — SVG лучше подходит для кроссплатформенных пользовательских интерфейсов, так как позволяет масштабировать изображение при различных разрешениях экрана.
  * SVG очень хорошо поддерживает анимацию. Элементы могут быть анимированы с использованием описательного синтаксиса или с помощью JavaScript.
  * Можно получить полный контроль над каждым элементом, используя SVG DOM API в JavaScript.
  * SVG хранится в формате XML, что предоставляет больше возможностей браузерам по обеспечению доступности SVG документов по сравнению с элементом canvas. Таким образом, SVG выглядит лучшим решением для пользовательских интерфейсов веб-приложений.
* Минусы:
  * Низкая скорость рендеринга при увеличении сложности документа (рисунка), так как используется модель DOM
  * Скорее всего, SVG не подходит для таких приложений как игры. Возможно лучшим выбором будет комбинация HTML Canvas + SVG.
### Canvas
* Плюсы:
  * Высокая производительность при отрисовке любых 2D объектов.
  * Стабильная производительность — всё есть пиксель. Производительность падает только при увеличении разрешения изображения.
  * Можно сохранить полученное изображение в PNG или JPG файл.
  * Лучше всего подходит для создания растровой графики (например, в играх, фракталов и т.п.), редактирования изображений и операций, требующих манипулирования на уровне пикселей.
* Минусы:
  * Отрисовка основана на пикселях.
  * Не существует API для анимации. Вам придется прибегать к использованию таймеров и других событий для обновления канвы.
  * Слабые возможности по рендерингу текста.
  * Возможно, не самый лучший выбор, когда доступность имеет решающее значение. Канва предоставляет вам поверхность для рисования в выбранном контексте (2D и 3D). Можно указать альтернативный контент внутри элемента canvas, который будет показан браузером при невозможности отображения графики. Кроме того, вы можете выполнить проверку доступности выбранного Canvas API с помощью JavaScript. На основе этого вы можете обеспечить различную функциональность для пользователей браузеров с разной поддержкой HTML 5 Canvas.
  * HTML 5 Canvas не подходит для создания веб-сайтов или интерфейсов веб-приложений, так как пользовательские интерфейсы обычно должны быть динамическими и интерактивными, а Canvas требует от вас постоянной перерисовки каждого элемента в интерфейсе.
  
  
Подробней:

https://habrahabr.ru/company/simbirsoft/blog/332750/
https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial


---

## 42. В каких случаях лучше выбрать canvas, а в каких svg?

### HTML 5 Canvas следует использовать для:
  * Редактирования изображений: обрезки, изменения размеров, фильтров (удаления эффекта красных глаз, создания эффекта сепии, изменения цветности или яркости)
  * Создания растровой графики: визуализации данных, создания фракталов и графиков функций.
  * Анализа изображений: создания гистограмм и т.п.
  * Создания игровой графики, такой как спрайты и фоны.
### SVG следует использовать для:
  * Создания пользовательских интерфейсов веб-приложений, независимых от разрешения экрана.
  * Высокоинтерактивных анимированных пользовательских интерфейсов.
  * Графиков и диаграмм.
  * Редактирования векторных изображений.

## 43. Что такое WebGL?

WebGL (Web-based Graphics Library) — программная библиотека для языка программирования JavaScript, позволяющая создавать на JavaScript интерактивную 3D-графику, функционирующую в широком спектре совместимых с ней веб-браузеров. За счёт использования низкоуровневых средств поддержки OpenGL, часть кода на WebGL может выполняться непосредственно на видеокартах. WebGL — это контекст элемента canvas HTML, который обеспечивает API 3D графики без использования плагинов. Спецификация версии 1.0 была выпущена 3 марта 2011 года. Проект по созданию библиотеки управляется некоммерческой организацией Khronos Group.

Подробней: https://ru.wikipedia.org/wiki/WebGL

---

## 44. 