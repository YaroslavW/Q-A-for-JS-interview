# Общие вопросы о веб-разработке

![logo General Web Dev](img/general-bliz-50.jpg)

## 1. Используете вы Perfect Pixel или что-то аналогичное?
Pixel Perfect верстка — это особая техника создания структуры html-кода, которая позволяет сверстанному html-шаблону максимально точно совпадать с оригинальным PSD-макетом пиксель в пиксель. При наложении html-шаблона на макет PSD должно произойти полное совпадение графических элементов, изображений и текста.

Следует уточнить про допуски при верстке, `5px - 10px`

---

## 2. Можете ли пояснить разницу между `progressive enhancement` и `graceful degradation`?

`graceful degradation` будет пониматься как отказоустойчивость клиентских веб-интерфейсов. Постепенная деградация может выражаться в возможности работы при отключённом JavaScript, в достаточно аккуратном отображении интерфейса в браузере, не поддерживающем новые свойства CSS3, в адекватном отображении сайта при отключенных изображениях. В каждом из этих случаев работа пользователя с интерфейсом будет в принципе возможна, хотя и не так удобна.

Что же такое `progressive enhancement`? Чаще всего этот термин переводят, как прогрессивное улучшение. Прогрессивное улучшение предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего. Можно сказать, что сейчас таких этапов четыре

* «Старый-добрый-HTML»
* «CSS»
* «CSS3»
* «JavaScript»

Подробнее - https://htmlacademy.ru/blog/useful/html/progressive-enhancement

---

## 3. Что такое прогрессивный JPEG?
Оптимизированные для веба фото — это jpeg, а jpeg делится на два типа: базовый последовательный (baseline) и прогрессивный (progressive). Последовательный jpeg — это один скан изображения сверху вниз в полном разрешении, а прогрессивный jpeg — это серия сканов улучшающегося качества. Так они и рендерятся — последовательный jpeg отрисовывается сверху вниз («тик, тик, тик, …»), а прогрессивный быстро размечает свою территорию и затем совершенствуется (по крайней мере так задумано).

Подробнее - https://habr.com/ru/post/165645/

---

## 4. Что такое `feature detection` (определение возможностей браузера)?

`Feature detection` определяет, поддерживает ли браузер тот или иной блок кода и запускает различный код в зависимости от того, поддерживает или нет, так чтобы браузер всегда мог показать рабочий код, вместо репортов об ошибках.

### 2 способа определения в js:
1. распарсить юзер-агент, определить версию браузера и писать в коде свитчи по версии браузера
2. Проверить наличие свойства или метода в window(dom, bom, javascript):

```js
if("geolocation" in navigator) {
	navigator.geolocation.getCurrentPosition(function(position) {
	// show the location on a map, perhaps using the Google Maps API
	});
} else {
	// Give the user a choice of static maps instead perhaps
}
```
### 1 способ в css:
* @supports

Подробней:

* https://developer.mozilla.org/de/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection
* https://habrahabr.ru/post/336466/

---

## 5. Как проверить что куки включенны?

```js
if (!navigator.cookieEnabled) {
  alert( 'Включите cookie для комфортной работы с этим сайтом' );
}
```

---

## 6. Объясните, что означает "Семантическая разметка"

Семантическая вёрстка, или семантический HTML-код, — это подход к созданию веб-страниц на языке HTML, основанный на использовании HTML-тегов в соответствии с их семантикой (предназначением), а также предполагающий логичную и последовательную иерархию страницы. Он противопоставляется подходу, при котором написание HTML-кода определяется внешним видом веб-страницы. Для оформления веб-страниц, написанных в соответствии с семантикой, используются каскадные таблицы стилей (CSS). Стандарт HTML с самого начала включал в себя ряд семантических тегов, но большую популярность семантическая вёрстка получила после начала работ над HTML5.

Подробнее: https://ru.wikipedia.org/wiki/Семантическая_вёрстка

---

## 7. Как можно оптимизировать загрузку внешних ресурсов на странице?

1. Уменьшите количество HTTP-запросов
2. Используйте поддомены для параллельного скачивания
3. Используйте кэш браузера
4. Используйте CDN для загрузки популярных JavaScript библиотек
5. Используйте Gzip- сжатие

Подробней по каждому пункту: https://habrahabr.ru/post/137239/

---

## 8.Каково преимущество в подгрузке внешних ресурсов с нескольких доменов?
Cогласно спецификации HTTP/1.1 на браузеры накладываются ограничения на количество одновременно загружаемых компонентов сайта, а именно не более 2-х компонентов с одного хоста. Поэтому если на Вашем сайте много графики, то ее лучше вынести на отдельный поддомен или поддомены. Для Вас это будет один и тот же сервер, а для браузера – разные. Чем больше поддоменов Вы создадите, тем больше файлов браузер сможет одновременно загрузить и тем быстрее загрузится вся страница сайта. Вам остается лишь изменить адрес картинок на новый. Очень простой, но действенный способ.

---

## 9. Назовите способы уменьшения времени загрузки страницы (воспринимаемого или реального)

1. Помещайте CSS файлы в начале страницы
2. Помещайте javascript в конец страницы
3. Минимизируйте css и javascript
4. Оптимизируйте ваши изображения
5. Не масштабируйте изображения

Подробней по каждому пункту: https://habrahabr.ru/post/137239/

---

## 10. Что такое `FOUC` (`Flash Of Unstyled Content`)? Как его избежать?
`Flash of Unstyled Content` (`FOUC`) – это кратковременное появление неоформленных HTML-элементов в некоторых версиях браузеров – сразу же после создания визуальных элементов и до полного применения стилей CSS.

* \`css {display: block}\` на компонент
* В обратных кавычках \` \` инлайнится код, необходимый для показа минимум 600px высоты страницы без загрузки дополнительных стилей.

---

## 11.Что такое критический путь рендеринга веб-страниц?
Критический путь рендеринга – это набор минимально необходимых для начала отрисовки страницы действий, ресурсов и вычислений.

Критический путь можно измерять в количестве критических ресурсов, минимальном времени загрузки (измеряется в RTT) и объеме критических ресурсов (в байтах).

Для иллюстрации возьмем простейший пример: HTML страницу размером 1 кб без внешних ресурсов. Критический путь будет: 1 ресурс (HTML-документ), 1 RTT (минимально), 1 кб трафика. Однако, таких простых страниц в природе почти не встретить, поэтому покажем, как можно определять критический путь на реальных веб-страницах.

Подробней: https://habrahabr.ru/post/262239/

---

## 12. Что такое WebSQL?

WebSQL DB — это API для доступа к полноценному SQL-хранилищу данных, основанному на SQLite. Впрочем, последнее обстоятельство — скорее, особенность реализации и стандартом не оговаривается, хотя диалект SQL используется именно от SQLite.

Подробней:
* (en) https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Storage
* https://habrahabr.ru/post/84654/
* (Раздел: За пределами пары ключ/значение: конкурентное видение) http://htmlbook.ru/html5/storage

---

## 13. Является ли WebSQL частью спецификации HTML 5?
Нет. Многие относят его к HTML 5, но WebSQL не является частью спецификации HTML 5. Спецификация основана на SQLite.

Поддержка браузерами: https://caniuse.com/#search=websql

---

## 14. Является ли, Drag and drop частью спецификации? Какие drag-события Вам известны?
Да, это часть спецификации

**dragstart, dragenter, dragover, dragleave, drag, drop, dragend**

Подробней: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Drag_and_drop#events

---

## 15. Является ли Web workers частью спецификации HTML 5?

Да. Worker - это объект, созданный при помощи конструктора (например, Worker()), который запускает JavaScript файл по имени — этот файл содержит код, который будет выполнен в потоке Worker'а; объекты Workers запускаются в другом глобальном контексте, который отличается от текущего window. Таким образом, использование переменной window для получения текущего глобального контекста (вместо self) внутри Worker вернет ошибку.

* https://developer.mozilla.org/ru/docs/DOM/Using_web_workers
* https://html.spec.whatwg.org/multipage/#toc-workers

---

## 16. Является ли service workers частью спецификации HTML 5?
Service worker запускается в контексте worker'ов, поэтому он не имеет доступа к DOM и работает в потоке отдельном от основного потока JavaScript, управляющего вашим приложением, а следовательно — не блокирует его. Он призван быть полностью асинхронным; как следствие, синхронные API, такие как XHR и localStorage, в service worker'е использовать нельзя.

Подробней:
* https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API
* https://html.spec.whatwg.org/multipage/#toc-workers

---

## 17. Что такое гиперссылка?
Часть гипертекстового документа, ссылающаяся на другой элемент (команда, текст, заголовок, примечание, изображение) в самом документе, на другой объект (файл, каталог, приложение), расположенный на локальном диске или в компьютерной сети, либо на элементы этого объекта.

Подробней: https://ru.wikipedia.org/wiki/Гиперссылка

---

## 18. Что такое GraphQL?
В двух словах, GraphQL это синтаксис, который описывает как запрашивать данные, и, в основном, используется клиентом для загрузки данных с сервера. GraphQL имеет три основные характеристики:

Позволяет клиенту точно указать, какие данные ему нужны.
Облегчает агрегацию данных из нескольких источников.
Использует систему типов для описания данных.
Подробней: https://habrahabr.ru/post/326986/

---

## 19. Что такое HTTP?
Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение, создаёт запрос, а затем ждет ответа. HTTP - это stateless-протокол, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на TCP/IP, он так же может использовать любой транспорт, который не теряет молча сообщения (то есть он обязан знать дошло ли сообщение до адресата).

Подробней:
* https://developer.mozilla.org/ru/docs/Web/HTTP
* https://ru.wikipedia.org/wiki/HTTP
* https://habrahabr.ru/post/215117/

---

## 20. Если через консоль, примеру curl'oм, запросить сайт, что мы увидим?
Стандартный ответ страницы, как для браузера

Еще желательно знать, как организовывается докачка файлов, после восстановления соединения.

Подробней: https://ru.wikipedia.org/wiki/HTTP

---

## 21. Перечислите хотя бы 4 метода HTTP:
GET, POST, PUT, DELETE

Подробней:
* https://developer.mozilla.org/ru/docs/Web/HTTP
* https://ru.wikipedia.org/wiki/HTTP

---

## 22. Назовите 5 классов ошибок при HTTP запросе:
* 1xx Информирование о процессе передачи.

* 2xx Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.

* 3xx Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.

* 4xx Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.

* 5xx Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.

Подробней:
* https://developer.mozilla.org/ru/docs/Web/HTTP
* https://ru.wikipedia.org/wiki/HTTP

---

## 23. В чем отличия HTTP/1 от HTTP/2?
Протокол HTTP/2 является бинарным. По сравнению с предыдущим стандартом изменены способы разбиения данных на фрагменты и транспортирования их между сервером и клиентом.

В HTTP/2 сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.

Также часть улучшений получена за счёт мультиплексирования запросов и ответов для преодоления проблемы «head-of-line blocking» протоколов HTTP 1; сжатия передаваемых заголовков и введения явной приоритезации запросов.

Так же поддерживает приоритетность загрузки

Подробней: https://ru.wikipedia.org/wiki/HTTP/2

---

## 24. Где именно хранятся данные session и как сервер понимает как сопоставить конкретные данные session конкретному http запросу?

Сессии могут храниться на клиенте (signed cookie session). При этом используется подпись куки с помощью HMAC, чтобы данные сессии не могли быть свободно изменены клиентом. Но обычно сессии хранятся на сервере. Тут выбор огромный: от баз данных и key-value хранилищ (Redis, например) до простых файлов. При этом, клиенту посылается кука ID сессии (так сервер идентифицирует юзера), которую злоумышленник может стащить. Таким кукам, дабы защитить юзеров от XSS, ставится флаг HttpOnly, который советует браузеру не давать эту куку скриптам вроде JS. В этом случае, стащить куку получится только завладев браузером, файловой системой юзера или через багу браузера.

Подробней: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки

---

## 25. Что такое HTTPS?
HTTPS (HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443

Подробней:
* https://yandex.ru/blog/company/77455
* https://ru.wikipedia.org/wiki/HTTPS

---

## 26. Что такое REST?
REST (Representational State Transfer — «передача состояния представления») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и упрощению архитектуры. В широком смысле [уточнить] компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является альтернативой RPC.

Подробней:
* https://ru.wikipedia.org/wiki/REST
* https://habrahabr.ru/post/38730/

---

## 27. Что такое протокол-SOAP?

SOAP (Simple Object Access Protocol — простой протокол доступа к объектам) — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур. Официальная спецификация последней версии 1.2 протокола никак не расшифровывает название SOAP. SOAP является расширением протокола XML-RPC.

Подробней:
https://ru.wikipedia.org/wiki/SOAP

---

## 28. Что такое нотация О-большое?

В информатике временна́я сложность алгоритма определяет время работы, используемое алгоритмом, как функции от длины строки, представляющей входные данные. Временная сложность алгоритма обычно выражается с использованием нотации «O» большое, которая исключает коэффициенты и члены меньшего порядка. Если сложность выражена таким способом, говорят об асимптотическом описании временной сложности, т.е. при стремлении размера входа к бесконечности. Например, если время, которое нужно алгоритму для выполнения работы, для всех входов длины n не превосходит 5n3 + 3n для некоторого n (большего некоторого n0), асимптотическая временная сложность равна O (n3).

Подробней:
* https://ru.wikipedia.org/wiki/Временная_сложность_алгоритма
* https://habrahabr.ru/post/195482/
* https://habrahabr.ru/post/188010/

---

## 29. Что такое HMAC?

HMAC (сокращение от англ. hash-based message authentication code, код аутентификации (проверки подлинности) сообщений, использующий хеш-функции) — в информатике (криптографии), один из механизмов проверки целостности информации, позволяющий гарантировать то, что данные, передаваемые или хранящиеся в ненадёжной среде, не были изменены посторонними лицами (см. человек посередине). Механизм HMAC использует MAC, описан в RFC 2104, в стандартах организаций ANSI, IETF, ISO и NIST. MAC — стандарт, описывающий способ обмена данными и способ проверки целостности передаваемых данных с использованием секретного ключа. Два клиента, использующие HMAC, как правило, разделяют общий секретный ключ. HMAC — надстройка над MAC; механизм обмена данными с использованием секретного ключа (как в MAC) и хеш-функций. В зависимости от используемой хеш-функции выделяют HMAC-MD5, HMAC-SHA1, HMAC-RIPEMD128, HMAC-RIPEMD160 и т. п.

Подробней: https://ru.wikipedia.org/wiki/HMAC

---

## 30. Что такое CORS?

CORS (Cross-Origin Resource Sharing,"Совместное использование ресурсов между разными источниками") - это система, состоящая из отправки HTTP заголовков, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.

The same-origin security policy ("правило ограничения домена") по умолчанию запрещает междоменные запросы. CORS предоставляет веб-серверам возможность контролировать междоменные запросы и позволяет производить безопасный обмен данными между разными доменами.

Подробней:
* https://developer.mozilla.org/ru/docs/Словарь/CORS
* https://habrahabr.ru/company/pentestit/blog/337146/
* https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy

---

## 31. Что такое архитектурный-паттерн MVC?

`Model-View-Controller` (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо

* **Модель** (Model) предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.

* **Представление** (View) отвечает за отображение данных модели пользователю, реагируя на изменения модель.

* **Контроллер** (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений.

Есть passive model & active model. Но из-за веба, этот паттер, претерпел изменения, что вносит смуту, и вряд ли получится найти 3 программиста, у которых совпадет понимание этого паттерна. Главное понимать общие черты, чтобы суметь отличить от MVVM(bindings) ;)

**Признаки контроллера**:
* Контроллер определяет, какие представление должно быть отображено в данный момент;
* События представления могут повлиять только на контроллер.контроллер может повлиять на модель и определить другое представление.
* Возможно несколько представлений только для одного контроллера;

Подробней:
* https://codepen.io/fikorte/pen/Rjgmqr?limit=all&page=2&q=mvc+example
* https://codepen.io/broneks/pen/RWRLRG?editors=1010
* https://codepen.io/kyliepace/pen/aNepxV?editors=1010
* https://codepen.io/bobodeity/pen/xPbwzX
* https://habrahabr.ru/company/devexpress/blog/305812/
* https://codepen.io/MrCheater/pen/GqQpYY?editors=1010

---

## 32. Что такое архитектурный-паттерн MVP?

Данный подход позволяет создавать абстракцию представления. Для этого необходимо выделить интерфейс представления с определенным набором свойств и методов. Презентер, в свою очередь, получает ссылку на реализацию интерфейса, подписывается на события представления и по запросу изменяет модель.

**Признаки презентера**:
* Двухсторонняя коммуникация с представлением;
* Представление взаимодействует напрямую с презентером, путем вызова соответствующих функций или событий экземпляра презентера;
* Презентер взаимодействует с View путем использования специального интерфейса, реализованного представлением;
* Один экземпляр презентера связан с одним отображением.

Подробеней:
* https://habrahabr.ru/post/215605/

* https://stackoverflow.com/questions/2056/what-are-mvp-and-mvc-and-what-is-the-difference

* https://habrahabr.ru/post/171925/

* https://habrahabr.ru/company/mobileup/blog/313538/

---

## 33. Что такое архитектурный-паттерн MVVM?

Данный подход позволяет связывать элементы представления со свойствами и событиями View-модели. Можно утверждать, что каждый слой этого паттерна не знает о существовании другого слоя.

**Признаки презентера**:
* Двухсторонняя коммуникация с представлением;
* View-модель — это абстракция представления. Обычно означает, что свойства представления совпадают со свойствами View-модели / модели
* View-модель не имеет ссылки на интерфейс представления (IView). Изменение состояния View-модели автоматически изменяет представление и наоборот, поскольку используется механизм связывания данных (Bindings)
* Один экземпляр View-модели связан с одним отображением.

Подробней:
* https://habrahabr.ru/post/215605/

* https://ru.wikipedia.org/wiki/Model-View-ViewModel

* https://habrahabr.ru/company/mobileup/blog/313538/

---

## 34. Что такое DOM?

Объектная Модель Документа (DOM) является программным интерфейсом для HTML, XML и SVG документов. Это обеспечивает структурированное представление документа (дерева), и определяет способ, по которому структура может быть доступна для программы, для изменения структуры документа, его стиля и содержания. DOM обеспечивает представление документа в виде структурированной группы узлов и объектов, которые имеют свойства и методы. По сути, она связывает веб -страницы со скриптами или языками программирования.

DOM (`Document Object Model` — «объектная модель документа») — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.

Подробней:
* https://developer.mozilla.org/ru/docs/DOM/DOM_Reference
* https://ru.wikipedia.org/wiki/Document_Object_Model

---

## 35. Что такое Virtual DOM? Как он работает?

`Virtual DOM`- это абстракция HTML DOM, которая выборочно отображает поддеревья узлов на основе изменений состояния. Он обеспечивает минимальное количество манипуляций с DOM, чтобы поддерживать ваши компоненты в актуальном состоянии.

Подробней:
* https://medium.com/treenodes/intro-to-react-2-41b84dd74b5d
* https://habrahabr.ru/post/256965/
* https://medium.com/devschacht/how-to-write-your-own-virtual-dom-c166b56cf01f


---

## 36. Что такое Shadow DOM?

Спецификация Shadow DOM является отдельным стандартом. Частично он уже используется для обычных DOM-элементов, но также применяется для создания веб-компонентов.

`Shadow DOM` – это внутренний DOM элемента, который существует отдельно от внешнего документа. В нём могут быть свои ID, свои стили и так далее. Причём снаружи его, без применения специальных техник, не видно, поэтому не возникает конфликтов.

Подробней:
* https://learn.javascript.ru/shadow-dom
* https://habrahabr.ru/post/180377/
* https://habrahabr.ru/post/259187/
* https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM

---

## 37.Чем отличаются между собой Shadow DOM и Virtual DOM и Regular Dom?

`Virtual DOM` – полное представление реального DOM. Его самой важной особенностью является группировка изменений и выполнение одиночного повторного рендеринга вместо множества мелких. Если коротко, то можно сказать, что Virtual DOM решает проблемы, связанные с производительностью (Не буду вдаваться в подробности принципа работы Virtual DOM. В рамках этой статьи достаточно знать, зачем он нужен.)

`Shadow DOM`, как настоящий интроверт, надежно защищает себя от влияния окружающих элементов и не заинтересован и не интересуется изменениями снаружи. Спросите себя, какую главную UI-проблему решают фреймворки типа React и VueJS?

**Инкапсуляция**

`CSS` – сложная штука. Все становится еще сложнее, если вы соединяете стили, пытаясь повторно их использовать в различных комбинациях. Это неизбежно приводит к регрессивным ошибкам интерфейса, сложному обслуживанию и плохой масштабируемости. И все же, я считаю, что основная проблема это не CSS, а то, как мы его используем.

`Shadow DOM` – инструмент, помогающий обойти инкапсуляцию DOM на нативном уровне. Суть не просто в CSS, а в элементах.

В отличие от обычного DOM Shadow DOM идет маленькими кусочками. То есть это не полное представление всего DOM. Представьте Shadow DOM в виде лего, формирующего реальный DOM, где каждый кирпичик представляет собой отдельный DOM.

`Shadow DOM` – это инкапсуляция.

Подробней:
* https://develoger.com/shadow-dom-virtual-dom-889bf78ce701

---

## 38. Что такое ООП и на каких 4х постулатах оно стоит?

1. абстрагирование для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счете — контекстное понимание предмета, формализуемое в виде класса;

2. инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;

3. наследование для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя все остальное, учтенное на предыдущих шагах;

4. полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.

Подробней:

* https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование

---

## 39.Что такое инкапсуляция?

Инкапсуляция - это механизм, который объединяет данные и методы, манипулирующие этими данными, и защищает и то и другое от внешнего вмешательства или неправильного использования. Когда методы и данные объединяются таким способом, создается объект.

Подробней:
* https://ru.wikipedia.org/wiki/Инкапсуляция_(программирование)
* https://habrahabr.ru/post/87205/

---

## 40. Какие классификации паттернов проектирования Вы знаете?

Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.

Структурные паттерны показывают различные способы построения связей между объектами.

Поведенческие паттерны заботятся об эффективной коммуникации между объектами.

Подробней:
* https://refactoring.guru/ru/design-patterns/classification
* https://ru.wikipedia.org/wiki/Шаблон_проектирования

---

## 41. Назовите паттерны, которые относятся к порождающим

* **Одиночка(Singleton)**:
Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)

https://refactoring.guru/ru/design-patterns/singleton

https://github.com/torokmark/design_patterns_in_typescript/tree/master/singleton

* **Абстрактная фабрика(Abstract factory)**
Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

https://ru.wikipedia.org/wiki/Абстрактная_фабрика_(шаблон_проектирования)

https://refactoring.guru/ru/design-patterns/abstract-factory

https://github.com/torokmark/design_patterns_in_typescript/tree/master/abstract_factory

* **Фабричный метод(Factory method)**
Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

https://ru.wikipedia.org/wiki/Фабричный_метод_(шаблон_проектирования)

https://refactoring.guru/ru/design-patterns/factory-method

https://github.com/torokmark/design_patterns_in_typescript/tree/master/factory_method

* **Строитель(Builder)**
Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

https://ru.wikipedia.org/wiki/Строитель_(шаблон_проектирования)

https://refactoring.guru/ru/design-patterns/builder

https://github.com/torokmark/design_patterns_in_typescript/tree/master/builder

* **Прототип(Prototype)**
Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

https://ru.wikipedia.org/wiki/Прототип_(шаблон_проектирования)

https://refactoring.guru/ru/design-patterns/prototype

https://github.com/torokmark/design_patterns_in_typescript/tree/master/prototype

* **Менее известные**:
	* **Отложенная инициализация(Lazy initialization)**
		Объект, инициализируемый во время первого обращения к нему.

		https://ru.wikipedia.org/wiki/Отложенная_инициализация

   * **Пул одиночек(Multiton)**
		Гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к ним.

		https://ru.wikipedia.org/wiki/Объектный_пул

	* **Получение ресурса есть инициализация(Resource acquisition is initialization (RAII))**
	Получение некоторого ресурса совмещается с инициализацией, а освобождение — с уничтожением объекта.

	https://ru.wikipedia.org/wiki/Получение_ресурса_есть_инициализация


---

## 42. Назовите паттерны, которые относятся к структурным

* **Адаптер(Adapter / Wrapper)**
	Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

	https://ru.wikipedia.org/wiki/Адаптер_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/adapter

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/adapter

* **Мост(Bridge)**
	Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

	https://ru.wikipedia.org/wiki/Мост_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/bridge

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/bridge

* **Компоновщик(Composite)**
	Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, если бы это был единичный объект.

	https://ru.wikipedia.org/wiki/Composite

	https://refactoring.guru/ru/design-patterns/composite

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/composite

* **Декоратор(Decorator)**
	Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

	https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/decorator

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/decorator

* **Фасад(Facade)**
	Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

	https://ru.wikipedia.org/wiki/Фасад_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/facade

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/facade

* **Приспособленец(Flyweight) или Легковес**
	Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативной память за счёт экономного разделения общего состояния объектов между собой, вместо хранения одинаковых данных в каждом объекте.

	https://ru.wikipedia.org/wiki/Flyweight

	https://refactoring.guru/ru/design-patterns/flyweight

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/flyweight

* **Заместитель(Proxy)**
	Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

	https://ru.wikipedia.org/wiki/Proxy_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/proxy

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/proxy

* **Менее известные:**
	* **Единая точка входа(Front controller)**
	Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.

	 https://ru.wikipedia.org/wiki/Единая_точка_входа_(шаблон_проектирования)


---

## 43. Назовите паттерны, которые относятся к поведенческим

* **Цепочка обязанностей(Chain of responsibility)**
	Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

	https://ru.wikipedia.org/wiki/Chain_of_Responsibility

	https://refactoring.guru/ru/design-patterns/chain-of-responsibility

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/chain_of_responsibility

* **Команда, Action, Transaction(Command)**
	Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

	https://ru.wikipedia.org/wiki/Команда_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/command

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/command

* **Интерпретатор(Interpreter)**
	Решает часто встречающуюся, но подверженную изменениям, задачу.

	https://ru.wikipedia.org/wiki/Интерпретатор_(шаблон_проектирования)

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/interpreter

* **Итератор, Cursor(Iterator)**
	Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

	https://ru.wikipedia.org/wiki/Итератор_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/iterator

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/iterator

* **Посредник(Mediator)**
	Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

	https://ru.wikipedia.org/wiki/Mediator

	https://refactoring.guru/ru/design-patterns/mediator

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/mediator

* **Хранитель(Memento)**
	Снимок — это поведенческий паттерн проектирования, который позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов.

	https://ru.wikipedia.org/wiki/Хранитель_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/memento

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/memento

* **Наблюдатель(Observer)**
	Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

	https://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/observer

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/observer

	https://ru.wikipedia.org/wiki/Издатель-подписчик_(шаблон_проектирования)

* **Состояние(State)**
	Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

	https://ru.wikipedia.org/wiki/Состояние_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/state

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/state

* **Стратегия(Strategy)**
	Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс. После чего, алгоритмы можно взаимозаменять прямо во время исполнения программы.

	https://ru.wikipedia.org/wiki/Стратегия_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/strategy

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/strategy

* **Шаблонный метод(Template method)**
	Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

	https://ru.wikipedia.org/wiki/Шаблонный_метод_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/template-method

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/template_method

* **Посетитель(Visitor)**
	Посетитель — это поведенческий паттерн проектирования, который позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.

	https://ru.wikipedia.org/wiki/Посетитель_(шаблон_проектирования)

	https://refactoring.guru/ru/design-patterns/visitor

	https://github.com/torokmark/design_patterns_in_typescript/tree/master/visitor

---

## 44. Что такое функциональное программирование?

Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).

Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.

Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).

Подробней:
* https://ru.wikipedia.org/wiki/Функциональное_программирование
* https://habrahabr.ru/post/142351/
* https://ru.stackoverflow.com/questions/417898/Что-такое-функциональное-программирование
* https://tproger.ru/translations/functional-programming-concepts/
* https://habrahabr.ru/post/337880/

---

## 45. В чём разница между императивным и декларативным программированием?
Также подумаем о различиях ООП и ФП с точки зрения разницы между «императивным» и «декларативным» программированием.

Это общие термины, которые описывают общие характеристики нескольких парадигм программирования. ФП – пример декларативного программирования, а ООП – пример императивного программирования.

В базовом смысле императивное программирование касается того, как делать. Эта парадигма объясняет шаги конкретным образом и характеризуется циклами `for` и `while`, операторами `if` и `switch` и так далее.

```js
const sumArray = array => {
  let result = 0;
  for (let i = 0; i < array.length; i++) { 
    result += array[i]
  }; 
  return result;
}
```

Напротив, декларативное программирование сосредотачивается на том, что делать. При этом абстрагируется от описания, как делать, и опирается на выражения. Это часто приводит к получению более краткого кода, но при масштабировании его становится сложнее отлаживать из-за меньшей прозрачности.

Вот декларативный подход к функции `sumArray()`, написанной выше.

```js
const sumArray = array => { return array.reduce((x, y) => x + y) };
```

---

## 46. Что такое прототип-ориентированное наследование?
Наконец, мы подошли к прототип-ориентированному наследованию. Стилей объектно-ориентированного программирования несколько, и JavaScript использует прототип-ориентированное наследование. Система организует повторяющееся поведение с использованием действующих объектов – «прототипов».

Даже если идея прототипов окажется новой, JavaScript-разработчик сталкивается с этой системой, когда использует встроенные методы. Например, функции для работы с массивами – `map`, `reduce`, `splice` и другие – методы объекта `Array.prototype`. На самом деле, каждый экземпляр массива (определённый с помощью квадратных скобок `[]` или, что реже, с использованием `new Array()`) наследуется от `Array.prototype`. Поэтому методы вроде `map`, `reduce` и `splice` доступны по умолчанию.

То же относится почти всем другим встроенным объектам, таким как строки и логические значения. Только у некоторых, таких как `Infinity`, `NaN`, `null` и `undefined`, отсутствуют свойства или методы.

В конце цепочки прототипов находим `Object.prototype`, и почти каждый объект в JavaScript – экземпляр `Object.prototype`. `Array.prototype` и `String.prototype`, например, оба наследуют свойства и методы от `Object.prototype`.

Чтобы добавить свойства и методы к объекту с использованием синтаксиса прототипа, инициируем объект как функцию и используем ключевое слово `prototype` для добавления свойств и методов:

```js
function Person() {};
Person.prototype.forename = "John";
Person.prototype.surname = "Smith";
```

---

## 47. Стоит ли переопределять или расширять поведение прототипов?
Изменять поведение встроенных прототипов можно так же, как и создавать и расширять собственные прототипы, но почти каждый JavaScript-разработчик и большинство компаний не рекомендуют этого.

Если хотим, чтобы объекты имели одинаковое поведение, создаём пользовательский объект (или определяем собственный «класс» или «подкласс»), который наследуется от встроенного прототипа без внесения изменений в сам прототип. Если работаем с другими разработчиками, у них отчётливые ожидания относительно поведения JavaScript по умолчанию, и редактирование этого поведения по умолчанию может легко привести к ошибкам.

Однако стоит отметить, что не все разделяют это сильное сопротивление расширению встроенных прототипов. В [статье 2005 года](https://brendaneich.com/2005/06/javascript-1-2-and-in-between/) создатель JavaScript Брендан Эйх намекнул, что прототипная система на самом деле создавалась отчасти для возможности расширения!

---

## 48. Чем отличается выражение функции (Function Expression) от объявления функции (Function Declaration)?
Объявление функции использует ключевое слово function, за которым следует имя функции. Напротив, выражение функции начинается с `var`, `let` или `const`, за которым следует имя функции и оператор присваивания `=`. Вот примеры:

```js
// Объявление функции
function sum(x, y) {
  return x + y;
};

// Выражение функции: ES5
var sum = function(x, y) {
  return x + y;
};
// Выражение функции: ES6+
const sum = (x, y) => { return x + y };
```
При использовании главное отличие состоит в том, что объявления функций «**поднимаются**» (hoisted), а выражение функций – нет. Это означает, что объявления функций перемещаются интерпретатором JavaScript в верхнюю часть области видимости. Поэтому используем объявление функции и вызываем эту функцию в любом месте кода. Напротив, выражение функции вызывается только в линейной последовательности: определяется перед вызовом.

Сегодня JavaScript-разработчик предпочитает выражения функций по двум причинам:

* В первую очередь, функциональные выражения помогают создать более предсказуемую, структурированную кодовую базу. Конечно, этого можно достичь также и с объявлениями за счёт простоты избавления от грязного кода.
* Второе, используется синтаксис ES6 для выражений функций. Как правило, получается более кратко, а `let` и `const` предоставляют больше контроля над тем, можно ли переназначить переменную или нет, как увидим в следующем вопросе.


---

## 49. Почему `Math.max()` меньше, чем `Math.min()`?
То, что `Math.max() > Math.min()` возвращает `false`, звучит неправильно, но на самом деле, в этом много смысла. Если аргументы не указаны, `Math.min()` возвращает бесконечность `infinity`, а `Math.max()` возвращает `-infinity`. Это часть спецификации для методов `max()` и `min()`, но за выбором стоит логика. Взгляните на код:

```js
Math.min(1) 
// 1
Math.min(1, infinity)
// 1
Math.min(1, -infinity)
// -infinity
```

Если `-infinity` считался бы аргументом по умолчанию для `Math.min()`, то каждый результат равнялся бы `-infinity`, что бесполезно. Поскольку аргумент по умолчанию равен `infinity`, добавление другого аргумента вернёт это число – желаемое поведение.

---

## 50. Почему `0.1 + 0.2 === 0.3` возвращает `false`?
Вкратце, это связано с тем, насколько точно JavaScript хранит числа с плавающей запятой в двоичном виде. Если введём следующие уравнения в консоль Google Chrome, то получим:

```js
0.1 + 0.2
// 0.30000000000000004
0.1 + 0.2 - 0.2
// 0.10000000000000003
0.1 + 0.7
// 0.7999999999999999
```

Это вряд ли вызовет проблемы при вычислении простых уравнений, где не нужна высокая степень точности. Но вызывает головную боль даже в несложных приложениях, когда выполняется проверка на равенство. Рассмотрим решения этого вопроса.

### Фиксированная точка
Например, если известна максимальная точность, которая понадобится (допустим, работаем с валютами), используем целочисленный тип для хранения значения. Таким образом, вместо `4,99` долларов, запишем `499`, и будем выполнять любые уравнения с этим значением. Затем отобразим результат конечному пользователю с использованием выражения вроде `result = (value / 100).toFixed(2)`, которое возвращает строку.

### Двоично-десятичный код
Если точность в самом деле важна, другой вариант – использовать формат двоично-десятичного кода (BCD), к которому обращаемся в JavaScript с помощью [библиотеки BCD](https://formats.kaitai.io/bcd/javascript.html). Каждое десятичное значение хранится отдельно в одном байте (8 бит). Это неэффективно, поскольку байт хранит 16 отдельных значений, а эта система использует только значения 0-9. Однако, если точность важна для приложения, то стоит пойти на компромисс.

---
---
В целом, надеюсь, что эти вопросы помогли вам лучше понять JavaScript – как основные функции, так и особенности – и что помогут вам лучше подготовиться к следующему собеседованию.